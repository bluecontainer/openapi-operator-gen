/*
Copyright 2024 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package runtime

import (
	"testing"
)

func TestNewURLBuilder(t *testing.T) {
	builder := NewURLBuilder("/pet/{petId}")
	if builder == nil {
		t.Fatal("NewURLBuilder returned nil")
	}
	if builder.basePath != "/pet/{petId}" {
		t.Errorf("expected basePath '/pet/{petId}', got '%s'", builder.basePath)
	}
}

func TestWithPathParam(t *testing.T) {
	tests := []struct {
		name     string
		basePath string
		params   map[string]string
		expected string
	}{
		{
			name:     "single path param",
			basePath: "/pet/{petId}",
			params:   map[string]string{"petId": "123"},
			expected: "https://api.example.com/pet/123",
		},
		{
			name:     "multiple path params",
			basePath: "/pet/{petId}/photo/{photoId}",
			params:   map[string]string{"petId": "123", "photoId": "456"},
			expected: "https://api.example.com/pet/123/photo/456",
		},
		{
			name:     "empty value ignored",
			basePath: "/pet/{petId}",
			params:   map[string]string{"petId": ""},
			expected: "https://api.example.com/pet/{petId}",
		},
		{
			name:     "special characters encoded",
			basePath: "/pet/{petId}",
			params:   map[string]string{"petId": "hello world"},
			expected: "https://api.example.com/pet/hello%20world",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			builder := NewURLBuilder(tt.basePath)
			for name, value := range tt.params {
				builder.WithPathParam(name, value)
			}
			result := builder.Build("https://api.example.com")
			if result != tt.expected {
				t.Errorf("expected '%s', got '%s'", tt.expected, result)
			}
		})
	}
}

func TestWithPathParamInt(t *testing.T) {
	tests := []struct {
		name     string
		basePath string
		param    string
		value    int64
		expected string
	}{
		{
			name:     "positive int",
			basePath: "/pet/{petId}",
			param:    "petId",
			value:    123,
			expected: "https://api.example.com/pet/123",
		},
		{
			name:     "zero value ignored",
			basePath: "/pet/{petId}",
			param:    "petId",
			value:    0,
			expected: "https://api.example.com/pet/{petId}",
		},
		{
			name:     "negative int",
			basePath: "/order/{orderId}",
			param:    "orderId",
			value:    -1,
			expected: "https://api.example.com/order/-1",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := NewURLBuilder(tt.basePath).
				WithPathParamInt(tt.param, tt.value).
				Build("https://api.example.com")
			if result != tt.expected {
				t.Errorf("expected '%s', got '%s'", tt.expected, result)
			}
		})
	}
}

func TestWithQueryParam(t *testing.T) {
	tests := []struct {
		name     string
		basePath string
		params   map[string]string
		expected string
	}{
		{
			name:     "single query param",
			basePath: "/pet/findByStatus",
			params:   map[string]string{"status": "available"},
			expected: "https://api.example.com/pet/findByStatus?status=available",
		},
		{
			name:     "multiple query params",
			basePath: "/pet/findByStatus",
			params:   map[string]string{"status": "available", "limit": "10"},
			expected: "https://api.example.com/pet/findByStatus?limit=10&status=available",
		},
		{
			name:     "empty value ignored",
			basePath: "/pet/findByStatus",
			params:   map[string]string{"status": ""},
			expected: "https://api.example.com/pet/findByStatus",
		},
		{
			name:     "special characters encoded",
			basePath: "/search",
			params:   map[string]string{"q": "hello world"},
			expected: "https://api.example.com/search?q=hello+world",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			builder := NewURLBuilder(tt.basePath)
			for name, value := range tt.params {
				builder.WithQueryParam(name, value)
			}
			result := builder.Build("https://api.example.com")
			if result != tt.expected {
				t.Errorf("expected '%s', got '%s'", tt.expected, result)
			}
		})
	}
}

func TestWithQueryParamInt(t *testing.T) {
	result := NewURLBuilder("/items").
		WithQueryParamInt("limit", 10).
		WithQueryParamInt("offset", 0). // zero ignored
		Build("https://api.example.com")

	expected := "https://api.example.com/items?limit=10"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestWithQueryParamFloat(t *testing.T) {
	result := NewURLBuilder("/products").
		WithQueryParamFloat("minPrice", 19.99).
		WithQueryParamFloat("maxPrice", 0). // zero ignored
		Build("https://api.example.com")

	expected := "https://api.example.com/products?minPrice=19.99"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestWithQueryParamBool(t *testing.T) {
	result := NewURLBuilder("/items").
		WithQueryParamBool("verbose", true).
		WithQueryParamBool("debug", false). // false ignored
		Build("https://api.example.com")

	expected := "https://api.example.com/items?verbose=true"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestWithQueryParamArray(t *testing.T) {
	result := NewURLBuilder("/pet/findByTags").
		WithQueryParamArray("tags", []string{"tag1", "tag2", "tag3"}).
		Build("https://api.example.com")

	expected := "https://api.example.com/pet/findByTags?tags=tag1&tags=tag2&tags=tag3"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestWithQueryParamArrayEmpty(t *testing.T) {
	result := NewURLBuilder("/pet/findByTags").
		WithQueryParamArray("tags", []string{}).
		Build("https://api.example.com")

	expected := "https://api.example.com/pet/findByTags"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestWithQueryParamIntArray(t *testing.T) {
	result := NewURLBuilder("/items").
		WithQueryParamIntArray("ids", []int64{1, 2, 3}).
		Build("https://api.example.com")

	expected := "https://api.example.com/items?ids=1&ids=2&ids=3"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestWithResourceID(t *testing.T) {
	tests := []struct {
		name       string
		basePath   string
		resourceID string
		expected   string
	}{
		{
			name:       "append resource ID",
			basePath:   "/pet",
			resourceID: "123",
			expected:   "https://api.example.com/pet/123",
		},
		{
			name:       "path with trailing slash",
			basePath:   "/pet/",
			resourceID: "123",
			expected:   "https://api.example.com/pet/123",
		},
		{
			name:       "empty resource ID ignored",
			basePath:   "/pet",
			resourceID: "",
			expected:   "https://api.example.com/pet",
		},
		{
			name:       "special characters encoded",
			basePath:   "/pet",
			resourceID: "abc/def",
			expected:   "https://api.example.com/pet/abc%2Fdef",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := NewURLBuilder(tt.basePath).
				WithResourceID(tt.resourceID).
				Build("https://api.example.com")
			if result != tt.expected {
				t.Errorf("expected '%s', got '%s'", tt.expected, result)
			}
		})
	}
}

func TestWithResourceIDAlreadyInPath(t *testing.T) {
	// When resource ID is already set via path param, don't append again
	result := NewURLBuilder("/pet/{petId}").
		WithPathParam("petId", "123").
		WithResourceID("123").
		Build("https://api.example.com")

	expected := "https://api.example.com/pet/123"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestBuildForCreate(t *testing.T) {
	// BuildForCreate should not append resource ID
	result := NewURLBuilder("/pet").
		WithResourceID("123"). // should be ignored
		WithQueryParam("api_key", "secret").
		BuildForCreate("https://api.example.com")

	expected := "https://api.example.com/pet?api_key=secret"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestComplexURL(t *testing.T) {
	result := NewURLBuilder("/pet/{petId}/uploadImage").
		WithPathParam("petId", "123").
		WithQueryParam("additionalMetadata", "my photo").
		Build("https://api.example.com")

	expected := "https://api.example.com/pet/123/uploadImage?additionalMetadata=my+photo"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestBaseURLTrailingSlash(t *testing.T) {
	// Base URL with trailing slash should work correctly
	result := NewURLBuilder("/pet/{petId}").
		WithPathParam("petId", "123").
		Build("https://api.example.com/")

	expected := "https://api.example.com/pet/123"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestHasUnsubstitutedParams(t *testing.T) {
	tests := []struct {
		name     string
		basePath string
		params   map[string]string
		expected bool
	}{
		{
			name:     "no placeholders",
			basePath: "/pet",
			params:   nil,
			expected: false,
		},
		{
			name:     "all substituted",
			basePath: "/pet/{petId}",
			params:   map[string]string{"petId": "123"},
			expected: false,
		},
		{
			name:     "unsubstituted placeholder",
			basePath: "/pet/{petId}",
			params:   nil,
			expected: true,
		},
		{
			name:     "partial substitution",
			basePath: "/pet/{petId}/photo/{photoId}",
			params:   map[string]string{"petId": "123"},
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			builder := NewURLBuilder(tt.basePath)
			for name, value := range tt.params {
				builder.WithPathParam(name, value)
			}
			result := builder.HasUnsubstitutedParams()
			if result != tt.expected {
				t.Errorf("expected %v, got %v", tt.expected, result)
			}
		})
	}
}

func TestGetUnsubstitutedParams(t *testing.T) {
	builder := NewURLBuilder("/pet/{petId}/photo/{photoId}").
		WithPathParam("petId", "123")

	params := builder.GetUnsubstitutedParams()
	if len(params) != 1 {
		t.Fatalf("expected 1 unsubstituted param, got %d", len(params))
	}
	if params[0] != "photoId" {
		t.Errorf("expected 'photoId', got '%s'", params[0])
	}
}

func TestReset(t *testing.T) {
	builder := NewURLBuilder("/pet/{petId}").
		WithPathParam("petId", "123").
		WithQueryParam("status", "available").
		WithResourceID("456")

	builder.Reset()

	// After reset, should produce URL with unsubstituted path param
	result := builder.Build("https://api.example.com")
	expected := "https://api.example.com/pet/{petId}"
	if result != expected {
		t.Errorf("expected '%s', got '%s'", expected, result)
	}
}

func TestClone(t *testing.T) {
	original := NewURLBuilder("/pet/{petId}").
		WithPathParam("petId", "123").
		WithQueryParam("status", "available")

	clone := original.Clone()

	// Modify clone
	clone.WithQueryParam("limit", "10")

	// Original should be unchanged
	originalURL := original.Build("https://api.example.com")
	expectedOriginal := "https://api.example.com/pet/123?status=available"
	if originalURL != expectedOriginal {
		t.Errorf("original modified, expected '%s', got '%s'", expectedOriginal, originalURL)
	}

	// Clone should have the additional param
	cloneURL := clone.Build("https://api.example.com")
	expectedClone := "https://api.example.com/pet/123?limit=10&status=available"
	if cloneURL != expectedClone {
		t.Errorf("clone incorrect, expected '%s', got '%s'", expectedClone, cloneURL)
	}
}

func TestFluentAPI(t *testing.T) {
	// Test that all methods return *URLBuilder for chaining
	result := NewURLBuilder("/pet/{petId}").
		WithPathParam("petId", "123").
		WithPathParamInt("ordinal", 1).
		WithPathParams(map[string]string{"extra": "value"}).
		WithQueryParam("status", "available").
		WithQueryParamInt("limit", 10).
		WithQueryParamFloat("minPrice", 9.99).
		WithQueryParamBool("verbose", true).
		WithQueryParamArray("tags", []string{"a", "b"}).
		WithQueryParamIntArray("ids", []int64{1, 2}).
		WithQueryParams(map[string]string{"foo": "bar"}).
		WithResourceID("999").
		Build("https://api.example.com")

	// Just verify it doesn't panic and produces a URL
	if result == "" {
		t.Error("fluent API produced empty URL")
	}
}

func TestIsZeroValue(t *testing.T) {
	tests := []struct {
		name     string
		value    interface{}
		expected bool
	}{
		{"nil", nil, true},
		{"empty string", "", true},
		{"non-empty string", "hello", false},
		{"zero int", 0, true},
		{"non-zero int", 42, false},
		{"zero int64", int64(0), true},
		{"non-zero int64", int64(123), false},
		{"zero float", 0.0, true},
		{"non-zero float", 3.14, false},
		{"false bool", false, true},
		{"true bool", true, false},
		{"nil slice", []string(nil), true},
		{"empty slice", []string{}, false}, // Empty slice is not nil, so not zero
		{"non-empty slice", []string{"a"}, false},
		{"nil map", map[string]int(nil), true},
		{"empty map", map[string]int{}, false}, // Empty map is not nil
		{"nil pointer", (*int)(nil), true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := IsZeroValue(tt.value)
			if result != tt.expected {
				t.Errorf("IsZeroValue(%v) = %v, expected %v", tt.value, result, tt.expected)
			}
		})
	}
}
