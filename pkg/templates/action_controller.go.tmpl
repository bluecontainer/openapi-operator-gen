/*
Copyright {{ .Year }} Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	{{ .APIVersion }} "{{ .ModuleName }}/api/{{ .APIVersion }}"
	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
)

const (
	{{ .KindLower }}Finalizer = "{{ .APIGroup }}/finalizer"
)

// {{ .Kind }}Reconciler reconciles a {{ .Kind }} action object
type {{ .Kind }}Reconciler struct {
	client.Client
	Scheme           *runtime.Scheme
	HTTPClient       *http.Client
	EndpointResolver *endpoint.Resolver
	// BaseURL is used when EndpointResolver is nil (static URL mode)
	BaseURL string
}

// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }},verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/status,verbs=get;update;patch

// Reconcile executes the action and updates the status
func (r *{{ .Kind }}Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the {{ .Kind }} instance
	instance := &{{ .APIVersion }}.{{ .Kind }}{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("{{ .Kind }} resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get {{ .Kind }}")
		return ctrl.Result{}, err
	}

	// Handle deletion
	if instance.ObjectMeta.DeletionTimestamp != nil {
		if controllerutil.ContainsFinalizer(instance, {{ .KindLower }}Finalizer) {
			// No cleanup needed for action resources
			controllerutil.RemoveFinalizer(instance, {{ .KindLower }}Finalizer)
			if err := r.Update(ctx, instance); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	// Add finalizer if not present
	if !controllerutil.ContainsFinalizer(instance, {{ .KindLower }}Finalizer) {
		controllerutil.AddFinalizer(instance, {{ .KindLower }}Finalizer)
		if err := r.Update(ctx, instance); err != nil {
			return ctrl.Result{}, err
		}
		return ctrl.Result{Requeue: true}, nil
	}

	// Determine if action should be executed
	shouldExecute := false
	var requeueAfter time.Duration

	if instance.Status.State == "" || instance.Status.State == "Pending" {
		// First execution
		shouldExecute = true
	} else if instance.Status.State == "Completed" || instance.Status.State == "Failed" {
		// Check if spec changed (always re-execute on spec change)
		if instance.Status.ObservedGeneration != instance.Generation {
			logger.Info("Spec changed, re-executing action")
			shouldExecute = true
		} else if instance.Spec.ReExecuteInterval != nil && instance.Spec.ReExecuteInterval.Duration > 0 {
			// Check if re-execution interval has elapsed
			if instance.Status.LastExecutionTime == nil {
				// Should not happen, but handle gracefully
				shouldExecute = true
			} else {
				elapsed := time.Since(instance.Status.LastExecutionTime.Time)
				interval := instance.Spec.ReExecuteInterval.Duration

				if elapsed >= interval {
					logger.Info("Re-execution interval elapsed, re-executing",
						"interval", interval, "elapsed", elapsed)
					shouldExecute = true
				} else {
					// Schedule next execution
					requeueAfter = interval - elapsed
					logger.V(1).Info("Scheduling next re-execution", "requeueAfter", requeueAfter)
				}
			}
		} else {
			// No re-execution interval set, one-shot behavior
			logger.V(1).Info("Action already executed and no re-execution interval set, skipping")
			return ctrl.Result{}, nil
		}
	}

	if !shouldExecute {
		// Not time to execute yet, requeue for next interval
		return ctrl.Result{RequeueAfter: requeueAfter}, nil
	}

	// Execute the action
	if err := r.executeAction(ctx, instance); err != nil {
		// On error, still schedule next re-execution if interval is set
		if instance.Spec.ReExecuteInterval != nil && instance.Spec.ReExecuteInterval.Duration > 0 {
			return ctrl.Result{RequeueAfter: instance.Spec.ReExecuteInterval.Duration}, nil
		}
		return ctrl.Result{}, nil
	}

	// After successful execution, schedule next re-execution if interval is set
	if instance.Spec.ReExecuteInterval != nil && instance.Spec.ReExecuteInterval.Duration > 0 {
		return ctrl.Result{RequeueAfter: instance.Spec.ReExecuteInterval.Duration}, nil
	}

	return ctrl.Result{}, nil
}

func (r *{{ .Kind }}Reconciler) getBaseURL(ctx context.Context) (string, error) {
	if r.EndpointResolver != nil {
		return r.EndpointResolver.GetEndpoint()
	}
	if r.BaseURL == "" {
		return "", fmt.Errorf("no base URL configured")
	}
	return r.BaseURL, nil
}

func (r *{{ .Kind }}Reconciler) getBaseURLByOrdinal(ctx context.Context, ordinal *int32) (string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		if ordinal == nil {
			return "", fmt.Errorf("targetPodOrdinal is required when using by-ordinal strategy")
		}
		return r.EndpointResolver.GetEndpointByOrdinal(int(*ordinal))
	}
	return r.getBaseURL(ctx)
}

// resolveBaseURL determines the base URL to use for API requests based on CR targeting fields
func (r *{{ .Kind }}Reconciler) resolveBaseURL(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) (string, error) {
	if r.EndpointResolver != nil {
		namespace := instance.Spec.TargetNamespace
		if namespace == "" {
			namespace = instance.Namespace
		}

		if instance.Spec.TargetHelmRelease != "" {
			return r.EndpointResolver.GetEndpointForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace, instance.Spec.TargetPodOrdinal)
		}

		if instance.Spec.TargetStatefulSet != "" {
			return r.EndpointResolver.GetEndpointForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace, instance.Spec.TargetPodOrdinal)
		}

		if instance.Spec.TargetDeployment != "" {
			return r.EndpointResolver.GetEndpointForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
		}

		if r.EndpointResolver.IsByOrdinalStrategy() {
			return r.getBaseURLByOrdinal(ctx, instance.Spec.TargetPodOrdinal)
		}
	}

	return r.getBaseURL(ctx)
}

// buildActionURL builds the action URL with path parameters substituted
func (r *{{ .Kind }}Reconciler) buildActionURL(baseURL string, instance *{{ .APIVersion }}.{{ .Kind }}) string {
	actionPath := "{{ .ActionPath }}"

	// Substitute path parameters
{{- if .ParentIDParam }}
	actionPath = strings.Replace(actionPath, "{{ "{" }}{{ .ParentIDParam }}{{ "}" }}", instance.Spec.{{ .ParentIDField }}, 1)
{{- end }}
{{- range .PathParams }}
	actionPath = strings.Replace(actionPath, "{{ "{" }}{{ .Name }}{{ "}" }}", fmt.Sprintf("%v", instance.Spec.{{ .GoName }}), 1)
{{- end }}

	return baseURL + actionPath
}

// buildRequestBody builds the JSON request body from spec fields
func (r *{{ .Kind }}Reconciler) buildRequestBody(instance *{{ .APIVersion }}.{{ .Kind }}) ([]byte, error) {
{{- if .HasRequestBody }}
	body := make(map[string]interface{})
{{- range .RequestBodyFields }}
	if !isZeroValue(instance.Spec.{{ .GoName }}) {
		body["{{ .JSONName }}"] = instance.Spec.{{ .GoName }}
	}
{{- end }}
	if len(body) == 0 {
		return nil, nil
	}
	return json.Marshal(body)
{{- else }}
	return nil, nil
{{- end }}
}

{{- if .HasTypedResults }}
// parseResult parses the response body into typed result
{{- if .ResponseIsArray }}
func (r *{{ .Kind }}Reconciler) parseResult(body []byte) ([]{{ .APIVersion }}.{{ .ResultItemType }}, error) {
	var result []{{ .APIVersion }}.{{ .ResultItemType }}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal result: %w", err)
	}
	return result, nil
}
{{- else }}
func (r *{{ .Kind }}Reconciler) parseResult(body []byte) (*{{ .APIVersion }}.{{ .ResultItemType }}, error) {
	var result {{ .APIVersion }}.{{ .ResultItemType }}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal result: %w", err)
	}
	return &result, nil
}
{{- end }}
{{- end }}

// executeActionToEndpoint executes the action against a single endpoint
func (r *{{ .Kind }}Reconciler) executeActionToEndpoint(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, baseURL string, body []byte) ([]byte, int, error) {
	logger := log.FromContext(ctx)

	actionURL := r.buildActionURL(baseURL, instance)

	var bodyReader io.Reader
	if body != nil {
		bodyReader = bytes.NewReader(body)
	}

	req, err := http.NewRequestWithContext(ctx, "{{ .ActionMethod }}", actionURL, bodyReader)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	logger.Info("Executing action", "url", actionURL, "method", "{{ .ActionMethod }}")
	resp, err := r.HTTPClient.Do(req)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, resp.StatusCode, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return respBody, resp.StatusCode, fmt.Errorf("action failed: %s - %s", resp.Status, string(respBody))
	}

	return respBody, resp.StatusCode, nil
}

func (r *{{ .Kind }}Reconciler) executeAction(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) error {
	logger := log.FromContext(ctx)
	now := metav1.Now()

	// Mark as executing
	instance.Status.State = "Executing"
	instance.Status.ExecutedAt = &now
	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status to Executing")
	}

	// Build request body once (reused for all endpoints)
	body, err := r.buildRequestBody(instance)
	if err != nil {
		r.updateStatus(ctx, instance, "Failed", fmt.Sprintf("Failed to build request body: %v", err), 0, 0, 0)
		return err
	}

	// Check if using all-healthy strategy (execute on all endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.EndpointResolver.GetAllHealthyEndpoints()
		if err != nil {
			r.updateStatus(ctx, instance, "Failed", fmt.Sprintf("Failed to get all healthy endpoints: %v", err), 0, 0, 0)
			return err
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - execute on all
			responses := make(map[string]{{ .APIVersion }}.{{ .Kind }}EndpointResponse)
			successCount := 0
			var firstStatusCode int
{{- if .HasTypedResults }}
{{- if .ResponseIsArray }}
			var firstResult []{{ .APIVersion }}.{{ .ResultItemType }}
{{- else }}
			var firstResult *{{ .APIVersion }}.{{ .ResultItemType }}
{{- end }}
{{- end }}

			for _, baseURL := range baseURLs {
				endpointResp := {{ .APIVersion }}.{{ .Kind }}EndpointResponse{
					ExecutedAt: &now,
				}

				respBody, statusCode, err := r.executeActionToEndpoint(ctx, instance, baseURL, body)
				if err != nil {
					endpointResp.Success = false
					endpointResp.StatusCode = statusCode
					endpointResp.Error = err.Error()
					logger.Info("Action failed for endpoint", "endpoint", baseURL, "error", err)
				} else {
					endpointResp.Success = true
					endpointResp.StatusCode = statusCode
{{- if .HasTypedResults }}
					// Parse typed result
					data, parseErr := r.parseResult(respBody)
					if parseErr != nil {
						endpointResp.Success = false
						endpointResp.Error = parseErr.Error()
						logger.Info("Action succeeded but failed to parse response", "endpoint", baseURL, "error", parseErr)
					} else {
						endpointResp.Data = data
						successCount++
						if firstStatusCode == 0 {
							firstStatusCode = statusCode
							firstResult = data
						}
						logger.Info("Action succeeded for endpoint", "endpoint", baseURL, "statusCode", statusCode)
					}
{{- else }}
					endpointResp.Data = &runtime.RawExtension{Raw: respBody}
					successCount++
					if firstStatusCode == 0 {
						firstStatusCode = statusCode
					}
					logger.Info("Action succeeded for endpoint", "endpoint", baseURL, "statusCode", statusCode)
{{- end }}
				}

				responses[baseURL] = endpointResp
			}

			// Update status with all responses
			instance.Status.Responses = responses
			instance.Status.SuccessCount = successCount
			instance.Status.TotalEndpoints = len(baseURLs)

			// Store first successful result as EndpointResponse
			if firstStatusCode != 0 {
				instance.Status.Result = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
					Success:    true,
					StatusCode: firstStatusCode,
{{- if .HasTypedResults }}
					Data:       firstResult,
{{- end }}
					ExecutedAt: &now,
				}
			} else {
				instance.Status.Result = nil
			}

			if successCount == 0 {
				r.updateStatus(ctx, instance, "Failed", fmt.Sprintf("Action failed on all %d endpoints", len(baseURLs)), 0, successCount, len(baseURLs))
				return fmt.Errorf("action failed on all endpoints")
			}

			message := fmt.Sprintf("Action executed on %d/%d endpoints", successCount, len(baseURLs))
			r.updateStatus(ctx, instance, "Completed", message, firstStatusCode, successCount, len(baseURLs))
			return nil
		}
	}

	// Single endpoint case
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		r.updateStatus(ctx, instance, "Failed", fmt.Sprintf("Failed to resolve base URL: %v", err), 0, 0, 0)
		return err
	}

	respBody, statusCode, err := r.executeActionToEndpoint(ctx, instance, baseURL, body)

	instance.Status.HTTPStatusCode = statusCode
	instance.Status.Responses = nil // Clear multi-endpoint responses
	instance.Status.SuccessCount = 0
	instance.Status.TotalEndpoints = 0

	if err != nil {
		// Store failure in EndpointResponse
		instance.Status.Result = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
			Success:    false,
			StatusCode: statusCode,
			Error:      err.Error(),
			ExecutedAt: &now,
		}
		r.updateStatus(ctx, instance, "Failed", err.Error(), statusCode, 0, 0)
		return err
	}

	// Parse and store result as EndpointResponse
{{- if .HasTypedResults }}
	if respBody != nil && len(respBody) > 0 {
		result, parseErr := r.parseResult(respBody)
		if parseErr != nil {
			logger.Error(parseErr, "Failed to parse response as typed result")
			instance.Status.Result = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
				Success:    false,
				StatusCode: statusCode,
				Error:      parseErr.Error(),
				ExecutedAt: &now,
			}
		} else {
			instance.Status.Result = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
				Success:    true,
				StatusCode: statusCode,
				Data:       result,
				ExecutedAt: &now,
			}
		}
	}
{{- else }}
	if respBody != nil && len(respBody) > 0 {
		instance.Status.Result = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
			Success:    true,
			StatusCode: statusCode,
			Data:       &runtime.RawExtension{Raw: respBody},
			ExecutedAt: &now,
		}
	}
{{- end }}

	r.updateStatus(ctx, instance, "Completed", "Action executed successfully", statusCode, 0, 0)
	return nil
}

func (r *{{ .Kind }}Reconciler) updateStatus(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, state, message string, statusCode, successCount, totalEndpoints int) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	instance.Status.State = state
	instance.Status.Message = message
	instance.Status.ObservedGeneration = instance.Generation

	// Only set HTTPStatusCode for single-endpoint mode
	if totalEndpoints == 0 {
		instance.Status.HTTPStatusCode = statusCode
	}

	// Set multi-endpoint counts
	if totalEndpoints > 0 {
		instance.Status.SuccessCount = successCount
		instance.Status.TotalEndpoints = totalEndpoints
	}

	if state == "Completed" || state == "Failed" {
		instance.Status.CompletedAt = &now

		// Update last execution time for interval-based re-execution
		instance.Status.LastExecutionTime = &now

		// Increment execution count
		instance.Status.ExecutionCount++

		// Calculate next execution time if interval is configured
		if instance.Spec.ReExecuteInterval != nil && instance.Spec.ReExecuteInterval.Duration > 0 {
			nextTime := metav1.NewTime(now.Add(instance.Spec.ReExecuteInterval.Duration))
			instance.Status.NextExecutionTime = &nextTime
		} else {
			// Clear next execution time if no interval is set
			instance.Status.NextExecutionTime = nil
		}
	}

	// Update condition
	condition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Completed" {
		condition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, condition)

	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// isZeroValue checks if a value is its zero value
func isZeroValue(v interface{}) bool {
	if v == nil {
		return true
	}
	switch val := v.(type) {
	case string:
		return val == ""
	case int, int32, int64:
		return val == 0
	case float32, float64:
		return val == 0
	case bool:
		return !val
	case []interface{}:
		return len(val) == 0
	case map[string]interface{}:
		return len(val) == 0
	default:
		return false
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *{{ .Kind }}Reconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&{{ .APIVersion }}.{{ .Kind }}{}).
		Complete(r)
}
