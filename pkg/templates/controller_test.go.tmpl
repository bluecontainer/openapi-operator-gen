/*
Copyright {{.Year}} Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"

	{{.APIVersion}} "{{.ModuleName}}/api/{{.APIVersion}}"
)

// =============================================================================
// E2E Testing with Fake Client
// =============================================================================

// reconcileUntilComplete runs the reconciler in a loop until no requeue is requested
// or maxIterations is reached. This simulates the controller-runtime behavior.
func reconcile{{.Kind}}UntilComplete(
	t *testing.T,
	ctx context.Context,
	reconciler *{{.Kind}}Reconciler,
	req ctrl.Request,
	maxIterations int,
) (finalResult ctrl.Result, finalErr error, iterations int) {
	t.Helper()

	for i := 0; i < maxIterations; i++ {
		iterations = i + 1
		result, err := reconciler.Reconcile(ctx, req)

		if err != nil {
			return result, err, iterations
		}

		// If no requeue requested, we're done
		if !result.Requeue && result.RequeueAfter == 0 {
			return result, nil, iterations
		}

		t.Logf("Reconcile iteration %d: Requeue=%v, RequeueAfter=%v", iterations, result.Requeue, result.RequeueAfter)

		// In tests, we don't actually wait for RequeueAfter duration
		// Just continue to next iteration immediately
	}

	return ctrl.Result{}, nil, iterations
}

func Test{{.Kind}}Reconciler_E2E(t *testing.T) {
	// Setup scheme
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// Create mock HTTP server that returns appropriate response types
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		// Sample resource object
		sampleResource := map[string]interface{}{
			"id":   123,
			"name": "Test{{.Kind}}",
		}

		switch r.Method {
		case http.MethodGet:
{{- if .ResponseIsArray}}
			// Response is an array per OpenAPI spec
			json.NewEncoder(w).Encode([]map[string]interface{}{
				sampleResource,
				{"id": 456, "name": "Test{{.Kind}}2"},
			})
{{- else}}
			// Response is a single object per OpenAPI spec
			json.NewEncoder(w).Encode(sampleResource)
{{- end}}
		case http.MethodPost:
			// Return created resource
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(sampleResource)
		case http.MethodPut:
			// Return updated resource
			json.NewEncoder(w).Encode(map[string]interface{}{
				"id":   123,
				"name": "Updated{{.Kind}}",
			})
		case http.MethodDelete:
			w.WriteHeader(http.StatusNoContent)
		default:
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
	}))
	defer server.Close()

	// Create test CR
	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	// Create fake client with the object
	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	// Create reconciler
	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	// Run reconcile loop until complete (max 10 iterations)
	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	result, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 10)

	// Verify no error
	if err != nil {
		t.Fatalf("Reconcile returned error after %d iterations: %v", iterations, err)
	}

	t.Logf("Reconcile completed after %d iterations", iterations)

	// Verify final result (should have periodic requeue for sync)
	if result.RequeueAfter > 0 {
		t.Logf("Final result requests requeue after %v", result.RequeueAfter)
	}

	// Verify status was updated
	var updated {{.APIVersion}}.{{.Kind}}
	if err := fakeClient.Get(ctx, types.NamespacedName{Name: "test-{{.KindLower}}", Namespace: "default"}, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	if updated.Status.State == "" {
		t.Error("expected status.state to be set")
	}
}

func Test{{.Kind}}Reconciler_RequeueBehavior(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// Track request count
	requestCount := 0

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestCount++
		w.Header().Set("Content-Type", "application/json")

		sampleResource := map[string]interface{}{
			"id":   123,
			"name": "Test{{.Kind}}",
		}

		switch r.Method {
		case http.MethodPost:
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(sampleResource)
		case http.MethodGet:
{{- if .ResponseIsArray}}
			json.NewEncoder(w).Encode([]map[string]interface{}{sampleResource})
{{- else}}
			json.NewEncoder(w).Encode(sampleResource)
{{- end}}
		default:
			json.NewEncoder(w).Encode(sampleResource)
		}
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	// First reconcile
	result1, err := reconciler.Reconcile(ctx, req)
	if err != nil {
		t.Fatalf("First reconcile failed: %v", err)
	}

	// Check if requeue was requested
	if result1.Requeue || result1.RequeueAfter > 0 {
		t.Logf("First reconcile requested requeue: Requeue=%v, RequeueAfter=%v", result1.Requeue, result1.RequeueAfter)

		// Simulate the requeue by running reconcile again
		result2, err := reconciler.Reconcile(ctx, req)
		if err != nil {
			t.Fatalf("Second reconcile failed: %v", err)
		}
		t.Logf("Second reconcile: Requeue=%v, RequeueAfter=%v", result2.Requeue, result2.RequeueAfter)
	}

	t.Logf("Total HTTP requests made: %d", requestCount)
}

func Test{{.Kind}}Reconciler_CreateResource(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// Track HTTP requests
	var receivedMethod string
	var receivedPath string
	var receivedBody map[string]interface{}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		receivedMethod = r.Method
		receivedPath = r.URL.Path
		w.Header().Set("Content-Type", "application/json")

		sampleResource := map[string]interface{}{
			"id":   456,
			"name": "New{{.Kind}}",
		}

		switch r.Method {
		case http.MethodPost:
			json.NewDecoder(r.Body).Decode(&receivedBody)
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(sampleResource)
		case http.MethodGet:
{{- if .ResponseIsArray}}
			json.NewEncoder(w).Encode([]map[string]interface{}{sampleResource})
{{- else}}
			json.NewEncoder(w).Encode(sampleResource)
{{- end}}
		default:
			json.NewEncoder(w).Encode(sampleResource)
		}
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "new-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "new-{{.KindLower}}",
			Namespace: "default",
		},
	}

	// Run reconcile loop to handle any requeues
	_, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 10)

	if err != nil {
		t.Fatalf("Reconcile returned error: %v", err)
	}

	// Verify HTTP request was made
	if receivedMethod == "" {
		t.Error("expected HTTP request to be made")
	}

	t.Logf("HTTP request: %s %s (after %d iterations)", receivedMethod, receivedPath, iterations)
}

// =============================================================================
// Controller HTTP Error Handling Tests
// =============================================================================

func Test{{.Kind}}Reconciler_HTTPNotFound(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// Server returns 404 Not Found
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusNotFound)
		json.NewEncoder(w).Encode(map[string]string{
			"error": "resource not found",
		})
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	_, err, _ := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 5)

	// Verify the reconciler handled the 404 (may or may not be an error depending on implementation)
	if err != nil {
		t.Logf("Reconciler returned error on 404: %v", err)
	}

	// Check that status was updated to reflect the error
	var updated {{.APIVersion}}.{{.Kind}}
	if err := fakeClient.Get(ctx, req.NamespacedName, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	t.Logf("Status after 404: State=%s, Message=%s", updated.Status.State, updated.Status.Message)
}

func Test{{.Kind}}Reconciler_HTTPServerError(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	requestCount := 0

	// Server returns 500 Internal Server Error
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestCount++
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{
			"error": "internal server error",
		})
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	result, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 3)

	t.Logf("After %d iterations: err=%v, requeue=%v, requeueAfter=%v", iterations, err, result.Requeue, result.RequeueAfter)
	t.Logf("Total HTTP requests made: %d", requestCount)

	// Check status reflects the error
	var updated {{.APIVersion}}.{{.Kind}}
	if err := fakeClient.Get(ctx, req.NamespacedName, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	// Status should indicate an error state
	if updated.Status.State == "" {
		t.Log("Warning: status.state not set after server error")
	} else {
		t.Logf("Status after 500: State=%s", updated.Status.State)
	}
}

func Test{{.Kind}}Reconciler_HTTPUnauthorized(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// Server returns 401 Unauthorized
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnauthorized)
		json.NewEncoder(w).Encode(map[string]string{
			"error": "unauthorized",
		})
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	_, err, _ := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 3)

	// Check status reflects auth error
	var updated {{.APIVersion}}.{{.Kind}}
	if fetchErr := fakeClient.Get(ctx, req.NamespacedName, &updated); fetchErr != nil {
		t.Fatalf("failed to get updated object: %v", fetchErr)
	}

	t.Logf("Reconciler result on 401: err=%v, status.State=%s", err, updated.Status.State)
}

func Test{{.Kind}}Reconciler_HTTPRateLimited(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	requestCount := 0

	// Server returns 429 Too Many Requests, then succeeds
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestCount++
		w.Header().Set("Content-Type", "application/json")

		if requestCount <= 2 {
			w.Header().Set("Retry-After", "1")
			w.WriteHeader(http.StatusTooManyRequests)
			json.NewEncoder(w).Encode(map[string]string{
				"error": "rate limited",
			})
			return
		}

		// After rate limiting, return success
{{- if .ResponseIsArray}}
		json.NewEncoder(w).Encode([]map[string]interface{}{
			{"id": 123, "name": "Test{{.Kind}}"},
		})
{{- else}}
		json.NewEncoder(w).Encode(map[string]interface{}{
			"id":   123,
			"name": "Test{{.Kind}}",
		})
{{- end}}
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	_, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 5)

	t.Logf("Completed after %d iterations, %d HTTP requests, err=%v", iterations, requestCount, err)

	// Verify eventual success after rate limiting
	var updated {{.APIVersion}}.{{.Kind}}
	if err := fakeClient.Get(ctx, req.NamespacedName, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	t.Logf("Final status: State=%s", updated.Status.State)
}

func Test{{.Kind}}Reconciler_HTTPInvalidJSON(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// Server returns invalid JSON
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("this is not valid json"))
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	_, err, _ := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 3)

	// Check how controller handles invalid JSON
	var updated {{.APIVersion}}.{{.Kind}}
	if fetchErr := fakeClient.Get(ctx, req.NamespacedName, &updated); fetchErr != nil {
		t.Fatalf("failed to get updated object: %v", fetchErr)
	}

	t.Logf("Reconciler result on invalid JSON: err=%v, status.State=%s", err, updated.Status.State)
}

func Test{{.Kind}}Reconciler_HTTPTimeout(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// Server that delays response
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(200 * time.Millisecond)
		w.Header().Set("Content-Type", "application/json")
{{- if .ResponseIsArray}}
		json.NewEncoder(w).Encode([]map[string]interface{}{
			{"id": 123, "name": "Test{{.Kind}}"},
		})
{{- else}}
		json.NewEncoder(w).Encode(map[string]interface{}{
			"id":   123,
			"name": "Test{{.Kind}}",
		})
{{- end}}
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	// Create HTTP client with short timeout
	httpClient := &http.Client{
		Timeout: 50 * time.Millisecond,
	}

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: httpClient,
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	result, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 3)

	t.Logf("After %d iterations: err=%v, requeue=%v", iterations, err, result.Requeue || result.RequeueAfter > 0)

	// Check status reflects timeout
	var updated {{.APIVersion}}.{{.Kind}}
	if fetchErr := fakeClient.Get(ctx, req.NamespacedName, &updated); fetchErr != nil {
		t.Fatalf("failed to get updated object: %v", fetchErr)
	}

	t.Logf("Status after timeout: State=%s, Message=%s", updated.Status.State, updated.Status.Message)
}

// =============================================================================
// URL Construction and Consistency Tests
// =============================================================================

// httpRequest{{.Kind}} captures details of an HTTP request for test validation
type httpRequest{{.Kind}} struct {
	Method string
	URL    string
	Body   map[string]interface{}
}

// Test{{.Kind}}Reconciler_URLAndResponseConsistency verifies that:
// 1. CR spec values are correctly used in HTTP request URLs
// 2. HTTP response values match what was requested
// 3. The correct HTTP method is used for the endpoint type
func Test{{.Kind}}Reconciler_URLAndResponseConsistency(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// Define test ID that will be used consistently across spec, URL, and response
	const testResourceID = "test-resource-42"
	const testResourceIDNumeric int64 = 42

	// Track all received requests
	var receivedRequests []httpRequest{{.Kind}}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Capture request details
		fullURL := r.URL.Path
		if r.URL.RawQuery != "" {
			fullURL += "?" + r.URL.RawQuery
		}

		var bodyMap map[string]interface{}
		if r.Body != nil && r.Method != http.MethodGet && r.Method != http.MethodDelete {
			json.NewDecoder(r.Body).Decode(&bodyMap)
		}

		receivedRequests = append(receivedRequests, httpRequest{{.Kind}}{
			Method: r.Method,
			URL:    fullURL,
			Body:   bodyMap,
		})

		w.Header().Set("Content-Type", "application/json")

		// Response with consistent ID matching what was requested
		responseResource := map[string]interface{}{
			"id":   testResourceIDNumeric,
			"name": "Test{{.Kind}}",
		}

		switch r.Method {
		case http.MethodPost:
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(responseResource)
		case http.MethodGet:
{{- if .ResponseIsArray}}
			json.NewEncoder(w).Encode([]map[string]interface{}{responseResource})
{{- else}}
			json.NewEncoder(w).Encode(responseResource)
{{- end}}
		case http.MethodPut:
			json.NewEncoder(w).Encode(responseResource)
		case http.MethodDelete:
			w.WriteHeader(http.StatusNoContent)
		default:
			json.NewEncoder(w).Encode(responseResource)
		}
	}))
	defer server.Close()

	// Create CR with specific values that should appear in the URL
	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{
{{- if .IsAction }}
{{- if .HasParentID }}
			// Set parent ID for action endpoint
			{{.ParentIDField}}: testResourceID,
{{- end }}
{{- else if .IsQuery }}
			// Query endpoints use query parameters
{{- else }}
			// Resource endpoint - set external ID ref for read operations
{{- end }}
		},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	_, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 10)

	if err != nil {
		t.Fatalf("Reconcile returned error after %d iterations: %v", iterations, err)
	}

	// === Validation 1: At least one request was made ===
	if len(receivedRequests) == 0 {
		t.Fatal("expected at least one HTTP request to be made")
	}

	// Log all received requests for debugging
	t.Logf("Received %d HTTP requests:", len(receivedRequests))
	for i, req := range receivedRequests {
		t.Logf("  [%d] %s %s", i+1, req.Method, req.URL)
		if req.Body != nil {
			t.Logf("      Body: %v", req.Body)
		}
	}

	// === Validation 2: Correct HTTP method was used ===
	methodCounts := make(map[string]int)
	for _, req := range receivedRequests {
		methodCounts[req.Method]++
	}
	t.Logf("HTTP method counts: %v", methodCounts)

{{- if .IsQuery }}
	expectedMethod := http.MethodGet
	if methodCounts[expectedMethod] == 0 {
		t.Errorf("expected at least one %s request for query endpoint, got methods: %v", expectedMethod, methodCounts)
	}
{{- else if .IsAction }}
	expectedMethod := "{{.ActionMethod}}"
	if expectedMethod == "" {
		expectedMethod = http.MethodPost
	}
	if methodCounts[expectedMethod] == 0 {
		t.Errorf("expected at least one %s request for action endpoint, got methods: %v", expectedMethod, methodCounts)
	}
{{- else }}
	// Resource endpoints should use POST to create
	if methodCounts[http.MethodPost] == 0 {
		t.Errorf("expected at least one POST request for resource creation, got methods: %v", methodCounts)
	}
{{- end }}

	// === Validation 3: Correct path was used ===
{{- if .IsQuery }}
	expectedPath := "{{.QueryPath}}"
{{- else if .IsAction }}
	expectedPath := "{{.ActionPath}}"
	{{- if .HasParentID }}
	// Replace path parameter placeholder with actual value
	expectedPath = strings.Replace(expectedPath, "{{"{"}}{{.ParentIDParam}}{{"}"}}", testResourceID, 1)
	{{- end }}
	{{- range .PathParams }}
	expectedPath = strings.Replace(expectedPath, "{{"{"}}{{.Name}}{{"}"}}", testResourceID, 1)
	{{- end }}
{{- else }}
	expectedPath := "{{.BasePath}}"
	{{- range .ResourcePathParams }}
	// Replace path parameter placeholder with actual value
	expectedPath = strings.Replace(expectedPath, "{{"{"}}{{.Name}}{{"}"}}", testResourceID, 1)
	{{- end }}
{{- end }}

	foundCorrectPath := false
	for _, req := range receivedRequests {
		// Extract just the path part (without query string) for comparison
		reqPath := req.URL
		if idx := strings.Index(reqPath, "?"); idx != -1 {
			reqPath = reqPath[:idx]
		}

		if reqPath == expectedPath || strings.HasPrefix(reqPath, expectedPath) || strings.HasPrefix(reqPath+"/", expectedPath) {
			foundCorrectPath = true
			t.Logf("Found expected path %q in URL: %s", expectedPath, req.URL)
			break
		}
	}

	if !foundCorrectPath {
		t.Errorf("expected URL path %q, but none of the requests matched. Received URLs:", expectedPath)
		for _, req := range receivedRequests {
			t.Errorf("  %s %s", req.Method, req.URL)
		}
	}

	// === Validation 4: Verify status was updated correctly ===
	var updated {{.APIVersion}}.{{.Kind}}
	if err := fakeClient.Get(ctx, types.NamespacedName{Name: "test-{{.KindLower}}", Namespace: "default"}, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	if updated.Status.State == "" {
		t.Error("expected status.State to be set after reconciliation")
	}
	t.Logf("Final status: State=%s, Message=%s", updated.Status.State, updated.Status.Message)
}

{{- if and (not .IsQuery) (not .IsAction) }}
// Test{{.Kind}}Reconciler_PathParamInURL verifies that path parameters from spec
// are correctly substituted in the HTTP request URL
func Test{{.Kind}}Reconciler_PathParamInURL(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	// The external ID we expect to see in the URL
	const expectedExternalID = "path-param-test-789"

	var receivedRequests []httpRequest{{.Kind}}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fullURL := r.URL.Path
		if r.URL.RawQuery != "" {
			fullURL += "?" + r.URL.RawQuery
		}
		receivedRequests = append(receivedRequests, httpRequest{{.Kind}}{
			Method: r.Method,
			URL:    fullURL,
		})

		w.Header().Set("Content-Type", "application/json")

		// Return resource with matching ID
		responseResource := map[string]interface{}{
			"id":   expectedExternalID,
			"name": "Test{{.Kind}}",
		}

		switch r.Method {
		case http.MethodGet:
{{- if .ResponseIsArray}}
			json.NewEncoder(w).Encode([]map[string]interface{}{responseResource})
{{- else}}
			json.NewEncoder(w).Encode(responseResource)
{{- end}}
		default:
			json.NewEncoder(w).Encode(responseResource)
		}
	}))
	defer server.Close()

	// Create CR with ExternalIDRef - this should be used in the URL path
	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{
			ExternalIDRef: expectedExternalID,
			ReadOnly:      true, // ReadOnly mode uses GET with the external ID
		},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	_, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 10)

	if err != nil {
		t.Fatalf("Reconcile returned error after %d iterations: %v", iterations, err)
	}

	// Log requests
	t.Logf("Received %d HTTP requests:", len(receivedRequests))
	for i, req := range receivedRequests {
		t.Logf("  [%d] %s %s", i+1, req.Method, req.URL)
	}

	// Verify the external ID appears in at least one URL
	foundExternalID := false
	for _, req := range receivedRequests {
		if strings.Contains(req.URL, expectedExternalID) {
			foundExternalID = true
			t.Logf("Found external ID %q in URL: %s %s", expectedExternalID, req.Method, req.URL)
			break
		}
	}

	if !foundExternalID {
		t.Errorf("expected external ID %q to appear in URL path, got requests: %v", expectedExternalID, receivedRequests)
	}

	// Verify GET method was used (since ReadOnly mode)
	foundGet := false
	for _, req := range receivedRequests {
		if req.Method == http.MethodGet {
			foundGet = true
			break
		}
	}

	if !foundGet {
		t.Error("expected GET request for ReadOnly resource")
	}

	// Verify status reflects the external ID
	var updated {{.APIVersion}}.{{.Kind}}
	if err := fakeClient.Get(ctx, types.NamespacedName{Name: "test-{{.KindLower}}", Namespace: "default"}, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	// The external ID should be stored in status after successful GET
	if updated.Status.ExternalID != expectedExternalID {
		t.Errorf("expected status.ExternalID to be %q, got %q", expectedExternalID, updated.Status.ExternalID)
	}
}
{{- end }}

{{- if .IsAction }}
// Test{{.Kind}}Reconciler_ActionPathParams verifies that action endpoints
// correctly use path parameters from spec in the URL
func Test{{.Kind}}Reconciler_ActionPathParams(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

{{- if .HasParentID }}
	// The parent ID we expect to see in the URL
	const expectedParentID = "parent-id-555"
{{- end }}

	var receivedRequests []httpRequest{{.Kind}}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fullURL := r.URL.Path
		if r.URL.RawQuery != "" {
			fullURL += "?" + r.URL.RawQuery
		}

		var bodyMap map[string]interface{}
		if r.Body != nil {
			json.NewDecoder(r.Body).Decode(&bodyMap)
		}

		receivedRequests = append(receivedRequests, httpRequest{{.Kind}}{
			Method: r.Method,
			URL:    fullURL,
			Body:   bodyMap,
		})

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
{{- if .HasParentID }}
			"id":      expectedParentID,
{{- end }}
		})
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{
{{- if .HasParentID }}
			{{.ParentIDField}}: expectedParentID,
{{- end }}
		},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	_, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 10)

	if err != nil {
		t.Fatalf("Reconcile returned error after %d iterations: %v", iterations, err)
	}

	// Log requests
	t.Logf("Received %d HTTP requests:", len(receivedRequests))
	for i, req := range receivedRequests {
		t.Logf("  [%d] %s %s", i+1, req.Method, req.URL)
		if req.Body != nil {
			t.Logf("      Body: %v", req.Body)
		}
	}

	// Verify at least one request was made
	if len(receivedRequests) == 0 {
		t.Fatal("expected at least one HTTP request")
	}

{{- if .HasParentID }}
	// Verify parent ID appears in the URL
	foundParentID := false
	for _, req := range receivedRequests {
		if strings.Contains(req.URL, expectedParentID) {
			foundParentID = true
			t.Logf("Found parent ID %q in URL: %s", expectedParentID, req.URL)
			break
		}
	}

	if !foundParentID {
		t.Errorf("expected parent ID %q to appear in URL, got requests: %v", expectedParentID, receivedRequests)
	}
{{- end }}

	// Verify correct HTTP method
	expectedMethod := "{{.ActionMethod}}"
	if expectedMethod == "" {
		expectedMethod = http.MethodPost
	}

	foundMethod := false
	for _, req := range receivedRequests {
		if req.Method == expectedMethod {
			foundMethod = true
			break
		}
	}

	if !foundMethod {
		t.Errorf("expected %s request for action endpoint", expectedMethod)
	}

	// Build expected URL by replacing path parameter placeholders with actual values
	expectedActionPath := "{{.ActionPath}}"
{{- if .HasParentID }}
	expectedActionPath = strings.Replace(expectedActionPath, "{{"{"}}{{.ParentIDParam}}{{"}"}}", expectedParentID, 1)
{{- end }}
{{- range .PathParams }}
	expectedActionPath = strings.Replace(expectedActionPath, "{{"{"}}{{.Name}}{{"}"}}", expectedParentID, 1)
{{- end }}

	foundActionPath := false
	for _, req := range receivedRequests {
		// Extract just the path part (without query string)
		reqPath := req.URL
		if idx := strings.Index(reqPath, "?"); idx != -1 {
			reqPath = reqPath[:idx]
		}

		if reqPath == expectedActionPath {
			foundActionPath = true
			t.Logf("Found expected action path %q in URL: %s", expectedActionPath, req.URL)
			break
		}
	}

	if !foundActionPath {
		t.Errorf("expected action path %q, but none of the requests matched. Received URLs:", expectedActionPath)
		for _, req := range receivedRequests {
			t.Errorf("  %s %s", req.Method, req.URL)
		}
	}
}
{{- end }}

{{- if .IsQuery }}
// Test{{.Kind}}Reconciler_QueryParams verifies that query parameters from spec
// are correctly appended to the HTTP request URL
func Test{{.Kind}}Reconciler_QueryParams(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = {{.APIVersion}}.AddToScheme(scheme)

	var receivedRequests []httpRequest{{.Kind}}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fullURL := r.URL.Path
		if r.URL.RawQuery != "" {
			fullURL += "?" + r.URL.RawQuery
		}
		receivedRequests = append(receivedRequests, httpRequest{{.Kind}}{
			Method: r.Method,
			URL:    fullURL,
		})

		w.Header().Set("Content-Type", "application/json")

{{- if .ResponseIsArray}}
		json.NewEncoder(w).Encode([]map[string]interface{}{
			{"id": 1, "name": "Result1"},
			{"id": 2, "name": "Result2"},
		})
{{- else}}
		json.NewEncoder(w).Encode(map[string]interface{}{
			"id":   1,
			"name": "Result",
		})
{{- end}}
	}))
	defer server.Close()

	obj := &{{.APIVersion}}.{{.Kind}}{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
		Spec: {{.APIVersion}}.{{.Kind}}Spec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &{{.Kind}}Reconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-{{.KindLower}}",
			Namespace: "default",
		},
	}

	_, err, iterations := reconcile{{.Kind}}UntilComplete(t, ctx, reconciler, req, 10)

	if err != nil {
		t.Fatalf("Reconcile returned error after %d iterations: %v", iterations, err)
	}

	// Log requests
	t.Logf("Received %d HTTP requests:", len(receivedRequests))
	for i, req := range receivedRequests {
		t.Logf("  [%d] %s %s", i+1, req.Method, req.URL)
	}

	// Verify GET method was used
	foundGet := false
	for _, req := range receivedRequests {
		if req.Method == http.MethodGet {
			foundGet = true
			break
		}
	}

	if !foundGet {
		t.Error("expected GET request for query endpoint")
	}

	// Verify query path pattern is in URL
	expectedQueryPath := "{{.QueryPath}}"

	// Extract static parts of the path (handle any path params in query endpoints)
	pathParts := strings.Split(expectedQueryPath, "{")
	staticPrefix := pathParts[0]

	var staticSuffix string
	if idx := strings.LastIndex(expectedQueryPath, "}"); idx != -1 && idx < len(expectedQueryPath)-1 {
		staticSuffix = expectedQueryPath[idx+1:]
	}

	foundQueryPath := false
	for _, req := range receivedRequests {
		hasPrefix := strings.HasPrefix(req.URL, staticPrefix) || strings.Contains(req.URL, staticPrefix)
		hasSuffix := staticSuffix == "" || strings.Contains(req.URL, staticSuffix)

		if hasPrefix && hasSuffix {
			foundQueryPath = true
			t.Logf("Found query path pattern %q in URL: %s", expectedQueryPath, req.URL)
			break
		}
	}

	if !foundQueryPath {
		t.Errorf("expected query path pattern %q in URL (prefix=%q, suffix=%q)", expectedQueryPath, staticPrefix, staticSuffix)
	}
}
{{- end }}

