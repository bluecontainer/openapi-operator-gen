/*
Copyright {{ .Year }} Generated by openapi-operator-gen {{ .GeneratorVersion }}.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/util/retry"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
{{- if .HasDelete }}
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
{{- end }}
	"sigs.k8s.io/controller-runtime/pkg/log"

	controllerutil2 "github.com/bluecontainer/openapi-operator-gen/pkg/controller"
	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	"github.com/bluecontainer/openapi-operator-gen/pkg/runtime"
	{{ .APIVersion }} "{{ .ModuleName }}/api/{{ .APIVersion }}"
)

var (
	{{ .KindLower }}Tracer = otel.Tracer("{{ .ModuleName }}/controller/{{ .KindLower }}")
	{{ .KindLower }}Meter  = otel.Meter("{{ .ModuleName }}/controller/{{ .KindLower }}")

	// Metrics
	{{ .KindLower }}ReconcileTotal    metric.Int64Counter
	{{ .KindLower }}ReconcileDuration metric.Float64Histogram
	{{ .KindLower }}APICallTotal      metric.Int64Counter
	{{ .KindLower }}APICallDuration   metric.Float64Histogram
	{{ .KindLower }}DriftDetected     metric.Int64Counter
)

func init() {
	var err error

	{{ .KindLower }}ReconcileTotal, err = {{ .KindLower }}Meter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}ReconcileDuration, err = {{ .KindLower }}Meter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}APICallTotal, err = {{ .KindLower }}Meter.Int64Counter(
		"api_call_total",
		metric.WithDescription("Total number of REST API calls"),
		metric.WithUnit("{call}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}APICallDuration, err = {{ .KindLower }}Meter.Float64Histogram(
		"api_call_duration_seconds",
		metric.WithDescription("Duration of REST API calls in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}DriftDetected, err = {{ .KindLower }}Meter.Int64Counter(
		"drift_detected_total",
		metric.WithDescription("Total number of drift detections"),
		metric.WithUnit("{drift}"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
{{- if .HasDelete }}
	{{ .KindLower }}Finalizer    = "{{ .APIGroup }}/finalizer"
{{- end }}
	{{ .KindLower }}RequeueAfter = time.Second * 30
)

// APIError represents an error from the external REST API with status code information.
// This allows the controller to distinguish between retryable errors (5xx, network errors)
// and non-retryable errors (4xx client errors).
type {{ .Kind }}APIError struct {
	StatusCode int
	Status     string
	Body       string
	Method     string
	URL        string
}

func (e *{{ .Kind }}APIError) Error() string {
	return fmt.Sprintf("%s %s failed: %s - %s", e.Method, e.URL, e.Status, e.Body)
}

// IsRetryable returns true if the error is likely transient and worth retrying.
// 5xx errors and network errors are retryable; 4xx client errors are not.
func (e *{{ .Kind }}APIError) IsRetryable() bool {
	return e.StatusCode >= 500 || e.StatusCode == 0 // 0 means network error
}

// is{{ .Kind }}APIErrorRetryable checks if an error is a retryable API error.
// Returns true for non-API errors (network issues, etc.) and 5xx API errors.
// Returns false for 4xx client errors.
func is{{ .Kind }}APIErrorRetryable(err error) bool {
	if err == nil {
		return false
	}
	var apiErr *{{ .Kind }}APIError
	if ok := errors.As(err, &apiErr); ok {
		return apiErr.IsRetryable()
	}
	// Non-API errors (network, parsing, etc.) should be retried
	return true
}

// {{ .Kind }}Reconciler reconciles a {{ .Kind }} object
type {{ .Kind }}Reconciler struct {
	client.Client
	Scheme           *k8sruntime.Scheme
	HTTPClient       *http.Client
	EndpointResolver *endpoint.Resolver
	// BaseURL is used when EndpointResolver is nil (static URL mode)
	BaseURL string
}

// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }},verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/status,verbs=get;update;patch
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop
func (r *{{ .Kind }}Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// Start tracing span
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "{{ .Kind }}"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	// Record metrics
	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	{{ .KindLower }}ReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	{{ .KindLower }}ReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

// reconcileInternal contains the actual reconciliation logic
func (r *{{ .Kind }}Reconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the {{ .Kind }} instance
	instance := &{{ .APIVersion }}.{{ .Kind }}{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if k8serrors.IsNotFound(err) {
			logger.Info("{{ .Kind }} resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get {{ .Kind }}")
		return ctrl.Result{}, err
	}

	// Add resource attributes to current span
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
{{- if or .NeedsExternalIDRef .HasPost }}
		attribute.String("resource.externalID", r.getExternalID(instance)),
{{- end }}
		attribute.Bool("resource.readOnly", instance.Spec.ReadOnly),
	)

	// Check if this is a read-only resource
	isReadOnly := instance.Spec.ReadOnly

{{- if .HasDelete }}
	// Check if the resource is being deleted
	if instance.GetDeletionTimestamp() != nil {
		if controllerutil.ContainsFinalizer(instance, {{ .KindLower }}Finalizer) {
			// Run finalization logic (skip for read-only resources)
			// Note: We log errors but still remove the finalizer to avoid blocking CR deletion
			if !isReadOnly {
				if err := r.finalizeResource(ctx, instance); err != nil {
					logger.Error(err, "Finalization failed, but proceeding with finalizer removal to allow CR deletion")
				}
			}

			// Remove finalizer (always, even if finalization failed)
			controllerutil.RemoveFinalizer(instance, {{ .KindLower }}Finalizer)
			if err := r.Update(ctx, instance); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}
{{- end }}

	// Handle read-only mode: only GET and update status
	if isReadOnly {
{{- if .NeedsExternalIDRef }}
		if instance.Spec.ExternalIDRef == "" {
			r.updateStatus(ctx, instance, "Failed", "ReadOnly mode requires ExternalIDRef to be set")
			return ctrl.Result{RequeueAfter: {{ .KindLower }}RequeueAfter}, fmt.Errorf("readOnly mode requires externalIDRef")
		}
{{- end }}
		if err := r.observeResource(ctx, instance); err != nil {
			r.updateStatus(ctx, instance, "Failed", err.Error())
			// For retryable errors (5xx, network errors), requeue after standard interval
			// For 4xx client errors, don't auto-retry as the request won't succeed without spec changes
			// Note: We don't return err to avoid controller-runtime's aggressive exponential backoff
			if is{{ .Kind }}APIErrorRetryable(err) {
				logger.Error(err, "Retryable error, will retry after interval")
				return ctrl.Result{RequeueAfter: {{ .KindLower }}RequeueAfter}, nil
			}
			logger.Info("Non-retryable error (client error), not requeueing until spec changes", "error", err.Error())
			return ctrl.Result{}, nil
		}
		return ctrl.Result{RequeueAfter: {{ .KindLower }}RequeueAfter}, nil
	}

	// Sync with REST API (with drift detection)
	if err := r.syncResource(ctx, instance); err != nil {
		// Update status to failed
		r.updateStatus(ctx, instance, "Failed", err.Error())
		// For retryable errors (5xx, network errors), requeue after standard interval
		// For 4xx client errors, don't auto-retry as the request won't succeed without spec changes
		// Note: We don't return err to avoid controller-runtime's aggressive exponential backoff
		if is{{ .Kind }}APIErrorRetryable(err) {
			logger.Error(err, "Retryable error, will retry after interval")
			return ctrl.Result{RequeueAfter: {{ .KindLower }}RequeueAfter}, nil
		}
		logger.Info("Non-retryable error (client error), not requeueing until spec changes", "error", err.Error())
		return ctrl.Result{}, nil
	}

{{- if .HasDelete }}
	// Add finalizer after successful sync (not before, to avoid blocking deletion if creation fails)
	// Use retry to handle conflicts from concurrent reconciliations
	err = retry.RetryOnConflict(retry.DefaultRetry, func() error {
		// Re-fetch the latest version
		if err := r.Get(ctx, req.NamespacedName, instance); err != nil {
			return err
		}
		if !controllerutil.ContainsFinalizer(instance, {{ .KindLower }}Finalizer) {
			controllerutil.AddFinalizer(instance, {{ .KindLower }}Finalizer)
			return r.Update(ctx, instance)
		}
		return nil
	})
	if err != nil {
		return ctrl.Result{}, err
	}
{{- end }}

	return ctrl.Result{RequeueAfter: {{ .KindLower }}RequeueAfter}, nil
}

func (r *{{ .Kind }}Reconciler) getBaseURL(ctx context.Context) (string, error) {
	// Try static BaseURL first
	if r.BaseURL != "" {
		return r.BaseURL, nil
	}
	// Try global endpoint resolver
	if r.EndpointResolver != nil {
		url, err := r.EndpointResolver.GetEndpoint()
		if err == nil {
			return url, nil
		}
	}
	return "", fmt.Errorf("no endpoint configured: set global endpoint (--base-url, --statefulset-name, --deployment-name, or --helm-release) or specify per-CR targeting (targetHelmRelease, targetStatefulSet, or targetDeployment)")
}

func (r *{{ .Kind }}Reconciler) getBaseURLByOrdinal(ctx context.Context, ordinal *int32) (string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		if ordinal == nil {
			return "", fmt.Errorf("targetPodOrdinal is required when using by-ordinal strategy")
		}
		return r.EndpointResolver.GetEndpointByOrdinal(int(*ordinal))
	}
	// Fall back to regular endpoint selection if not using by-ordinal strategy
	return r.getBaseURL(ctx)
}

// buildResourceURL builds the URL for resource operations with path and query parameters
// ResourcePath is the full path template with placeholders (e.g., /pet/{petId}, /classes/{className}/variables/{variableName})
// Path parameters are substituted from the spec fields
func (r *{{ .Kind }}Reconciler) buildResourceURL(baseURL string, instance *{{ .APIVersion }}.{{ .Kind }}) string {
	builder := runtime.NewURLBuilder("{{ .ResourcePath }}")

	{{- if .ResourcePathParams }}
	// Add path parameters from spec, with ExternalID fallback for the last path param
	{{- $lastIndex := sub (len .ResourcePathParams) 1 }}
	{{- range $index, $param := .ResourcePathParams }}
	{{- $isLast := eq $index $lastIndex }}
	{{- if $param.IsPointer }}
	{{- if eq $param.BaseType "string" }}
	if instance.Spec.{{ $param.GoName }} != nil {
		builder.WithPathParam("{{ $param.Name }}", *instance.Spec.{{ $param.GoName }})
	}{{- if $isLast }} else if instance.Status.ExternalID != "" {
		// Fallback to ExternalID for the last path param (e.g., after POST returns ID)
		builder.WithPathParam("{{ $param.Name }}", instance.Status.ExternalID)
	}
	{{- end }}
	{{- else if eq $param.BaseType "int64" }}
	if instance.Spec.{{ $param.GoName }} != nil {
		builder.WithPathParamInt("{{ $param.Name }}", *instance.Spec.{{ $param.GoName }})
	}{{- if $isLast }} else if instance.Status.ExternalID != "" {
		// Fallback to ExternalID for the last path param (e.g., after POST returns ID)
		builder.WithPathParam("{{ $param.Name }}", instance.Status.ExternalID)
	}
	{{- end }}
	{{- else }}
	if instance.Spec.{{ $param.GoName }} != nil {
		builder.WithPathParam("{{ $param.Name }}", fmt.Sprintf("%v", *instance.Spec.{{ $param.GoName }}))
	}{{- if $isLast }} else if instance.Status.ExternalID != "" {
		// Fallback to ExternalID for the last path param (e.g., after POST returns ID)
		builder.WithPathParam("{{ $param.Name }}", instance.Status.ExternalID)
	}
	{{- end }}
	{{- end }}
	{{- else if eq $param.GoType "string" }}
	{{- if $isLast }}
	if instance.Spec.{{ $param.GoName }} != "" {
		builder.WithPathParam("{{ $param.Name }}", instance.Spec.{{ $param.GoName }})
	} else if instance.Status.ExternalID != "" {
		// Fallback to ExternalID for the last path param (e.g., after POST returns ID)
		builder.WithPathParam("{{ $param.Name }}", instance.Status.ExternalID)
	}
	{{- else }}
	builder.WithPathParam("{{ $param.Name }}", instance.Spec.{{ $param.GoName }})
	{{- end }}
	{{- else if eq $param.GoType "int64" }}
	{{- if $isLast }}
	if instance.Spec.{{ $param.GoName }} != 0 {
		builder.WithPathParamInt("{{ $param.Name }}", instance.Spec.{{ $param.GoName }})
	} else if instance.Status.ExternalID != "" {
		// Fallback to ExternalID for the last path param (e.g., after POST returns ID)
		builder.WithPathParam("{{ $param.Name }}", instance.Status.ExternalID)
	}
	{{- else }}
	builder.WithPathParamInt("{{ $param.Name }}", instance.Spec.{{ $param.GoName }})
	{{- end }}
	{{- else }}
	{{- if $isLast }}
	if instance.Spec.{{ $param.GoName }} != 0 {
		builder.WithPathParam("{{ $param.Name }}", fmt.Sprintf("%v", instance.Spec.{{ $param.GoName }}))
	} else if instance.Status.ExternalID != "" {
		// Fallback to ExternalID for the last path param (e.g., after POST returns ID)
		builder.WithPathParam("{{ $param.Name }}", instance.Status.ExternalID)
	}
	{{- else }}
	builder.WithPathParam("{{ $param.Name }}", fmt.Sprintf("%v", instance.Spec.{{ $param.GoName }}))
	{{- end }}
	{{- end }}
	{{- end }}
	{{- end }}

	{{- if .ResourceQueryParams }}
	// Add query parameters from spec
	{{- range .ResourceQueryParams }}
	{{- if .IsArray }}
	if len(instance.Spec.{{ .GoName }}) > 0 {
		builder.WithQueryParamArray("{{ .Name }}", instance.Spec.{{ .GoName }})
	}
	{{- else if eq .GoType "string" }}
	builder.WithQueryParam("{{ .Name }}", instance.Spec.{{ .GoName }})
	{{- else if eq .GoType "int64" }}
	builder.WithQueryParamInt("{{ .Name }}", instance.Spec.{{ .GoName }})
	{{- else }}
	if instance.Spec.{{ .GoName }} != 0 {
		builder.WithQueryParam("{{ .Name }}", fmt.Sprintf("%v", instance.Spec.{{ .GoName }}))
	}
	{{- end }}
	{{- end }}
	{{- end }}

	return builder.Build(baseURL)
}

{{- if .HasPost }}

// buildResourceURLForCreate builds the URL for resource creation (POST) with query parameters only
func (r *{{ .Kind }}Reconciler) buildResourceURLForCreate(baseURL string, instance *{{ .APIVersion }}.{{ .Kind }}) string {
	builder := runtime.NewURLBuilder("{{ .BasePath }}")

	{{- if .ResourceQueryParams }}
	// Add query parameters from spec
	{{- range .ResourceQueryParams }}
	{{- if .IsArray }}
	if len(instance.Spec.{{ .GoName }}) > 0 {
		builder.WithQueryParamArray("{{ .Name }}", instance.Spec.{{ .GoName }})
	}
	{{- else if eq .GoType "string" }}
	builder.WithQueryParam("{{ .Name }}", instance.Spec.{{ .GoName }})
	{{- else if eq .GoType "int64" }}
	builder.WithQueryParamInt("{{ .Name }}", instance.Spec.{{ .GoName }})
	{{- else }}
	if instance.Spec.{{ .GoName }} != 0 {
		builder.WithQueryParam("{{ .Name }}", fmt.Sprintf("%v", instance.Spec.{{ .GoName }}))
	}
	{{- end }}
	{{- end }}
	{{- end }}

	return builder.BuildForCreate(baseURL)
}

{{- if len .ResourcePathParams }}
// hasValidPathParams checks if all path parameters have valid (non-zero/non-empty) values.
// This is used to determine if we can perform GET operations on a resource.
// The last path parameter can use ExternalID as a fallback (e.g., when POST returns an ID).
func (r *{{ .Kind }}Reconciler) hasValidPathParams(instance *{{ .APIVersion }}.{{ .Kind }}) bool {
	{{- $lastIndex := sub (len .ResourcePathParams) 1 }}
	{{- range $index, $param := .ResourcePathParams }}
	{{- $isLast := eq $index $lastIndex }}
	{{- if $param.IsPointer }}
	{{- if $isLast }}
	// Last path param can use ExternalID as fallback
	if instance.Spec.{{ $param.GoName }} == nil && instance.Status.ExternalID == "" {
		return false
	}
	{{- if eq $param.BaseType "string" }}
	if instance.Spec.{{ $param.GoName }} != nil && *instance.Spec.{{ $param.GoName }} == "" && instance.Status.ExternalID == "" {
		return false
	}
	{{- else if or (eq $param.BaseType "int64") (eq $param.BaseType "int32") (eq $param.BaseType "int") }}
	if instance.Spec.{{ $param.GoName }} != nil && *instance.Spec.{{ $param.GoName }} == 0 && instance.Status.ExternalID == "" {
		return false
	}
	{{- end }}
	{{- else }}
	if instance.Spec.{{ $param.GoName }} == nil {
		return false
	}
	{{- if eq $param.BaseType "string" }}
	if *instance.Spec.{{ $param.GoName }} == "" {
		return false
	}
	{{- else if or (eq $param.BaseType "int64") (eq $param.BaseType "int32") (eq $param.BaseType "int") }}
	if *instance.Spec.{{ $param.GoName }} == 0 {
		return false
	}
	{{- end }}
	{{- end }}
	{{- else if eq $param.GoType "string" }}
	{{- if $isLast }}
	// Last path param can use ExternalID as fallback
	if instance.Spec.{{ $param.GoName }} == "" && instance.Status.ExternalID == "" {
		return false
	}
	{{- else }}
	if instance.Spec.{{ $param.GoName }} == "" {
		return false
	}
	{{- end }}
	{{- else if or (eq $param.GoType "int64") (eq $param.GoType "int32") (eq $param.GoType "int") }}
	{{- if $isLast }}
	// Last path param can use ExternalID as fallback
	if instance.Spec.{{ $param.GoName }} == 0 && instance.Status.ExternalID == "" {
		return false
	}
	{{- else }}
	if instance.Spec.{{ $param.GoName }} == 0 {
		return false
	}
	{{- end }}
	{{- end }}
	{{- end }}
	return true
}
{{- end }}
{{- end }}

{{- if .PutPathDiffers }}

// buildResourceURLForPut builds the URL for PUT operations when PUT uses a different path than GET.
// This is common when PUT /resource updates by ID in the request body, not in the URL.
func (r *{{ .Kind }}Reconciler) buildResourceURLForPut(baseURL string, instance *{{ .APIVersion }}.{{ .Kind }}) string {
	builder := runtime.NewURLBuilder("{{ .PutPath }}")
	return builder.Build(baseURL)
}
{{- end }}

{{- if or .NeedsExternalIDRef .HasPost }}
// getExternalID returns the external ID to use for GET/PUT/DELETE operations.
{{- if and .NeedsExternalIDRef .HasPost }}
// It prefers ExternalIDRef from spec (for importing existing resources),
// then falls back to ExternalID from status (for resources created by the controller).
{{- else if .NeedsExternalIDRef }}
// It returns ExternalIDRef from spec (for referencing existing resources).
{{- else if .HasPost }}
// It returns ExternalID from status (for resources created by the controller).
{{- end }}
func (r *{{ .Kind }}Reconciler) getExternalID(instance *{{ .APIVersion }}.{{ .Kind }}) string {
{{- if .NeedsExternalIDRef }}
	if instance.Spec.ExternalIDRef != "" {
		return instance.Spec.ExternalIDRef
	}
{{- end }}
{{- if .HasPost }}
	return instance.Status.ExternalID
{{- else }}
	return ""
{{- end }}
}
{{- end }}

// extractExternalIDFromResponse extracts the external ID from an API response.
// It looks for common ID field names (id, ID) and returns the value as a string.
// If no ID is found in the response, it falls back to the provided fallback value.
func (r *{{ .Kind }}Reconciler) extractExternalIDFromResponse(respData map[string]interface{}, fallback string) string {
	// Try common ID field names
	for _, idField := range []string{"id", "ID", "Id"} {
		if id, ok := respData[idField]; ok {
			switch v := id.(type) {
			case string:
				return v
			case float64:
				return fmt.Sprintf("%.0f", v)
			case int:
				return fmt.Sprintf("%d", v)
			case int64:
				return fmt.Sprintf("%d", v)
			}
		}
	}
	return fallback
}

// getResource performs a GET request to fetch the current state of the resource from the REST API.
// Returns the response body as a map, or nil if the resource doesn't exist (404).
func (r *{{ .Kind }}Reconciler) getResource(ctx context.Context, baseURL string, externalID string, instance *{{ .APIVersion }}.{{ .Kind }}) (map[string]interface{}, []byte, error) {
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "GET",
		trace.WithAttributes(
			attribute.String("http.method", "GET"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", externalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURL(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to create GET request: %w", err)
	}
	req.Header.Set("Accept", "application/json")

	logger.Info("Getting resource", "url", url)
	logger.V(1).Info("REST API request", "method", "GET", "url", url)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "GET", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to execute GET request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "GET", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to read GET response: %w", err)
	}

	// 404 means resource doesn't exist
	if resp.StatusCode == http.StatusNotFound {
		r.recordAPICallMetrics(ctx, "GET", "not_found", resp.StatusCode, duration)
		logger.Info("Resource not found in external API", "externalID", externalID)
		return nil, nil, nil
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "GET", "error", resp.StatusCode, duration)
		apiErr := &{{ .Kind }}APIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "GET",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return nil, nil, apiErr
	}

	r.recordAPICallMetrics(ctx, "GET", "success", resp.StatusCode, duration)

	logger.V(1).Info("REST API response", "method", "GET", "url", url, "statusCode", resp.StatusCode, "body", string(body))

	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err != nil {
		return nil, body, fmt.Errorf("failed to parse GET response: %w", err)
	}

	return respData, body, nil
}

// recordAPICallMetrics records metrics for API calls
func (r *{{ .Kind }}Reconciler) recordAPICallMetrics(ctx context.Context, method, status string, statusCode int, duration float64) {
	{{ .KindLower }}APICallTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("method", method),
			attribute.String("status", status),
			attribute.Int("status_code", statusCode),
		))
	{{ .KindLower }}APICallDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("method", method),
			attribute.String("status", status),
		))
}

// compareSpecWithResponse compares the CR spec with the API response to detect drift.
// When mergeOnUpdate is enabled (the default), it compares what the merged result would be
// against the current API state. This means fields not specified in the CR spec won't cause
// drift because they would be preserved from the API response during a merge.
// Returns true if there is drift (spec differs from current state).
func (r *{{ .Kind }}Reconciler) compareSpecWithResponse(instance *{{ .APIVersion }}.{{ .Kind }}, apiResponse map[string]interface{}) bool {
	// Marshal spec to JSON for comparison
	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return true // Assume drift on error
	}

	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return true // Assume drift on error
	}

	// Remove controller-specific fields from spec that aren't part of the API resource
	delete(specMap, "targetPodOrdinal")
	delete(specMap, "targetHelmRelease")
	delete(specMap, "targetStatefulSet")
	delete(specMap, "targetDeployment")
	delete(specMap, "targetPod")
	delete(specMap, "targetNamespace")
	delete(specMap, "targetBaseURL")
{{- if .NeedsExternalIDRef }}
	delete(specMap, "externalIDRef")
{{- end }}
	delete(specMap, "readOnly")
	delete(specMap, "mergeOnUpdate")
{{- if .HasDelete }}
	delete(specMap, "onDelete")
{{- end }}

	// Check if mergeOnUpdate is enabled (default: true)
	mergeEnabled := instance.Spec.MergeOnUpdate == nil || *instance.Spec.MergeOnUpdate

	if mergeEnabled {
		// When mergeOnUpdate is enabled, we compare what the merged result would be.
		// Start with current API state and overlay the spec fields.
		// This means only fields explicitly set in the spec can cause drift.
		mergedState := make(map[string]interface{})
		for k, v := range apiResponse {
			mergedState[k] = v
		}
		for k, v := range specMap {
			// Skip empty maps and empty slices - these represent unset Go struct fields
			// that shouldn't overwrite API values (e.g., Category{} serializes as {} but
			// shouldn't replace the API's actual category value)
			if m, ok := v.(map[string]interface{}); ok && len(m) == 0 {
				continue
			}
			if s, ok := v.([]interface{}); ok && len(s) == 0 {
				continue
			}
			mergedState[k] = v
		}

		// Compare merged state with API response
		for key, mergedValue := range mergedState {
			apiValue, exists := apiResponse[key]
			if !exists {
				// Field exists in merged but not in API - this is drift (new field being added)
				if _, inSpec := specMap[key]; inSpec {
					return true
				}
				continue
			}
			if !controllerutil2.ValuesEqual(mergedValue, apiValue) {
				return true // Drift detected
			}
		}
	} else {
		// When mergeOnUpdate is disabled, compare spec directly with API response.
		// Only fields present in the spec are compared.
		for key, specValue := range specMap {
			apiValue, exists := apiResponse[key]
			if !exists {
				// Field exists in spec but not in API response - could be drift or API doesn't return this field
				continue
			}
			if !controllerutil2.ValuesEqual(specValue, apiValue) {
				return true // Drift detected
			}
		}
	}

	return false // No drift
}

// observeResource performs a GET-only observation for read-only CRs.
func (r *{{ .Kind }}Reconciler) observeResource(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) error {
	logger := log.FromContext(ctx)

{{- if or .NeedsExternalIDRef .HasPost }}
	externalID := r.getExternalID(instance)
{{- if .NeedsExternalIDRef }}
	if externalID == "" {
		return fmt.Errorf("no external ID available for observation")
	}
{{- end }}
{{- else }}
	// Resource identified by path parameters - no external ID needed
	externalID := ""
{{- end }}

	now := metav1.Now()

	// Check if using all-healthy strategy (fan out GET to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - collect responses from all
			responses := make(map[string]{{ .APIVersion }}.{{ .Kind }}EndpointResponse)
			successCount := 0
			var firstSuccessBody []byte

			for _, baseURL := range baseURLs {
				endpointResp := {{ .APIVersion }}.{{ .Kind }}EndpointResponse{
					LastUpdated: &now,
				}

				respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
				if err != nil {
					endpointResp.Success = false
					endpointResp.Error = err.Error()
					logger.Info("Failed to observe from endpoint", "endpoint", baseURL, "error", err)
				} else if respData == nil {
					endpointResp.Success = false
					endpointResp.StatusCode = 404
					endpointResp.Error = fmt.Sprintf("resource %s not found", externalID)
					logger.Info("Resource not found at endpoint", "endpoint", baseURL, "externalID", externalID)
				} else {
					endpointResp.Success = true
					endpointResp.StatusCode = 200
					endpointResp.Data = &k8sruntime.RawExtension{Raw: body}
					successCount++
					if firstSuccessBody == nil {
						firstSuccessBody = body
					}
					logger.Info("Successfully observed from endpoint", "endpoint", baseURL, "externalID", externalID)
				}

				responses[baseURL] = endpointResp
			}

			// Update status with all responses
{{- if .HasPost }}
			instance.Status.ExternalID = externalID
{{- end }}
			instance.Status.Responses = responses
			instance.Status.LastGetTime = &now
			instance.Status.DriftDetected = false

			// Also set the single Response field with first success for backwards compatibility
			if firstSuccessBody != nil {
				instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: firstSuccessBody},
					LastUpdated: &now,
				}
			}

			if successCount == 0 {
				r.updateStatus(ctx, instance, "NotFound", fmt.Sprintf("Resource %s not found in any endpoint (%d endpoints queried)", externalID, len(baseURLs)))
				return nil
			}

			message := fmt.Sprintf("Successfully observed from %d/%d endpoints", successCount, len(baseURLs))
			logger.Info(message, "externalID", externalID)
			r.updateStatus(ctx, instance, "Observed", message)
			return nil
		}
	}

	// Single endpoint case - resolve URL and observe
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return err
	}

	respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
	if err != nil {
		return err
	}

	if respData == nil {
		r.updateStatus(ctx, instance, "NotFound", fmt.Sprintf("Resource %s not found in external API", externalID))
		return nil
	}

	// Update status with fetched data
{{- if .HasPost }}
	instance.Status.ExternalID = externalID
{{- end }}
	instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
		Success:     true,
		StatusCode:  200,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.LastGetTime = &now
	instance.Status.DriftDetected = false // No drift concept for read-only
	instance.Status.Responses = nil // Clear multi-endpoint responses for single endpoint

	logger.Info("Successfully observed resource", "externalID", externalID)
	r.updateStatus(ctx, instance, "Observed", "Successfully fetched resource from REST API")
	return nil
}

// resolveBaseURL determines the base URL to use for API requests based on CR targeting fields.
func (r *{{ .Kind }}Reconciler) resolveBaseURL(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) (string, error) {
	// Per-CR static base URL takes highest priority
	if instance.Spec.TargetBaseURL != "" {
		return instance.Spec.TargetBaseURL, nil
	}

	if r.EndpointResolver != nil {
		namespace := instance.Spec.TargetNamespace
		if namespace == "" {
			namespace = instance.Namespace
		}

		// Per-CR pod targeting
		if instance.Spec.TargetPod != "" {
			return r.EndpointResolver.GetEndpointForPod(ctx, instance.Spec.TargetPod, namespace)
		}

		// Per-CR Helm release targeting
		if instance.Spec.TargetHelmRelease != "" {
			return r.EndpointResolver.GetEndpointForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace, instance.Spec.TargetPodOrdinal)
		}

		// Per-CR StatefulSet targeting
		if instance.Spec.TargetStatefulSet != "" {
			return r.EndpointResolver.GetEndpointForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace, instance.Spec.TargetPodOrdinal)
		}

		// Per-CR Deployment targeting
		if instance.Spec.TargetDeployment != "" {
			return r.EndpointResolver.GetEndpointForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
		}

		// Global pod-name targeting (from operator flags)
		if r.EndpointResolver.IsPodConfigured() {
			return r.EndpointResolver.GetEndpointForPod(ctx, r.EndpointResolver.GetConfiguredPodName(), namespace)
		}

		// By-ordinal strategy
		if r.EndpointResolver.IsByOrdinalStrategy() {
			return r.getBaseURLByOrdinal(ctx, instance.Spec.TargetPodOrdinal)
		}
	}

	return r.getBaseURL(ctx)
}

// resolveAllHealthyEndpoints returns all healthy endpoint URLs based on CR targeting fields.
// This is used for all-healthy strategy fan-out operations.
func (r *{{ .Kind }}Reconciler) resolveAllHealthyEndpoints(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) ([]string, error) {
	// Per-CR static base URL takes highest priority
	if instance.Spec.TargetBaseURL != "" {
		return []string{instance.Spec.TargetBaseURL}, nil
	}

	if r.EndpointResolver == nil {
		// No resolver - return single static URL
		url, err := r.getBaseURL(ctx)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	namespace := instance.Spec.TargetNamespace
	if namespace == "" {
		namespace = instance.Namespace
	}

	// Per-CR pod targeting (returns single endpoint)
	if instance.Spec.TargetPod != "" {
		url, err := r.EndpointResolver.GetEndpointForPod(ctx, instance.Spec.TargetPod, namespace)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	// Per-CR Helm release targeting
	if instance.Spec.TargetHelmRelease != "" {
		return r.EndpointResolver.GetAllEndpointsForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace)
	}

	// Per-CR StatefulSet targeting
	if instance.Spec.TargetStatefulSet != "" {
		return r.EndpointResolver.GetAllEndpointsForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace)
	}

	// Per-CR Deployment targeting
	if instance.Spec.TargetDeployment != "" {
		return r.EndpointResolver.GetAllEndpointsForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
	}

	// Global pod-name targeting (returns single endpoint)
	if r.EndpointResolver.IsPodConfigured() {
		url, err := r.EndpointResolver.GetEndpointForPod(ctx, r.EndpointResolver.GetConfiguredPodName(), namespace)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	// Fall back to global all-healthy endpoints
	return r.EndpointResolver.GetAllHealthyEndpoints()
}

// syncToEndpoint syncs to a single endpoint URL with GET-first drift detection.
{{- if .HasPost }}
// On success, it updates instance.Status.ExternalID, instance.Status.Response, and instance.Status.DriftDetected.
{{- else }}
// On success, it updates instance.Status.Response and instance.Status.DriftDetected.
{{- end }}
// The caller is responsible for calling updateStatus after this returns.
func (r *{{ .Kind }}Reconciler) syncToEndpoint(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, baseURL string) error {
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "SyncToEndpoint",
		trace.WithAttributes(
			attribute.String("endpoint.url", baseURL),
		))
	defer span.End()

	logger := log.FromContext(ctx)

	now := metav1.Now()
{{- if or .NeedsExternalIDRef .HasPost }}
	externalID := r.getExternalID(instance)
	span.SetAttributes(attribute.String("resource.externalID", externalID))
{{- else }}
	// Resource identified by path parameters - no external ID needed
	externalID := ""
{{- end }}

{{- if and (not .HasPost) .NeedsExternalIDRef }}
	// POST not available - ExternalIDRef is required
	if instance.Spec.ExternalIDRef == "" {
		return fmt.Errorf("externalIDRef is required: this resource does not support creation (no POST method available)")
	}
{{- end }}

	// Determine if we should try GET first to check if resource exists
{{- if len .ResourcePathParams }}
	// Path params are required to build GET URL - skip GET if path params are invalid
	shouldTryGet := r.hasValidPathParams(instance)
{{- else if .NeedsExternalIDRef }}
	// ExternalIDRef mode - only GET if we have an ID reference
	shouldTryGet := externalID != ""
{{- else if .HasPost }}
	// POST available without path params - try GET if we have an ExternalID from previous creation
	shouldTryGet := instance.Status.ExternalID != ""
{{- else }}
	// No path params and no POST - always try GET
	shouldTryGet := true
{{- end }}

	if shouldTryGet {
		respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
		if err != nil {
			return fmt.Errorf("failed to get resource: %w", err)
		}

		instance.Status.LastGetTime = &now

		if respData != nil {
			// Resource exists - check for drift
			hasDrift := r.compareSpecWithResponse(instance, respData)
			instance.Status.DriftDetected = hasDrift
			span.SetAttributes(attribute.Bool("drift.detected", hasDrift))

			// Extract external ID from response if available (for resources identified by path params)
			responseExternalID := r.extractExternalIDFromResponse(respData, externalID)

{{- if or .HasPatch .HasPut }}
			// Snapshot original state on first adoption of existing resource
			// This applies when:
			// - Using path params (e.g., id: 10 references existing pet)
			// - Using externalIDRef to adopt existing resource
			// - Resource wasn't created by this controller
			if instance.Status.OriginalState == nil && !instance.Status.CreatedByController {
				instance.Status.OriginalState = &k8sruntime.RawExtension{Raw: body}
				instance.Status.AdoptedAt = &now
				logger.Info("Captured original state for adopted resource", "externalID", responseExternalID)
			}
{{- end }}

			if hasDrift {
				// Increment drift detected count
				instance.Status.DriftDetectedCount++
				// Record drift detection metric
				{{ .KindLower }}DriftDetected.Add(ctx, 1,
					metric.WithAttributes(
						attribute.String("resource.name", instance.Name),
						attribute.String("resource.namespace", instance.Namespace),
					))
			}

{{- if or .HasPatch .HasPut }}
			if !hasDrift {
				// No drift - skip update
				logger.Info("No drift detected, skipping update", "externalID", responseExternalID)
{{- if .HasPost }}
				instance.Status.ExternalID = responseExternalID
{{- end }}
				instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: body},
					LastUpdated: &now,
				}
				return nil
			}

			// Drift detected - proceed with update
			logger.Info("Drift detected, updating resource", "externalID", responseExternalID)
{{- if .HasPatch }}
			// Prefer PATCH for partial updates (inherently does partial update)
			return r.patchResource(ctx, instance, baseURL, responseExternalID)
{{- else }}
			// Use PUT with merge support
			return r.updateResource(ctx, instance, baseURL, responseExternalID, respData)
{{- end }}
{{- else }}
{{- if .UpdateWithPost }}
			if !hasDrift {
				// No drift - skip update
				logger.Info("No drift detected, skipping update", "externalID", responseExternalID)
				instance.Status.ExternalID = responseExternalID
				instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: body},
					LastUpdated: &now,
				}
				return nil
			}

			// Drift detected - proceed with POST (UpdateWithPost mode)
			logger.Info("Drift detected, updating resource with POST", "externalID", responseExternalID)
			return r.updateResourceWithPost(ctx, instance, baseURL, responseExternalID, respData)
{{- else }}
			// No PUT method available - just record the current state (read-only sync)
			logger.Info("Resource exists, recording current state (no PUT available)", "externalID", responseExternalID)
{{- if .HasPost }}
			instance.Status.ExternalID = responseExternalID
{{- end }}
			instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
				Success:     true,
				StatusCode:  200,
				Data:        &k8sruntime.RawExtension{Raw: body},
				LastUpdated: &now,
			}
			if hasDrift {
				// Record drift but can't update (no PUT)
				logger.Info("Drift detected but cannot update (no PUT method available)", "externalID", responseExternalID)
			}
			return nil
{{- end }}
{{- end }}
		}

{{- if .NeedsExternalIDRef }}
		// Resource doesn't exist (404) - if we're using externalIDRef, this is an error
		if instance.Spec.ExternalIDRef != "" {
			return fmt.Errorf("resource with externalIDRef %s not found", instance.Spec.ExternalIDRef)
		}
{{- end }}

		{{- if .HasPost }}
		// Resource was created by us but no longer exists - recreate it
		logger.Info("Resource no longer exists, recreating", "externalID", externalID)
		instance.Status.ExternalID = "" // Clear so we do a POST
		{{- else }}
		// Cannot recreate - POST not available
		return fmt.Errorf("resource no longer exists and cannot be recreated (no POST method available)")
		{{- end }}
	}

	{{- if .HasPost }}
	// No external ID or resource doesn't exist - create new resource
	return r.createResource(ctx, instance, baseURL)
	{{- else }}
	// This should not be reached since ExternalIDRef is required when POST is not available
	return fmt.Errorf("unexpected state: no external ID and POST not available")
	{{- end }}
}

{{- if .HasPost }}

// createResource performs a POST to create a new resource.
func (r *{{ .Kind }}Reconciler) createResource(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, baseURL string) error {
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "POST",
		trace.WithAttributes(
			attribute.String("http.method", "POST"),
			attribute.String("http.url", baseURL),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURLForCreate(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(specData))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create POST request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Creating resource", "url", url)
	logger.V(1).Info("REST API request", "method", "POST", "url", url, "body", string(specData))
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "POST", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to execute POST request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "POST", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to read POST response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "POST", "error", resp.StatusCode, duration)
		apiErr := &{{ .Kind }}APIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "POST",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, "POST", "success", resp.StatusCode, duration)

	// Parse response to extract ID
	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err == nil {
		if id, ok := respData["id"]; ok {
			switch v := id.(type) {
			case string:
				instance.Status.ExternalID = v
			case float64:
				instance.Status.ExternalID = fmt.Sprintf("%.0f", v)
			}
		}
	}

	span.SetAttributes(attribute.String("resource.externalID", instance.Status.ExternalID))

	logger.V(1).Info("REST API response", "method", "POST", "url", url, "statusCode", resp.StatusCode, "body", string(body))

	now := metav1.Now()
	instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now
{{- if .HasDelete }}
	instance.Status.CreatedByController = true
{{- end }}

	logger.Info("Successfully created resource", "externalID", instance.Status.ExternalID)
	return nil
}
{{- end }}

{{- if .HasPatch }}

// patchResource performs a PATCH to partially update an existing resource.
// PATCH inherently performs partial updates, only modifying the fields specified in the request.
func (r *{{ .Kind }}Reconciler) patchResource(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, baseURL string, externalID string) error {
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "PATCH",
		trace.WithAttributes(
			attribute.String("http.method", "PATCH"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", externalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURL(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bytes.NewReader(specData))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create PATCH request: %w", err)
	}
	req.Header.Set("Content-Type", "application/merge-patch+json")

	logger.Info("Patching resource", "url", url)
	logger.V(1).Info("REST API request", "method", "PATCH", "url", url, "body", string(specData))
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "PATCH", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to execute PATCH request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "PATCH", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to read PATCH response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "PATCH", "error", resp.StatusCode, duration)
		apiErr := &{{ .Kind }}APIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "PATCH",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, "PATCH", "success", resp.StatusCode, duration)

	logger.V(1).Info("REST API response", "method", "PATCH", "url", url, "statusCode", resp.StatusCode, "body", string(body))

	now := metav1.Now()
{{- if .HasPost }}
	instance.Status.ExternalID = externalID
{{- end }}
	instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now

	logger.Info("Successfully patched resource", "externalID", externalID)
	return nil
}
{{- end }}

{{- if .HasPut }}

// updateResource performs a PUT to update an existing resource.
// If mergeOnUpdate is true (default), it merges the spec with the current API state before sending.
func (r *{{ .Kind }}Reconciler) updateResource(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, baseURL string, externalID string, currentState map[string]interface{}) error {
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "PUT",
		trace.WithAttributes(
			attribute.String("http.method", "PUT"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", externalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

{{- if .PutPathDiffers }}
	url := r.buildResourceURLForPut(baseURL, instance)
{{- else }}
	url := r.buildResourceURL(baseURL, instance)
{{- end }}
	span.SetAttributes(attribute.String("http.url", url))

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	// Check if mergeOnUpdate is enabled (default: true)
	mergeEnabled := instance.Spec.MergeOnUpdate == nil || *instance.Spec.MergeOnUpdate
	span.SetAttributes(attribute.Bool("merge_on_update", mergeEnabled))

	var requestBody []byte
	if mergeEnabled && currentState != nil {
		// Merge spec with current API state
		requestBody, err = r.mergeSpecWithCurrentState(specData, currentState)
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			return fmt.Errorf("failed to merge spec with current state: %w", err)
		}
		logger.Info("Merged spec with current API state for PUT")
	} else {
		requestBody = specData
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bytes.NewReader(requestBody))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create PUT request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Updating resource", "url", url, "mergeEnabled", mergeEnabled)
	logger.V(1).Info("REST API request", "method", "PUT", "url", url, "body", string(requestBody))
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "PUT", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to execute PUT request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "PUT", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to read PUT response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "PUT", "error", resp.StatusCode, duration)
		apiErr := &{{ .Kind }}APIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "PUT",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, "PUT", "success", resp.StatusCode, duration)

	logger.V(1).Info("REST API response", "method", "PUT", "url", url, "statusCode", resp.StatusCode, "body", string(body))

	now := metav1.Now()
{{- if .HasPost }}
	instance.Status.ExternalID = externalID
{{- end }}
	instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now

	logger.Info("Successfully updated resource", "externalID", externalID)
	return nil
}
{{- end }}

{{- if or .HasPut .UpdateWithPost }}

// mergeSpecWithCurrentState merges the spec fields with the current API state.
// Fields explicitly set in the spec override the current state, while unset fields are preserved.
func (r *{{ .Kind }}Reconciler) mergeSpecWithCurrentState(specData []byte, currentState map[string]interface{}) ([]byte, error) {
	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return nil, fmt.Errorf("failed to unmarshal spec: %w", err)
	}

	// Start with current state as base
	merged := make(map[string]interface{})
	for k, v := range currentState {
		merged[k] = v
	}

	// Overlay spec fields (only non-zero/non-empty values)
	for k, v := range specMap {
		if !r.isZeroValue(v) {
			merged[k] = v
		}
	}

	return json.Marshal(merged)
}

// isZeroValue checks if a value is considered "zero" or empty for merge purposes.
// Zero values are not overlaid onto the current state, preserving the API's current value.
func (r *{{ .Kind }}Reconciler) isZeroValue(v interface{}) bool {
	if v == nil {
		return true
	}
	switch val := v.(type) {
	case string:
		return val == ""
	case float64:
		return val == 0
	case bool:
		return !val
	case []interface{}:
		return len(val) == 0
	case map[string]interface{}:
		return len(val) == 0
	default:
		return false
	}
}
{{- end }}

{{- if .UpdateWithPost }}

// updateResourceWithPost performs a POST to update an existing resource (when PUT is not available).
// This is used when the API uses POST for both creation and updates.
// If mergeOnUpdate is true (default), it merges the spec with the current API state before sending.
func (r *{{ .Kind }}Reconciler) updateResourceWithPost(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, baseURL string, externalID string, currentState map[string]interface{}) error {
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "POST_UPDATE",
		trace.WithAttributes(
			attribute.String("http.method", "POST"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", externalID),
			attribute.Bool("update_with_post", true),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	// Use the same URL as create (base path without ID) since this API uses POST for both create and update
	url := r.buildResourceURLForCreate(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	// Check if mergeOnUpdate is enabled (default: true)
	mergeEnabled := instance.Spec.MergeOnUpdate == nil || *instance.Spec.MergeOnUpdate
	span.SetAttributes(attribute.Bool("merge_on_update", mergeEnabled))

	var requestBody []byte
	if mergeEnabled && currentState != nil {
		// Merge spec with current API state
		requestBody, err = r.mergeSpecWithCurrentState(specData, currentState)
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			return fmt.Errorf("failed to merge spec with current state: %w", err)
		}
		logger.Info("Merged spec with current API state for POST update")
	} else {
		requestBody = specData
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(requestBody))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create POST request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Updating resource with POST", "url", url, "mergeEnabled", mergeEnabled)
	logger.V(1).Info("REST API request", "method", "POST", "url", url, "body", string(requestBody))
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "POST", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to execute POST request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "POST", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to read POST response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "POST", "error", resp.StatusCode, duration)
		apiErr := &{{ .Kind }}APIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "POST",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, "POST", "success", resp.StatusCode, duration)

	logger.V(1).Info("REST API response", "method", "POST", "url", url, "statusCode", resp.StatusCode, "body", string(body))

	now := metav1.Now()
	instance.Status.ExternalID = externalID
	instance.Status.Response = &{{ .APIVersion }}.{{ .Kind }}EndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now

	logger.Info("Successfully updated resource with POST", "externalID", externalID)
	return nil
}
{{- end }}

// marshalSpecForAPI marshals the spec for sending to the API, excluding controller-specific fields.
func (r *{{ .Kind }}Reconciler) marshalSpecForAPI(instance *{{ .APIVersion }}.{{ .Kind }}) ([]byte, error) {
	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return nil, err
	}

	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return nil, err
	}

	// Remove controller-specific fields
	delete(specMap, "targetPodOrdinal")
	delete(specMap, "targetHelmRelease")
	delete(specMap, "targetStatefulSet")
	delete(specMap, "targetDeployment")
	delete(specMap, "targetPod")
	delete(specMap, "targetNamespace")
	delete(specMap, "targetBaseURL")
{{- if .NeedsExternalIDRef }}
	delete(specMap, "externalIDRef")
{{- end }}
	delete(specMap, "readOnly")
	delete(specMap, "mergeOnUpdate")
{{- if .HasDelete }}
	delete(specMap, "onDelete")
{{- end }}

	{{- if .ResourcePathParams }}
	// Remove path parameter fields (they're used in URL, not body)
	{{- range .ResourcePathParams }}
	delete(specMap, "{{ .Name }}")
	{{- end }}
	{{- end }}

	{{- if .ResourceQueryParams }}
	// Remove query parameter fields (they're used in URL, not body)
	{{- range .ResourceQueryParams }}
	delete(specMap, "{{ .JSONName }}")
	{{- end }}
	{{- end }}

	return json.Marshal(specMap)
}

func (r *{{ .Kind }}Reconciler) syncResource(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) error {
	logger := log.FromContext(ctx)

	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - fan out to all
			var syncErrors []error
			successCount := 0

			for _, baseURL := range baseURLs {
				if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
					syncErrors = append(syncErrors, fmt.Errorf("%s: %w", baseURL, err))
				} else {
					successCount++
				}
			}

			// If all requests failed, return error
			if successCount == 0 {
				return fmt.Errorf("all sync requests failed: %v", syncErrors)
			}

			// Log partial failures
			if len(syncErrors) > 0 {
				logger.Info("Some sync requests failed", "successCount", successCount, "errors", syncErrors)
			}

			r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
			return nil
		}
	}

	// Single endpoint case - resolve URL and sync
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	logger.Info("Syncing to endpoint", "baseURL", baseURL)
	if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
		return err
	}

	r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
	return nil
}

{{- if .HasDelete }}
// deleteFromEndpoint deletes from a single endpoint URL
func (r *{{ .Kind }}Reconciler) deleteFromEndpoint(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, baseURL string) error {
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "DELETE",
		trace.WithAttributes(
			attribute.String("http.method", "DELETE"),
			attribute.String("http.url", baseURL),
{{- if .HasPost }}
			attribute.String("resource.externalID", instance.Status.ExternalID),
{{- end }}
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURL(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create delete request: %w", err)
	}

	logger.Info("Deleting external resource", "url", url)
	logger.V(1).Info("REST API request", "method", "DELETE", "url", url)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "DELETE", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to delete resource: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	// 404 is OK - resource already deleted
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusNotFound {
		body, _ := io.ReadAll(resp.Body)
		r.recordAPICallMetrics(ctx, "DELETE", "error", resp.StatusCode, duration)
		apiErr := &{{ .Kind }}APIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "DELETE",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, "DELETE", "success", resp.StatusCode, duration)
	logger.V(1).Info("REST API response", "method", "DELETE", "url", url, "statusCode", resp.StatusCode)
	logger.Info("Successfully deleted external resource")
	return nil
}

func (r *{{ .Kind }}Reconciler) finalizeResource(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) error {
	logger := log.FromContext(ctx)

{{- if len .ResourcePathParams }}
	// DELETE requires valid path parameters to build the URL
	if !r.hasValidPathParams(instance) {
		logger.Info("No valid path parameters for DELETE URL, skipping finalization")
		return nil
	}
{{- else if .HasPost }}
	// No path params means resource is identified by ExternalID only
	if instance.Status.ExternalID == "" {
		logger.Info("No external ID, skipping finalization")
		return nil
	}
{{- end }}

	// Determine deletion policy
	policy := instance.Spec.OnDelete
	if policy == "" {
		// Default: Delete if we created it, Orphan if we adopted it
		if instance.Status.CreatedByController {
			policy = "Delete"
		} else {
			policy = "Orphan"
		}
	}

	logger.Info("Finalizing resource", "policy", policy, "createdByController", instance.Status.CreatedByController)

	switch policy {
	case "Restore":
{{- if or .HasPatch .HasPut }}
		if instance.Status.OriginalState == nil {
			logger.Info("No original state to restore, orphaning instead")
			return nil
		}
		return r.restoreOriginalState(ctx, instance)
{{- else }}
		// Restore not supported without PUT/PATCH - orphan instead
		logger.Info("Restore not supported (no PUT/PATCH method), orphaning instead")
		return nil
{{- end }}
	case "Orphan":
		logger.Info("Orphaning external resource", "externalID", r.getExternalID(instance))
		return nil
	case "Delete":
		// Continue with delete logic below
	default:
		logger.Info("Unknown OnDelete policy, defaulting to Orphan", "policy", policy)
		return nil
	}

	// Delete the external resource
	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - fan out delete to all
			var deleteErrors []error
			successCount := 0

			for _, baseURL := range baseURLs {
				if err := r.deleteFromEndpoint(ctx, instance, baseURL); err != nil {
					deleteErrors = append(deleteErrors, fmt.Errorf("%s: %w", baseURL, err))
				} else {
					successCount++
				}
			}

			// If all requests failed, return error
			if successCount == 0 {
				return fmt.Errorf("all delete requests failed: %v", deleteErrors)
			}

			// Log partial failures but consider success if at least one succeeded
			if len(deleteErrors) > 0 {
				logger.Info("Some delete requests failed", "successCount", successCount, "errors", deleteErrors)
			}

			return nil
		}
	}

	// Single endpoint case - resolve URL and delete
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	return r.deleteFromEndpoint(ctx, instance, baseURL)
}

{{- if or .HasPatch .HasPut }}
// restoreOriginalState restores the external resource to its original state captured during adoption.
// This works for resources adopted via path params (e.g., id: 10) or externalIDRef.
func (r *{{ .Kind }}Reconciler) restoreOriginalState(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) error {
{{- if .UpdateWithPost }}
	httpMethod := "POST"
{{- else }}
	httpMethod := "PUT"
{{- end }}

	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "RestoreOriginalState",
		trace.WithAttributes(
			attribute.String("resource.externalID", r.getExternalID(instance)),
			attribute.String("http.method", httpMethod),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

{{- if .UpdateWithPost }}
	// Use create URL for POST-based updates
	url := r.buildResourceURLForCreate(baseURL, instance)
{{- else }}
	url := r.buildResourceURL(baseURL, instance)
{{- end }}
	span.SetAttributes(attribute.String("http.url", url))

	req, err := http.NewRequestWithContext(ctx, httpMethod, url, bytes.NewReader(instance.Status.OriginalState.Raw))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create restore request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Restoring original state", "url", url, "method", httpMethod)
	logger.V(1).Info("REST API request", "method", httpMethod, "url", url, "body", string(instance.Status.OriginalState.Raw))
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, httpMethod, "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to restore original state: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	// 404 is acceptable - resource may have been deleted externally
	if resp.StatusCode == http.StatusNotFound {
		r.recordAPICallMetrics(ctx, httpMethod, "not_found", resp.StatusCode, duration)
		logger.Info("Resource not found during restore (may have been deleted externally)")
		return nil
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		r.recordAPICallMetrics(ctx, httpMethod, "error", resp.StatusCode, duration)
		apiErr := &{{ .Kind }}APIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     httpMethod,
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, httpMethod, "success", resp.StatusCode, duration)
	logger.V(1).Info("REST API response", "method", httpMethod, "url", url, "statusCode", resp.StatusCode)
	logger.Info("Successfully restored original state", "externalID", r.getExternalID(instance))
	return nil
}
{{- end }}
{{- end }}

func (r *{{ .Kind }}Reconciler) updateStatus(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, state, message string) {
	logger := log.FromContext(ctx)

	// Capture status values we want to preserve from the current instance
	// These may have been set during syncToEndpoint
	statusSnapshot := instance.Status.DeepCopy()

	// Retry on conflict - refetch and reapply status
	err := retry.RetryOnConflict(retry.DefaultRetry, func() error {
		// Fetch the latest version
		latest := &{{ .APIVersion }}.{{ .Kind }}{}
		if err := r.Get(ctx, client.ObjectKeyFromObject(instance), latest); err != nil {
			return err
		}

		now := metav1.Now()
		// Apply captured status values
		latest.Status = *statusSnapshot
		latest.Status.State = state
		latest.Status.Message = message
		latest.Status.LastSyncTime = &now
		latest.Status.ObservedGeneration = latest.Generation

		// Update condition
		condition := metav1.Condition{
			Type:               "Ready",
			Status:             metav1.ConditionFalse,
			Reason:             state,
			Message:            message,
			LastTransitionTime: now,
		}
		// Set Ready=True for successful states
		if state == "Synced" || state == "Observed" {
			condition.Status = metav1.ConditionTrue
		}
		meta.SetStatusCondition(&latest.Status.Conditions, condition)

		return r.Status().Update(ctx, latest)
	})

	if err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *{{ .Kind }}Reconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&{{ .APIVersion }}.{{ .Kind }}{}).
		Complete(r)
}
