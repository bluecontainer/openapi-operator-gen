/*
Copyright {{ .Year }} Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package main

import (
	"context"
	"flag"
	"net/http"
	"os"
	"time"

	"k8s.io/apimachinery/pkg/runtime"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/healthz"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"

	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

	{{ .APIVersion }} "{{ .ModuleName }}/api/{{ .APIVersion }}"
	"{{ .ModuleName }}/internal/controller"
	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	"github.com/bluecontainer/openapi-operator-gen/pkg/telemetry"
)

var (
	scheme   = runtime.NewScheme()
	setupLog = ctrl.Log.WithName("setup")
)

func init() {
	utilruntime.Must(clientgoscheme.AddToScheme(scheme))
	utilruntime.Must({{ .APIVersion }}.AddToScheme(scheme))
}

func main() {
	var metricsAddr string
	var probeAddr string

	// Static URL mode
	var baseURL string

	// Workload discovery mode
	var stsName string
	var deployName string
	var namespace string
	var stsServiceName string
	var port int
	var urlScheme string
	var strategy string
	var discoveryMode string
	var healthPath string
	var workloadKind string

	// Helm release discovery mode
	var helmRelease string

	flag.StringVar(&metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
	flag.StringVar(&probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")

	// Static URL mode flags
	flag.StringVar(&baseURL, "base-url", "", "Base URL of the REST API (static mode)")

	// Workload discovery mode flags
	flag.StringVar(&stsName, "statefulset-name", "", "Name of the StatefulSet to discover endpoints from")
	flag.StringVar(&deployName, "deployment-name", "", "Name of the Deployment to discover endpoints from")
	flag.StringVar(&namespace, "namespace", "", "Namespace of the workload (defaults to operator namespace)")
	flag.StringVar(&stsServiceName, "service", "", "Headless service name for DNS discovery (StatefulSet only)")
	flag.IntVar(&port, "port", 8080, "Port number for REST API on pods")
	flag.StringVar(&urlScheme, "scheme", "http", "URL scheme (http or https)")
	flag.StringVar(&strategy, "strategy", "round-robin", "Endpoint selection strategy: round-robin, leader-only, any-healthy, all-healthy, by-ordinal")
	flag.StringVar(&discoveryMode, "discovery-mode", "", "Discovery mode: dns or pod-ip (defaults to dns for StatefulSet, pod-ip for Deployment)")
	flag.StringVar(&healthPath, "health-path", "/health", "Health check path (empty to disable)")
	flag.StringVar(&workloadKind, "workload-kind", "auto", "Workload type: statefulset, deployment, or auto")

	// Helm release discovery mode flags
	flag.StringVar(&helmRelease, "helm-release", "", "Helm release name to discover workload from (auto-detects StatefulSet or Deployment)")

	opts := zap.Options{Development: true}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()

	ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))

	// Initialize OpenTelemetry (configured via environment variables)
	ctx := context.Background()
	otelProvider, err := telemetry.InitProviderFromEnv(ctx, "{{ .AppName }}-operator", "v0.0.1")
	if err != nil {
		setupLog.Error(err, "failed to initialize OpenTelemetry")
		os.Exit(1)
	}
	if otelProvider != nil {
		defer func() {
			shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()
			if err := otelProvider.Shutdown(shutdownCtx); err != nil {
				setupLog.Error(err, "failed to shutdown OpenTelemetry")
			}
		}()
		setupLog.Info("OpenTelemetry initialized", "endpoint", os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT"))
	}

	// Check environment variables as fallback
	if baseURL == "" {
		baseURL = os.Getenv("REST_API_BASE_URL")
	}
	if stsName == "" {
		stsName = os.Getenv("STATEFULSET_NAME")
	}
	if deployName == "" {
		deployName = os.Getenv("DEPLOYMENT_NAME")
	}
	if helmRelease == "" {
		helmRelease = os.Getenv("HELM_RELEASE")
	}
	if namespace == "" {
		namespace = os.Getenv("WORKLOAD_NAMESPACE")
		if namespace == "" {
			// Try to get from downward API
			if ns, err := os.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace"); err == nil {
				namespace = string(ns)
			}
		}
	}
	if stsServiceName == "" {
		stsServiceName = os.Getenv("SERVICE_NAME")
	}

	// Check if global endpoint configuration is provided
	useWorkloadDiscovery := stsName != "" || deployName != "" || helmRelease != ""
	hasGlobalConfig := useWorkloadDiscovery || baseURL != ""

	if !hasGlobalConfig {
		setupLog.Info("No global endpoint configuration provided - CRs must specify targetHelmRelease, targetStatefulSet, or targetDeployment")
	}

	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme:                 scheme,
		HealthProbeBindAddress: probeAddr,
	})
	if err != nil {
		setupLog.Error(err, "unable to start manager")
		os.Exit(1)
	}

	// Create HTTP client with OpenTelemetry instrumentation
	httpClient := &http.Client{
		Timeout:   30 * time.Second,
		Transport: otelhttp.NewTransport(http.DefaultTransport),
	}

	// Only default service name if StatefulSet name is explicitly provided
	if stsServiceName == "" && stsName != "" {
		stsServiceName = stsName
	}

	// Always create endpoint resolver for per-CR targeting support
	cfg := endpoint.Config{
		StatefulSetName: stsName,
		DeploymentName:  deployName,
		Namespace:       namespace,
		HelmRelease:     helmRelease,
		WorkloadKind:    endpoint.WorkloadKind(workloadKind),
		ServiceName:     stsServiceName,
		Port:            port,
		Scheme:          urlScheme,
		Strategy:        endpoint.Strategy(strategy),
		DiscoveryMode:   endpoint.DiscoveryMode(discoveryMode),
		HealthCheckPath: healthPath,
	}

	resolver := endpoint.NewResolver(mgr.GetClient(), cfg)

	// Start resolver's background refresh only if global workload discovery is configured
	if useWorkloadDiscovery {
		if err := resolver.Start(ctx); err != nil {
			setupLog.Error(err, "unable to start endpoint resolver")
			os.Exit(1)
		}

		if helmRelease != "" {
			setupLog.Info("Using Helm release endpoint discovery",
				"helmRelease", helmRelease,
				"namespace", namespace,
				"workloadKind", workloadKind,
				"strategy", strategy,
				"discovery", discoveryMode)
		} else if deployName != "" {
			setupLog.Info("Using Deployment endpoint discovery",
				"deployment", deployName,
				"namespace", namespace,
				"strategy", strategy)
		} else {
			setupLog.Info("Using StatefulSet endpoint discovery",
				"statefulset", stsName,
				"namespace", namespace,
				"strategy", strategy,
				"discovery", discoveryMode)
		}
	} else if baseURL != "" {
		setupLog.Info("Using static base URL", "url", baseURL)
	}

{{ range .CRDs }}
	if err = (&controller.{{ .Kind }}Reconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "{{ .Kind }}")
		os.Exit(1)
	}
{{ end }}
{{- if .HasAggregate }}
	// Setup aggregate controller (read-only, no HTTP client needed)
	if err = (&controller.{{ .AggregateKind }}Reconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "{{ .AggregateKind }}")
		os.Exit(1)
	}
{{- end }}

	if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil {
		setupLog.Error(err, "unable to set up health check")
		os.Exit(1)
	}
	if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil {
		setupLog.Error(err, "unable to set up ready check")
		os.Exit(1)
	}

	setupLog.Info("starting manager")
	if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {
		setupLog.Error(err, "problem running manager")
		os.Exit(1)
	}
}
