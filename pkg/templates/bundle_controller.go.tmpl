/*
Copyright {{ .Year }} Generated by openapi-operator-gen {{ .GeneratorVersion }}.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/bluecontainer/openapi-operator-gen/pkg/aggregate"
	"github.com/bluecontainer/openapi-operator-gen/pkg/bundle"
	celutil "github.com/bluecontainer/openapi-operator-gen/pkg/cel"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	k8stypes "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/util/retry"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	controllerutil2 "github.com/bluecontainer/openapi-operator-gen/pkg/controller"
	{{ .APIVersion }} "{{ .ModuleName }}/api/{{ .APIVersion }}"
)

var (
	{{ .KindLower }}Tracer = otel.Tracer("{{ .ModuleName }}/controller/{{ .KindLower }}")
	{{ .KindLower }}Meter  = otel.Meter("{{ .ModuleName }}/controller/{{ .KindLower }}")

	// Metrics
	{{ .KindLower }}ReconcileTotal    metric.Int64Counter
	{{ .KindLower }}ReconcileDuration metric.Float64Histogram
	{{ .KindLower }}ResourcesTotal    metric.Int64UpDownCounter
)

func init() {
	var err error

	{{ .KindLower }}ReconcileTotal, err = {{ .KindLower }}Meter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}ReconcileDuration, err = {{ .KindLower }}Meter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}ResourcesTotal, err = {{ .KindLower }}Meter.Int64UpDownCounter(
		"bundle_resources_total",
		metric.WithDescription("Total number of resources in the bundle"),
		metric.WithUnit("{resource}"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
	{{ .KindLower }}FinalizerName = "{{ .APIGroup }}/bundle-finalizer"
	// {{ .KindLower }}RetryAfter is used to requeue when waiting for child resources to sync
	{{ .KindLower }}RetryAfter    = time.Second * 5
)

// {{ .Kind }}Reconciler reconciles a {{ .Kind }} object
type {{ .Kind }}Reconciler struct {
	client.Client
	Scheme *k8sruntime.Scheme
}

// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }},verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/status,verbs=get;update;patch
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/finalizers,verbs=update
{{- range .AllKinds }}
// +kubebuilder:rbac:groups={{ $.APIGroup }},resources={{ . | pluralize }},verbs=get;list;watch;create;update;patch;delete
{{- end }}

// Reconcile is part of the main kubernetes reconciliation loop
func (r *{{ .Kind }}Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// Start tracing span
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "{{ .Kind }}"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	// Record metrics
	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	{{ .KindLower }}ReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	{{ .KindLower }}ReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

// reconcileInternal contains the actual reconciliation logic
func (r *{{ .Kind }}Reconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the {{ .Kind }} instance
	bundle := &{{ .APIVersion }}.{{ .Kind }}{}
	err := r.Get(ctx, req.NamespacedName, bundle)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("{{ .Kind }} resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get {{ .Kind }}")
		return ctrl.Result{}, err
	}

	// Handle deletion
	if !bundle.DeletionTimestamp.IsZero() {
		return r.handleDeletion(ctx, bundle)
	}

	// Add finalizer if not present
	if !controllerutil.ContainsFinalizer(bundle, {{ .KindLower }}FinalizerName) {
		controllerutil.AddFinalizer(bundle, {{ .KindLower }}FinalizerName)
		if err := r.Update(ctx, bundle); err != nil {
			return ctrl.Result{}, err
		}
		return ctrl.Result{Requeue: true}, nil
	}

	// Check if paused
	if bundle.Spec.Paused {
		return r.updateBundleStatus(ctx, bundle, "Paused", "Reconciliation paused")
	}

	// Build dependency graph and determine execution order
	order, err := r.buildExecutionOrder(bundle.Spec.Resources)
	if err != nil {
		return r.updateBundleStatus(ctx, bundle, "Failed", fmt.Sprintf("Invalid dependencies: %v", err))
	}

	// Process resources in dependency order
	return r.syncResources(ctx, bundle, order)
}

// buildExecutionOrder builds a DAG and returns topologically sorted resource IDs
// Dependencies are derived from:
// 1. Explicit dependsOn declarations
// 2. Implicit references in spec via ${resources.<id>...} patterns
// Uses shared bundle package for dependency extraction and validation.
func (r *{{ .Kind }}Reconciler) buildExecutionOrder(resources []{{ .APIVersion }}.BundleResourceSpec) ([]string, error) {
	if len(resources) == 0 {
		return []string{}, nil
	}

	// Build set of valid resource IDs for validation
	validIDs := make(map[string]bool)
	for _, res := range resources {
		validIDs[res.ID] = true
	}

	// Build adjacency list
	inDegree := make(map[string]int)
	dependents := make(map[string][]string) // Maps resource ID to IDs that depend on it

	// Initialize all resources with 0 in-degree
	for _, res := range resources {
		inDegree[res.ID] = 0
	}

	// Build dependency graph from explicit dependsOn and implicit references
	for _, res := range resources {
		// Collect all dependencies (explicit + implicit) using shared bundle package
		allDeps := make(map[string]bool)

		// Add explicit dependencies
		for _, dep := range res.DependsOn {
			allDeps[dep] = true
		}

		// Extract implicit dependencies from spec using shared bundle package
		if res.Spec.Raw != nil {
			for _, dep := range bundle.ExtractDependenciesFromBytes(res.Spec.Raw, false) {
				allDeps[dep] = true
			}
		}

		// Also check readyWhen and skipWhen conditions for references (include bare refs)
		for _, condition := range res.ReadyWhen {
			for _, dep := range bundle.ExtractDependenciesFromExpression(condition) {
				allDeps[dep] = true
			}
		}
		for _, condition := range res.SkipWhen {
			for _, dep := range bundle.ExtractDependenciesFromExpression(condition) {
				allDeps[dep] = true
			}
		}

		// Remove self-reference if any
		delete(allDeps, res.ID)

		// Validate and add dependencies
		for dep := range allDeps {
			if !validIDs[dep] {
				return nil, fmt.Errorf("resource %s depends on unknown resource %s", res.ID, dep)
			}
			inDegree[res.ID]++
			dependents[dep] = append(dependents[dep], res.ID)
		}
	}

	// Kahn's algorithm for topological sort with deterministic ordering
	var queue []string
	for id, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, id)
		}
	}

	// Sort queue for deterministic ordering
	sort.Strings(queue)

	var order []string
	for len(queue) > 0 {
		// Take from front of sorted queue
		id := queue[0]
		queue = queue[1:]
		order = append(order, id)

		// Get dependents and sort for determinism
		deps := dependents[id]
		sort.Strings(deps)

		// Reduce in-degree of dependent resources
		for _, dependent := range deps {
			inDegree[dependent]--
			if inDegree[dependent] == 0 {
				queue = append(queue, dependent)
				// Re-sort queue to maintain deterministic order
				sort.Strings(queue)
			}
		}
	}

	if len(order) != len(resources) {
		return nil, fmt.Errorf("circular dependency detected")
	}

	return order, nil
}

// syncResources creates/updates resources in dependency order
func (r *{{ .Kind }}Reconciler) syncResources(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}, order []string) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Build resource map for quick lookup
	resourceMap := make(map[string]{{ .APIVersion }}.BundleResourceSpec)
	for _, res := range bundle.Spec.Resources {
		resourceMap[res.ID] = res
	}

	// Build status map from existing resources
	statusMap := make(map[string]*{{ .APIVersion }}.BundleResourceStatus)
	for i := range bundle.Status.Resources {
		statusMap[bundle.Status.Resources[i].ID] = &bundle.Status.Resources[i]
	}

	// Process in order
	var statuses []{{ .APIVersion }}.BundleResourceStatus
	allSynced := true
	hasFailed := false
	needsRequeue := false

	for _, id := range order {
		res := resourceMap[id]

		// Check skipWhen conditions
		if len(res.SkipWhen) > 0 {
			skip, err := r.evaluateConditions(res.SkipWhen, statusMap, bundle)
			if err != nil {
				logger.Error(err, "Failed to evaluate skipWhen", "resource", id)
			}
			if skip {
				now := metav1.Now()
				statuses = append(statuses, {{ .APIVersion }}.BundleResourceStatus{
					ID:           id,
					Kind:         res.Kind,
					Name:         fmt.Sprintf("%s-%s", bundle.Name, id),
					State:        "Skipped",
					Skipped:      true,
					LastSyncTime: &now,
				})
				continue
			}
		}

		// Check if dependencies are ready
		depsReady := r.checkDependenciesReady(res.DependsOn, statusMap)
		if !depsReady {
			statuses = append(statuses, {{ .APIVersion }}.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    fmt.Sprintf("%s-%s", bundle.Name, id),
				State:   "Pending",
				Message: "Waiting for dependencies",
			})
			allSynced = false
			needsRequeue = true
			continue
		}

		// Get existing child's REST API response data (for preserving ${now()} values)
		childName := fmt.Sprintf("%s-%s", bundle.Name, id)
		existingResponseData := r.getExistingChildResponseData(ctx, res.Kind, childName, bundle.Namespace)

		// Resolve CEL expressions in spec, using REST API response values for ${now()} if available
		resolvedSpec, err := r.resolveExpressions(res.Spec, statusMap, bundle, existingResponseData)
		if err != nil {
			statuses = append(statuses, {{ .APIVersion }}.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    childName,
				State:   "Failed",
				Message: fmt.Sprintf("Expression error: %v", err),
			})
			hasFailed = true
			continue
		}

		// Create or update the child resource
		status, err := r.syncChildResource(ctx, bundle, id, res.Kind, resolvedSpec)
		if err != nil {
			statuses = append(statuses, {{ .APIVersion }}.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    fmt.Sprintf("%s-%s", bundle.Name, id),
				State:   "Failed",
				Message: err.Error(),
			})
			hasFailed = true
			continue
		}

		// Check readyWhen conditions if specified
		if len(res.ReadyWhen) > 0 && status.State == "Synced" {
			ready, err := r.evaluateConditions(res.ReadyWhen, statusMap, bundle)
			if err != nil {
				logger.Error(err, "Failed to evaluate readyWhen", "resource", id)
			}
			status.Ready = ready
		} else {
			status.Ready = status.State == "Synced"
		}

		statuses = append(statuses, *status)
		statusMap[id] = status // Update statusMap for dependent resources

		if status.State != "Synced" {
			allSynced = false
			needsRequeue = true
		}
	}

	// Update bundle status
	bundle.Status.Resources = statuses
	bundle.Status.Summary = r.calculateSummary(statuses)

	// Update resource metrics
	{{ .KindLower }}ResourcesTotal.Add(ctx, int64(bundle.Status.Summary.Total),
		metric.WithAttributes(
			attribute.String("bundle.name", bundle.Name),
			attribute.String("bundle.namespace", bundle.Namespace),
		))

	var state, message string
	if hasFailed {
		state = "Failed"
		message = fmt.Sprintf("%d resources failed", bundle.Status.Summary.Failed)
	} else if allSynced {
		state = "Synced"
		message = "All resources synced"
	} else {
		state = "Syncing"
		message = fmt.Sprintf("%d/%d resources synced", bundle.Status.Summary.Synced, bundle.Status.Summary.Total)
	}

	logger.Info("Bundle sync status",
		"state", state,
		"total", bundle.Status.Summary.Total,
		"synced", bundle.Status.Summary.Synced,
		"failed", bundle.Status.Summary.Failed)

	result, _ := r.updateBundleStatus(ctx, bundle, state, message)

	// Requeue if not all synced
	if needsRequeue {
		return ctrl.Result{RequeueAfter: {{ .KindLower }}RetryAfter}, nil
	}

	return result, nil
}

// getExistingChildResponseData retrieves the status.response.data of an existing child resource.
// Returns nil if the resource doesn't exist or has no response data.
// This is used to preserve ${now()} values on updates - we use the value from the REST API
// response (the authoritative source) instead of re-evaluating to new timestamps.
func (r *{{ .Kind }}Reconciler) getExistingChildResponseData(
	ctx context.Context,
	kind string,
	name string,
	namespace string,
) map[string]interface{} {
	switch kind {
{{- range .ResourceKinds }}
	case "{{ . }}":
		existing := &{{ $.APIVersion }}.{{ . }}{}
		if err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: namespace}, existing); err != nil {
			return nil
		}
		// Use status.response.data if available (contains REST API response)
		if existing.Status.Response != nil && existing.Status.Response.Data != nil && existing.Status.Response.Data.Raw != nil {
			var dataMap map[string]interface{}
			if err := json.Unmarshal(existing.Status.Response.Data.Raw, &dataMap); err != nil {
				return nil
			}
			return dataMap
		}
		return nil
{{- end }}
{{- range .QueryKinds }}
	case "{{ . }}":
		// Query CRDs don't have REST API response data to preserve
		// ${now()} should be re-evaluated for periodic queries
		return nil
{{- end }}
{{- range .ActionKinds }}
	case "{{ . }}":
		// Action CRDs don't have REST API response data to preserve in the same way
		// ${now()} should be evaluated fresh for each action execution
		return nil
{{- end }}
	default:
		return nil
	}
}

// syncChildResource creates or updates a single child resource
func (r *{{ .Kind }}Reconciler) syncChildResource(
	ctx context.Context,
	bundle *{{ .APIVersion }}.{{ .Kind }},
	id string,
	kind string,
	spec []byte,
) (*{{ .APIVersion }}.BundleResourceStatus, error) {
	// Generate child resource name
	childName := fmt.Sprintf("%s-%s", bundle.Name, id)

	// Create the appropriate typed resource based on kind
	switch kind {
{{- range .ResourceKinds }}
	case "{{ . }}":
		return r.sync{{ . }}(ctx, bundle, childName, id, spec)
{{- end }}
{{- range .QueryKinds }}
	case "{{ . }}":
		return r.sync{{ . }}(ctx, bundle, childName, id, spec)
{{- end }}
{{- range .ActionKinds }}
	case "{{ . }}":
		return r.sync{{ . }}(ctx, bundle, childName, id, spec)
{{- end }}
	default:
		return nil, fmt.Errorf("unknown kind: %s", kind)
	}
}

{{- range .ResourceKinds }}

// sync{{ . }} creates/updates a {{ . }} resource
func (r *{{ $.Kind }}Reconciler) sync{{ . }}(
	ctx context.Context,
	bundle *{{ $.APIVersion }}.{{ $.Kind }},
	name string,
	id string,
	specData []byte,
) (*{{ $.APIVersion }}.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child {{ $.APIVersion }}.{{ . }}
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for {{ . }}: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &{{ $.APIVersion }}.{{ . }}{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "{{ . }}", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &{{ $.APIVersion }}.BundleResourceStatus{
			ID:           id,
			Kind:         "{{ . }}",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed (using smart comparison that handles timestamp fields)
	if !r.specsEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "{{ . }}", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			if errors.IsConflict(err) {
				// Resource was modified, requeue to retry
				return &{{ $.APIVersion }}.BundleResourceStatus{
					ID:           id,
					Kind:         "{{ . }}",
					Name:         name,
					State:        "Pending",
					Message:      "Resource conflict, retrying",
					LastSyncTime: existing.Status.LastSyncTime,
				}, nil
			}
			return nil, err
		}
	}

	// Return current status (default to "Pending" if state is empty)
	state := existing.Status.State
	if state == "" {
		state = "Pending"
	}
	return &{{ $.APIVersion }}.BundleResourceStatus{
		ID:           id,
		Kind:         "{{ . }}",
		Name:         name,
		State:        state,
		ExternalID:   controllerutil2.GetExternalIDIfPresent(existing),
		Message:      existing.Status.Message,
		Ready:        state == "Synced",
		LastSyncTime: existing.Status.LastSyncTime,
	}, nil
}
{{- end }}

{{- range .QueryKinds }}

// sync{{ . }} creates/updates a {{ . }} resource
func (r *{{ $.Kind }}Reconciler) sync{{ . }}(
	ctx context.Context,
	bundle *{{ $.APIVersion }}.{{ $.Kind }},
	name string,
	id string,
	specData []byte,
) (*{{ $.APIVersion }}.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child {{ $.APIVersion }}.{{ . }}
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for {{ . }}: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &{{ $.APIVersion }}.{{ . }}{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "{{ . }}", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &{{ $.APIVersion }}.BundleResourceStatus{
			ID:           id,
			Kind:         "{{ . }}",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed (using smart comparison that handles timestamp fields)
	if !r.specsEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "{{ . }}", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			if errors.IsConflict(err) {
				// Resource was modified, requeue to retry
				return &{{ $.APIVersion }}.BundleResourceStatus{
					ID:           id,
					Kind:         "{{ . }}",
					Name:         name,
					State:        "Pending",
					Message:      "Resource conflict, retrying",
					LastSyncTime: existing.Status.LastQueryTime,
				}, nil
			}
			return nil, err
		}
	}

	// Return current status (Query CRDs use "Queried" as success state)
	// Normalize to Bundle-compatible states: Queried -> Synced
	state := existing.Status.State
	ready := false
	switch state {
	case "Queried":
		state = "Synced" // Normalize to Bundle's allowed state
		ready = true
	case "":
		state = "Pending"
	}
	return &{{ $.APIVersion }}.BundleResourceStatus{
		ID:           id,
		Kind:         "{{ . }}",
		Name:         name,
		State:        state,
		Message:      existing.Status.Message,
		Ready:        ready,
		LastSyncTime: existing.Status.LastQueryTime,
	}, nil
}
{{- end }}

{{- range .ActionKinds }}

// sync{{ . }} creates/updates a {{ . }} resource
func (r *{{ $.Kind }}Reconciler) sync{{ . }}(
	ctx context.Context,
	bundle *{{ $.APIVersion }}.{{ $.Kind }},
	name string,
	id string,
	specData []byte,
) (*{{ $.APIVersion }}.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child {{ $.APIVersion }}.{{ . }}
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for {{ . }}: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &{{ $.APIVersion }}.{{ . }}{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "{{ . }}", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &{{ $.APIVersion }}.BundleResourceStatus{
			ID:           id,
			Kind:         "{{ . }}",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed (using smart comparison that handles timestamp fields)
	if !r.specsEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "{{ . }}", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			if errors.IsConflict(err) {
				// Resource was modified, requeue to retry
				return &{{ $.APIVersion }}.BundleResourceStatus{
					ID:           id,
					Kind:         "{{ . }}",
					Name:         name,
					State:        "Pending",
					Message:      "Resource conflict, retrying",
					LastSyncTime: existing.Status.LastExecutionTime,
				}, nil
			}
			return nil, err
		}
	}

	// Return current status (Action CRDs use "Completed" as success state)
	// Normalize to Bundle-compatible states: Completed -> Synced, Executing -> Creating
	state := existing.Status.State
	ready := false
	switch state {
	case "Completed":
		state = "Synced" // Normalize to Bundle's allowed state
		ready = true
	case "Executing":
		state = "Creating" // Normalize to Bundle's allowed state (in progress)
	case "":
		state = "Pending"
	}
	return &{{ $.APIVersion }}.BundleResourceStatus{
		ID:           id,
		Kind:         "{{ . }}",
		Name:         name,
		State:        state,
		Message:      existing.Status.Message,
		Ready:        ready,
		LastSyncTime: existing.Status.LastExecutionTime,
	}, nil
}
{{- end }}

// handleDeletion handles bundle deletion - child resources are cleaned up via ownerReferences
func (r *{{ .Kind }}Reconciler) handleDeletion(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	if !controllerutil.ContainsFinalizer(bundle, {{ .KindLower }}FinalizerName) {
		return ctrl.Result{}, nil
	}

	logger.Info("Handling bundle deletion")

	// Child resources are garbage collected via ownerReferences
	// Just remove the finalizer
	controllerutil.RemoveFinalizer(bundle, {{ .KindLower }}FinalizerName)
	if err := r.Update(ctx, bundle); err != nil {
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}

// checkDependenciesReady checks if all dependencies are in a ready state
func (r *{{ .Kind }}Reconciler) checkDependenciesReady(dependsOn []string, statusMap map[string]*{{ .APIVersion }}.BundleResourceStatus) bool {
	for _, dep := range dependsOn {
		status, exists := statusMap[dep]
		if !exists {
			return false
		}
		if !status.Ready && !status.Skipped {
			return false
		}
	}
	return true
}

// evaluateConditions evaluates CEL conditions against current resource status
func (r *{{ .Kind }}Reconciler) evaluateConditions(conditions []string, statusMap map[string]*{{ .APIVersion }}.BundleResourceStatus, bundle *{{ .APIVersion }}.{{ .Kind }}) (bool, error) {
	if len(conditions) == 0 {
		return true, nil
	}

	// Build variables for CEL evaluation
	// resources is a map where keys are resource IDs for expressions like: resources.backend.status.state
	resourcesVar := make(map[string]interface{})
	for id, status := range statusMap {
		resourcesVar[id] = map[string]interface{}{
			"status": map[string]interface{}{
				"state":      status.State,
				"externalID": status.ExternalID,
				"message":    status.Message,
				"ready":      status.Ready,
				"skipped":    status.Skipped,
			},
		}
	}

	// Create CEL environment for Bundle condition evaluation
	// This environment treats "resources" as a map (not a list) for dot-notation access
	env, err := celutil.NewBundleConditionEnvironment()
	if err != nil {
		return false, fmt.Errorf("failed to create CEL environment: %w", err)
	}

	// All conditions must be true (AND logic)
	for _, condition := range conditions {
		vars := map[string]interface{}{
			"resources": resourcesVar,
		}

		result := celutil.Evaluate(env, condition, vars)
		if result.Error != nil {
			return false, fmt.Errorf("failed to evaluate condition %q: %w", condition, result.Error)
		}

		// Check if result is a boolean
		if boolResult, ok := result.Value.(bool); ok {
			if !boolResult {
				return false, nil
			}
		} else {
			return false, fmt.Errorf("condition %q did not evaluate to boolean, got %T", condition, result.Value)
		}
	}

	return true, nil
}

// resolveExpressions replaces CEL expressions in spec with resolved values.
// If existingSpec is provided (non-nil), ${now()} expressions will use the
// existing value instead of generating a new timestamp. This prevents drift
// on updates when the bundle uses dynamic timestamps.
func (r *{{ .Kind }}Reconciler) resolveExpressions(
	spec k8sruntime.RawExtension,
	statusMap map[string]*{{ .APIVersion }}.BundleResourceStatus,
	bundle *{{ .APIVersion }}.{{ .Kind }},
	existingSpec map[string]interface{},
) ([]byte, error) {
	if spec.Raw == nil {
		return []byte("{}"), nil
	}

	// Parse spec as JSON
	var data map[string]interface{}
	if err := json.Unmarshal(spec.Raw, &data); err != nil {
		return nil, err
	}

	// Build resources map for expression resolution
	resourcesVar := make(map[string]interface{})
	for id, status := range statusMap {
		resourcesVar[id] = map[string]interface{}{
			"status": map[string]interface{}{
				"state":      status.State,
				"externalID": status.ExternalID,
				"message":    status.Message,
				"ready":      status.Ready,
			},
		}
	}

	// Recursively resolve expressions, passing existingSpec for ${now()} preservation
	resolved, err := r.resolveMap(data, resourcesVar, existingSpec)
	if err != nil {
		return nil, err
	}

	return json.Marshal(resolved)
}

// resolveMap recursively resolves CEL expressions in a map.
// existingSpec is used to preserve ${now()} values on updates - if a field had
// ${now()} and the resource already exists, use the existing value instead.
func (r *{{ .Kind }}Reconciler) resolveMap(
	data map[string]interface{},
	resources map[string]interface{},
	existingSpec map[string]interface{},
) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	for key, value := range data {
		switch v := value.(type) {
		case string:
			// Check if it's a standalone CEL expression: ${...}
			if strings.HasPrefix(v, "${") && strings.HasSuffix(v, "}") && strings.Count(v, "${") == 1 {
				expr := v[2 : len(v)-1]
				// For ${now()} expressions, use existing value if available
				if expr == "now()" && existingSpec != nil {
					if existingVal, ok := existingSpec[key]; ok {
						result[key] = existingVal
						continue
					}
				}
				resolved, err := r.evaluateSimpleExpression(expr, resources)
				if err != nil {
					return nil, fmt.Errorf("failed to evaluate %s: %w", key, err)
				}
				result[key] = resolved
			} else if strings.Contains(v, "${") {
				// Handle embedded expressions like "prefix-${resources.x.status.y}-suffix"
				resolved, err := r.resolveEmbeddedExpressions(v, resources)
				if err != nil {
					return nil, fmt.Errorf("failed to evaluate embedded expression in %s: %w", key, err)
				}
				result[key] = resolved
			} else {
				result[key] = v
			}
		case map[string]interface{}:
			// Get nested existing spec if available
			var nestedExisting map[string]interface{}
			if existingSpec != nil {
				if nested, ok := existingSpec[key].(map[string]interface{}); ok {
					nestedExisting = nested
				}
			}
			resolved, err := r.resolveMap(v, resources, nestedExisting)
			if err != nil {
				return nil, err
			}
			result[key] = resolved
		case []interface{}:
			resolved, err := r.resolveSlice(v, resources)
			if err != nil {
				return nil, err
			}
			result[key] = resolved
		default:
			result[key] = v
		}
	}

	return result, nil
}

// resolveSlice recursively resolves CEL expressions in a slice
func (r *{{ .Kind }}Reconciler) resolveSlice(
	data []interface{},
	resources map[string]interface{},
) ([]interface{}, error) {
	result := make([]interface{}, len(data))

	for i, value := range data {
		switch v := value.(type) {
		case string:
			if strings.HasPrefix(v, "${") && strings.HasSuffix(v, "}") && strings.Count(v, "${") == 1 {
				expr := v[2 : len(v)-1]
				resolved, err := r.evaluateSimpleExpression(expr, resources)
				if err != nil {
					return nil, err
				}
				result[i] = resolved
			} else if strings.Contains(v, "${") {
				// Handle embedded expressions
				resolved, err := r.resolveEmbeddedExpressions(v, resources)
				if err != nil {
					return nil, err
				}
				result[i] = resolved
			} else {
				result[i] = v
			}
		case map[string]interface{}:
			// No existing spec for nested maps in slices
			resolved, err := r.resolveMap(v, resources, nil)
			if err != nil {
				return nil, err
			}
			result[i] = resolved
		case []interface{}:
			resolved, err := r.resolveSlice(v, resources)
			if err != nil {
				return nil, err
			}
			result[i] = resolved
		default:
			result[i] = v
		}
	}

	return result, nil
}

// evaluateSimpleExpression evaluates a simple path expression like "resources.pet.status.externalID"
// or a CEL function call like "now()" or "addDuration(now(), '24h')"
func (r *{{ .Kind }}Reconciler) evaluateSimpleExpression(expr string, resources map[string]interface{}) (interface{}, error) {
	// Handle resources.<id>.status.<field> pattern
	if strings.HasPrefix(expr, "resources.") {
		parts := strings.Split(expr[10:], ".")
		if len(parts) < 3 {
			return nil, fmt.Errorf("invalid expression: %s", expr)
		}

		resourceID := parts[0]
		resource, ok := resources[resourceID]
		if !ok {
			return nil, fmt.Errorf("resource not found: %s", resourceID)
		}

		// Navigate the path
		current := resource
		for _, part := range parts[1:] {
			m, ok := current.(map[string]interface{})
			if !ok {
				return nil, fmt.Errorf("cannot navigate path: %s", expr)
			}
			current = m[part]
		}

		// Convert numeric strings to actual numbers for proper JSON marshaling
		// This allows expressions like ${resources.parent.status.externalID} to work
		// with numeric fields like petId: int64
		if str, ok := current.(string); ok {
			// Try to parse as integer first
			if i, err := strconv.ParseInt(str, 10, 64); err == nil {
				return i, nil
			}
			// Try to parse as float
			if f, err := strconv.ParseFloat(str, 64); err == nil {
				return f, nil
			}
			// Not a number, return as string
		}

		return current, nil
	}

	// Handle CEL function calls (expressions containing parentheses)
	// Examples: now(), nowUnix(), addDuration(now(), "24h"), formatTime(nowUnix(), "2006-01-02")
	if strings.Contains(expr, "(") {
		// Create a CEL environment with datetime functions
		env, err := celutil.NewEnvironment([]string{})
		if err != nil {
			return nil, fmt.Errorf("failed to create CEL environment: %w", err)
		}

		// Provide empty variables (CEL functions like now() don't need variables)
		vars := map[string]interface{}{
			"resources": []map[string]interface{}{},
			"summary":   map[string]int64{"total": 0},
		}

		result := celutil.Evaluate(env, expr, vars)
		if result.Error != nil {
			return nil, fmt.Errorf("CEL evaluation failed: %w", result.Error)
		}

		return result.Value, nil
	}

	return nil, fmt.Errorf("unsupported expression: %s", expr)
}

// resolveEmbeddedExpressions handles strings with embedded expressions like "prefix-${resources.x.status.y}-suffix".
// It replaces all ${...} patterns within the string with their resolved values.
// The result is always a string since we're doing string interpolation.
func (r *{{ .Kind }}Reconciler) resolveEmbeddedExpressions(s string, resources map[string]interface{}) (string, error) {
	result := s
	for {
		start := strings.Index(result, "${")
		if start == -1 {
			break
		}
		end := strings.Index(result[start:], "}")
		if end == -1 {
			return "", fmt.Errorf("unclosed expression in: %s", s)
		}
		end += start // Adjust to absolute position

		expr := result[start+2 : end]
		resolved, err := r.evaluateSimpleExpression(expr, resources)
		if err != nil {
			return "", err
		}

		// Convert resolved value to string for interpolation
		var strValue string
		switch v := resolved.(type) {
		case string:
			strValue = v
		case int64:
			strValue = strconv.FormatInt(v, 10)
		case float64:
			strValue = strconv.FormatFloat(v, 'f', -1, 64)
		case bool:
			strValue = strconv.FormatBool(v)
		default:
			strValue = fmt.Sprintf("%v", v)
		}

		result = result[:start] + strValue + result[end+1:]
	}
	return result, nil
}

// calculateSummary computes resource counts from statuses using shared classification logic
func (r *{{ .Kind }}Reconciler) calculateSummary(statuses []{{ .APIVersion }}.BundleResourceStatus) {{ .APIVersion }}.BundleSummary {
	var counter celutil.SummaryCounter
	for _, s := range statuses {
		counter.Add(s.State)
	}

	return {{ .APIVersion }}.BundleSummary{
		Total:   int(counter.Total),
		Synced:  int(counter.Synced),
		Failed:  int(counter.Failed),
		Pending: int(counter.Pending),
		Skipped: int(counter.Skipped),
	}
}

// specsEqual compares two specs for equality, treating RFC3339 timestamps as equal
// regardless of their actual values. This prevents unnecessary updates when dynamic
// timestamps like ${now()} are used - once set, the timestamp is considered equal
// even if it differs from a freshly-resolved value.
//
// The comparison checks that all fields in the desired spec are present and equal
// in the existing spec. Extra fields in the existing spec (added by API server
// defaults like mergeOnUpdate, category, etc.) are ignored.
//
// Controller-specific fields (mergeOnUpdate, targetHelmRelease, etc.) are excluded
// from comparison since they may have defaults applied by the API server.
func (r *{{ .Kind }}Reconciler) specsEqual(existing, desired interface{}) bool {
	// Fast path: direct equality
	if reflect.DeepEqual(existing, desired) {
		return true
	}

	// Marshal both to JSON for deep comparison
	existingJSON, err1 := json.Marshal(existing)
	desiredJSON, err2 := json.Marshal(desired)
	if err1 != nil || err2 != nil {
		return false
	}

	// Unmarshal to maps for field-by-field comparison
	var existingMap, desiredMap map[string]interface{}
	if err := json.Unmarshal(existingJSON, &existingMap); err != nil {
		return false
	}
	if err := json.Unmarshal(desiredJSON, &desiredMap); err != nil {
		return false
	}

	// Remove controller-specific fields from desired spec
	// These fields are not part of the "business" spec and shouldn't cause updates
	controllerFields := []string{
		"mergeOnUpdate",     // Has default value true
		"targetHelmRelease", // Inherited from bundle
		"targetNamespace",   // Inherited from bundle
		"readOnly",          // Controller behavior flag
		"onDelete",          // Controller behavior flag
		"externalIDRef",     // Reference field, not part of API payload
	}
	for _, field := range controllerFields {
		delete(desiredMap, field)
	}

	// Check that all fields in desired are present and equal in existing
	// Extra fields in existing (from API defaults) are ignored
	return r.desiredSubsetOfExisting(existingMap, desiredMap)
}

// desiredSubsetOfExisting checks that all fields in desired are present and equal
// in existing. Extra fields in either map are ignored. This handles cases where:
// 1. The API server adds default values (like category: {}) that aren't in our spec
// 2. The bundle spec contains fields that aren't valid for the CRD (like 'name' for Order)
//    - these get dropped during json.Unmarshal into the typed struct
func (r *{{ .Kind }}Reconciler) desiredSubsetOfExisting(existing, desired map[string]interface{}) bool {
	for key, desiredVal := range desired {
		existingVal, exists := existing[key]
		if !exists {
			// Desired field not in existing - this could mean:
			// 1. The field was empty and omitted (ok to skip)
			// 2. The field is invalid for this CRD type and will be dropped (ok to skip)
			// Either way, if it's not in existing, we can't compare it
			// and updating won't help since the field will be dropped again
			continue
		}
		if !r.valuesEqualWithTimestampTolerance(existingVal, desiredVal) {
			return false
		}
	}
	return true
}

// isEmptyValue checks if a value is an empty slice, empty map, or nil
func (r *{{ .Kind }}Reconciler) isEmptyValue(v interface{}) bool {
	if v == nil {
		return true
	}
	switch val := v.(type) {
	case []interface{}:
		return len(val) == 0
	case map[string]interface{}:
		return len(val) == 0
	case string:
		return val == ""
	}
	return false
}

// valuesEqualWithTimestampTolerance compares values, treating timestamps specially.
// For maps, it checks that the desired (b) is a subset of existing (a).
func (r *{{ .Kind }}Reconciler) valuesEqualWithTimestampTolerance(existing, desired interface{}) bool {
	// Handle nil
	if existing == nil && desired == nil {
		return true
	}
	// If desired is nil/empty, it's always satisfied
	if r.isEmptyValue(desired) {
		return true
	}
	if existing == nil {
		return false
	}

	// Check string timestamps
	existingStr, existingIsStr := existing.(string)
	desiredStr, desiredIsStr := desired.(string)
	if existingIsStr && desiredIsStr {
		// Try parsing as RFC3339 timestamps
		existingTime, existingErr := time.Parse(time.RFC3339, existingStr)
		desiredTime, desiredErr := time.Parse(time.RFC3339, desiredStr)
		if existingErr == nil && desiredErr == nil {
			// Both are timestamps - treat as equal (the existing timestamp wins)
			// This prevents drift from dynamic values like ${now()}
			_ = existingTime
			_ = desiredTime
			return true
		}
		// Not timestamps, compare as strings
		return existingStr == desiredStr
	}

	// Handle maps - check desired is subset of existing
	existingMap, existingIsMap := existing.(map[string]interface{})
	desiredMap, desiredIsMap := desired.(map[string]interface{})
	if existingIsMap && desiredIsMap {
		return r.desiredSubsetOfExisting(existingMap, desiredMap)
	}

	// Handle slices
	existingSlice, existingIsSlice := existing.([]interface{})
	desiredSlice, desiredIsSlice := desired.([]interface{})
	if existingIsSlice && desiredIsSlice {
		if len(existingSlice) != len(desiredSlice) {
			return false
		}
		for i := range desiredSlice {
			if !r.valuesEqualWithTimestampTolerance(existingSlice[i], desiredSlice[i]) {
				return false
			}
		}
		return true
	}

	// Handle numeric comparisons (JSON unmarshaling may produce different types)
	existingFloat, existingIsNum := toFloat64(existing)
	desiredFloat, desiredIsNum := toFloat64(desired)
	if existingIsNum && desiredIsNum {
		return existingFloat == desiredFloat
	}

	// Default: direct comparison
	return reflect.DeepEqual(existing, desired)
}

// toFloat64 attempts to convert a value to float64 for numeric comparison.
func toFloat64(v interface{}) (float64, bool) {
	switch n := v.(type) {
	case float64:
		return n, true
	case float32:
		return float64(n), true
	case int:
		return float64(n), true
	case int32:
		return float64(n), true
	case int64:
		return float64(n), true
	case uint:
		return float64(n), true
	case uint32:
		return float64(n), true
	case uint64:
		return float64(n), true
	}
	return 0, false
}

// calculateAggregatedHealth computes Aggregate CRD-compatible health status from bundle resources.
// This provides consistent health reporting semantics between Bundle and Aggregate CRDs.
func (r *{{ .Kind }}Reconciler) calculateAggregatedHealth(bundle *{{ .APIVersion }}.{{ .Kind }}) *{{ .APIVersion }}.BundleAggregatedHealth {
	now := metav1.Now()

	// Convert BundleResourceStatus to AggregatedResourceStatus for consistency
	aggregatedResources := make([]{{ .APIVersion }}.AggregatedResourceStatus, 0, len(bundle.Status.Resources))
	for _, res := range bundle.Status.Resources {
		// Map Bundle states to Aggregate-compatible states
		state := res.State
		switch res.State {
		case "Queried", "Completed":
			state = "Synced" // Normalize to Aggregate CRD's Synced state
		case "Creating":
			state = "Pending"
		}

		aggregatedResources = append(aggregatedResources, {{ .APIVersion }}.AggregatedResourceStatus{
			Kind:         res.Kind,
			Name:         res.Name,
			Namespace:    bundle.Namespace,
			State:        state,
			ExternalID:   res.ExternalID,
			Message:      res.Message,
			LastSyncTime: res.LastSyncTime,
		})
	}

	// Calculate summary from the aggregated resources we just built
	// This ensures consistency rather than relying on bundle.Status.Summary which may be stale
	var aggSummary {{ .APIVersion }}.AggregateSummary
	for _, res := range aggregatedResources {
		aggSummary.Total++
		switch res.State {
		case "Synced":
			aggSummary.Synced++
		case "Failed":
			aggSummary.Failed++
		case "Pending":
			aggSummary.Pending++
		}
	}

	// Determine aggregated health state using the same strategy as Aggregate CRD
	strategy := bundle.Spec.AggregationStrategy
	if strategy == "" {
		strategy = "AllHealthy"
	}

	healthState := r.evaluateAggregationStrategy(strategy, aggSummary)

	return &{{ .APIVersion }}.BundleAggregatedHealth{
		State:               healthState,
		Summary:             aggSummary,
		Resources:           aggregatedResources,
		LastAggregationTime: &now,
		// ComputedValues will be populated separately if DerivedValues are specified
	}
}

// evaluateAggregationStrategy determines the health state using Aggregate CRD semantics
func (r *{{ .Kind }}Reconciler) evaluateAggregationStrategy(strategy string, summary {{ .APIVersion }}.AggregateSummary) string {
	if summary.Total == 0 {
		return "Unknown"
	}

	switch strategy {
	case "AllHealthy":
		// All resources must be synced
		if summary.Failed > 0 {
			return "Degraded"
		}
		if summary.Pending > 0 {
			return "Pending"
		}
		if summary.Synced == summary.Total {
			return "Healthy"
		}
		return "Pending"

	case "AnyHealthy":
		// At least one resource must be synced
		if summary.Synced > 0 {
			return "Healthy"
		}
		if summary.Failed == summary.Total {
			return "Degraded"
		}
		return "Pending"

	case "Quorum":
		// Majority of resources must be synced
		quorum := (summary.Total / 2) + 1
		if summary.Synced >= quorum {
			return "Healthy"
		}
		if summary.Failed > summary.Total-quorum {
			return "Degraded" // Can't reach quorum
		}
		return "Pending"

	default:
		return "Unknown"
	}
}

func (r *{{ .Kind }}Reconciler) updateBundleStatus(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}, state, message string) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Capture the current resource status snapshot (may have been updated by syncChildResources)
	resourcesSnapshot := make([]{{ .APIVersion }}.BundleResourceStatus, len(bundle.Status.Resources))
	copy(resourcesSnapshot, bundle.Status.Resources)
	// Also capture the summary that was calculated from the statuses
	summarySnapshot := bundle.Status.Summary

	// Use retry to handle conflicts from concurrent reconciliations (e.g., when child resources are also being watched)
	err := retry.RetryOnConflict(retry.DefaultRetry, func() error {
		// Refetch the latest version to get current resourceVersion
		latest := &{{ .APIVersion }}.{{ .Kind }}{}
		if err := r.Get(ctx, client.ObjectKeyFromObject(bundle), latest); err != nil {
			return err
		}

		now := metav1.Now()
		latest.Status.State = state
		latest.Status.Message = message
		latest.Status.ObservedGeneration = latest.Generation

		// Apply the captured resource statuses and summary
		latest.Status.Resources = resourcesSnapshot
		latest.Status.Summary = summarySnapshot

		// Update operation state
		if latest.Status.OperationState == nil {
			latest.Status.OperationState = &{{ .APIVersion }}.BundleOperationState{}
		}
		// Map bundle state to operation phase (Phase enum: Pending, Running, Succeeded, Failed)
		switch state {
		case "Synced":
			latest.Status.OperationState.Phase = "Succeeded"
		case "Failed":
			latest.Status.OperationState.Phase = "Failed"
		case "Pending", "Creating":
			latest.Status.OperationState.Phase = "Running"
		default:
			latest.Status.OperationState.Phase = "Pending"
		}
		latest.Status.OperationState.Message = message
		if state == "Synced" || state == "Failed" {
			latest.Status.OperationState.FinishedAt = &now
		}

		// Calculate and set Aggregate CRD-compatible health status
		latest.Status.AggregatedHealth = r.calculateAggregatedHealth(latest)

		// Evaluate derived values if configured
		if len(latest.Spec.DerivedValues) > 0 {
			latest.Status.AggregatedHealth.ComputedValues = r.evaluateDerivedValues(ctx, latest)
		}

		// Set conditions
		r.setConditions(ctx, latest, state, message)

		return r.Status().Update(ctx, latest)
	})

	if err != nil {
		logger.Error(err, "Failed to update status after retries")
		return ctrl.Result{}, err
	}

	// No periodic requeue needed - reconciliation is triggered by:
	// 1. Changes to the bundle CR itself (spec updates)
	// 2. Changes to child resources (via Owns() watches in SetupWithManager)
	return ctrl.Result{}, nil
}

// setConditions sets the status conditions based on bundle state
func (r *{{ .Kind }}Reconciler) setConditions(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}, state, message string) {
	now := metav1.Now()

	// Ready condition
	readyCondition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Synced" {
		readyCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, readyCondition)

	// Progressing condition
	progressingCondition := metav1.Condition{
		Type:               "Progressing",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Syncing" || state == "Pending" {
		progressingCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, progressingCondition)

	// HasFailures condition
	hasFailuresCondition := metav1.Condition{
		Type:               "HasFailures",
		Status:             metav1.ConditionFalse,
		Reason:             "NoFailures",
		Message:            "No resources have failed",
		LastTransitionTime: now,
	}
	if bundle.Status.Summary.Failed > 0 {
		hasFailuresCondition.Status = metav1.ConditionTrue
		hasFailuresCondition.Reason = "ResourcesFailed"
		hasFailuresCondition.Message = fmt.Sprintf("%d resources have failed", bundle.Status.Summary.Failed)
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, hasFailuresCondition)
}

// evaluateDerivedValues evaluates CEL expressions from spec.derivedValues.
// Uses the same CEL evaluation as Aggregate CRD for consistency.
func (r *{{ .Kind }}Reconciler) evaluateDerivedValues(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}) []{{ .APIVersion }}.ComputedValue {
	logger := log.FromContext(ctx)
	var results []{{ .APIVersion }}.ComputedValue

	// Build CEL data from bundle resources
	celResources, celDataByKind := r.buildCELData(ctx, bundle)

	// Create CEL environment using the shared utility
	kindNames := []string{
		{{- range .AllKinds }}
		"{{ . | pluralize }}",
		{{- end }}
	}
	// Collect resource-specific keys using {kind}-{name} convention
	resourceKeys := celutil.CollectResourceKeys(celResources)
	env, err := celutil.NewEnvironmentWithResources(kindNames, resourceKeys)
	if err != nil {
		logger.Error(err, "Failed to create CEL environment")
		for _, dv := range bundle.Spec.DerivedValues {
			results = append(results, {{ .APIVersion }}.ComputedValue{
				Name:  dv.Name,
				Error: fmt.Sprintf("failed to create CEL environment: %v", err),
			})
		}
		return results
	}

	// Build evaluation variables using the shared utility (includes skipped for Bundle and resource-specific variables)
	celSummary := celutil.BuildSummaryWithSkipped(
		int64(bundle.Status.Summary.Total),
		int64(bundle.Status.Summary.Synced),
		int64(bundle.Status.Summary.Failed),
		int64(bundle.Status.Summary.Pending),
		int64(bundle.Status.Summary.Skipped),
	)
	evalVars := celutil.BuildVariablesWithResources(celResources, celSummary, celDataByKind)

	// Evaluate each derived value expression
	for _, dv := range bundle.Spec.DerivedValues {
		result := {{ .APIVersion }}.ComputedValue{Name: dv.Name}

		// Use the shared evaluation function
		evalResult := celutil.Evaluate(env, dv.Expression, evalVars)
		if evalResult.Error != nil {
			result.Error = evalResult.Error.Error()
			results = append(results, result)
			continue
		}

		// Convert result to string using the shared utility
		result.Value = celutil.ValueToString(evalResult.RawValue)
		results = append(results, result)

		logger.V(1).Info("Evaluated CEL expression",
			"name", dv.Name,
			"expression", dv.Expression,
			"result", result.Value)
	}

	return results
}

// buildCELData builds CEL-compatible data structures from bundle resources
func (r *{{ .Kind }}Reconciler) buildCELData(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}) ([]map[string]interface{}, map[string][]map[string]interface{}) {
	celResources := make([]map[string]interface{}, 0)
	celDataByKind := make(map[string][]map[string]interface{})

	// Initialize kind-specific lists
	{{- range .AllKinds }}
	celDataByKind["{{ . | pluralize }}"] = make([]map[string]interface{}, 0)
	{{- end }}

	// Convert each bundle resource status to CEL data
	for _, resStatus := range bundle.Status.Resources {
		// Find the corresponding spec to get the full data
		var resSpec *{{ .APIVersion }}.BundleResourceSpec
		for i := range bundle.Spec.Resources {
			if bundle.Spec.Resources[i].ID == resStatus.ID {
				resSpec = &bundle.Spec.Resources[i]
				break
			}
		}

		celData := r.bundleResourceToCELData(resStatus, resSpec, bundle)
		celResources = append(celResources, celData)

		// Add to kind-specific list
		kindKey := aggregate.KindToVariableName(resStatus.Kind)
		if _, ok := celDataByKind[kindKey]; ok {
			celDataByKind[kindKey] = append(celDataByKind[kindKey], celData)
		}
	}

	return celResources, celDataByKind
}

// bundleResourceToCELData converts a bundle resource to a CEL-compatible map
func (r *{{ .Kind }}Reconciler) bundleResourceToCELData(
	resStatus {{ .APIVersion }}.BundleResourceStatus,
	resSpec *{{ .APIVersion }}.BundleResourceSpec,
	bundle *{{ .APIVersion }}.{{ .Kind }},
) map[string]interface{} {
	result := map[string]interface{}{
		"kind": resStatus.Kind,
		"metadata": map[string]interface{}{
			"name":      resStatus.Name,
			"namespace": bundle.Namespace,
		},
		"status": map[string]interface{}{
			"state":      resStatus.State,
			"externalID": resStatus.ExternalID,
			"message":    resStatus.Message,
			"ready":      resStatus.Ready,
			"skipped":    resStatus.Skipped,
		},
	}

	// Include spec data if available
	if resSpec != nil {
		// Parse the raw extension to get spec data
		var specData map[string]interface{}
		if resSpec.Spec.Raw != nil {
			if err := json.Unmarshal(resSpec.Spec.Raw, &specData); err == nil {
				result["spec"] = specData
			} else {
				result["spec"] = map[string]interface{}{}
			}
		} else {
			result["spec"] = map[string]interface{}{}
		}
	} else {
		result["spec"] = map[string]interface{}{}
	}

	return result
}

// SetupWithManager sets up the controller with the Manager
func (r *{{ .Kind }}Reconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&{{ .APIVersion }}.{{ .Kind }}{}).
		// Watch owned resources - they are created with ownerReferences
{{- range .ResourceKinds }}
		Owns(&{{ $.APIVersion }}.{{ . }}{}).
{{- end }}
{{- range .QueryKinds }}
		Owns(&{{ $.APIVersion }}.{{ . }}{}).
{{- end }}
{{- range .ActionKinds }}
		Owns(&{{ $.APIVersion }}.{{ . }}{}).
{{- end }}
		Complete(r)
}

