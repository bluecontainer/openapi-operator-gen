/*
Copyright {{ .Year }} Generated by openapi-operator-gen {{ .GeneratorVersion }}.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/common/types"
	"github.com/google/cel-go/common/types/ref"
	"github.com/google/cel-go/common/types/traits"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	k8stypes "k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	controllerutil2 "github.com/bluecontainer/openapi-operator-gen/pkg/controller"
	{{ .APIVersion }} "{{ .ModuleName }}/api/{{ .APIVersion }}"
)

var (
	{{ .KindLower }}Tracer = otel.Tracer("{{ .ModuleName }}/controller/{{ .KindLower }}")
	{{ .KindLower }}Meter  = otel.Meter("{{ .ModuleName }}/controller/{{ .KindLower }}")

	// Metrics
	{{ .KindLower }}ReconcileTotal    metric.Int64Counter
	{{ .KindLower }}ReconcileDuration metric.Float64Histogram
	{{ .KindLower }}ResourcesTotal    metric.Int64UpDownCounter
)

func init() {
	var err error

	{{ .KindLower }}ReconcileTotal, err = {{ .KindLower }}Meter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}ReconcileDuration, err = {{ .KindLower }}Meter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}ResourcesTotal, err = {{ .KindLower }}Meter.Int64UpDownCounter(
		"bundle_resources_total",
		metric.WithDescription("Total number of resources in the bundle"),
		metric.WithUnit("{resource}"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
	{{ .KindLower }}FinalizerName = "{{ .APIGroup }}/bundle-finalizer"
	{{ .KindLower }}RequeueAfter  = time.Second * 30
	{{ .KindLower }}RetryAfter    = time.Second * 5
)

// {{ .Kind }}Reconciler reconciles a {{ .Kind }} object
type {{ .Kind }}Reconciler struct {
	client.Client
	Scheme *k8sruntime.Scheme
}

// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }},verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/status,verbs=get;update;patch
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/finalizers,verbs=update
{{- range .AllKinds }}
// +kubebuilder:rbac:groups={{ $.APIGroup }},resources={{ . | lower }}s,verbs=get;list;watch;create;update;patch;delete
{{- end }}

// Reconcile is part of the main kubernetes reconciliation loop
func (r *{{ .Kind }}Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// Start tracing span
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "{{ .Kind }}"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	// Record metrics
	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	{{ .KindLower }}ReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	{{ .KindLower }}ReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

// reconcileInternal contains the actual reconciliation logic
func (r *{{ .Kind }}Reconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the {{ .Kind }} instance
	bundle := &{{ .APIVersion }}.{{ .Kind }}{}
	err := r.Get(ctx, req.NamespacedName, bundle)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("{{ .Kind }} resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get {{ .Kind }}")
		return ctrl.Result{}, err
	}

	// Handle deletion
	if !bundle.DeletionTimestamp.IsZero() {
		return r.handleDeletion(ctx, bundle)
	}

	// Add finalizer if not present
	if !controllerutil.ContainsFinalizer(bundle, {{ .KindLower }}FinalizerName) {
		controllerutil.AddFinalizer(bundle, {{ .KindLower }}FinalizerName)
		if err := r.Update(ctx, bundle); err != nil {
			return ctrl.Result{}, err
		}
		return ctrl.Result{Requeue: true}, nil
	}

	// Check if paused
	if bundle.Spec.Paused {
		return r.updateBundleStatus(ctx, bundle, "Paused", "Reconciliation paused")
	}

	// Build dependency graph and determine execution order
	order, err := r.buildExecutionOrder(bundle.Spec.Resources)
	if err != nil {
		return r.updateBundleStatus(ctx, bundle, "Failed", fmt.Sprintf("Invalid dependencies: %v", err))
	}

	// Process resources in dependency order
	return r.syncResources(ctx, bundle, order)
}

// buildExecutionOrder builds a DAG and returns topologically sorted resource IDs
// Dependencies are derived from:
// 1. Explicit dependsOn declarations
// 2. Implicit references in spec via ${resources.<id>...} patterns
func (r *{{ .Kind }}Reconciler) buildExecutionOrder(resources []{{ .APIVersion }}.BundleResourceSpec) ([]string, error) {
	// Build set of valid resource IDs for validation
	validIDs := make(map[string]bool)
	for _, res := range resources {
		validIDs[res.ID] = true
	}

	// Build adjacency list
	inDegree := make(map[string]int)
	dependents := make(map[string][]string) // Maps resource ID to IDs that depend on it

	// Initialize all resources
	for _, res := range resources {
		if _, exists := inDegree[res.ID]; !exists {
			inDegree[res.ID] = 0
		}
	}

	// Build dependency graph from explicit dependsOn and implicit references
	for _, res := range resources {
		// Collect all dependencies (explicit + implicit)
		allDeps := make(map[string]bool)

		// Add explicit dependencies
		for _, dep := range res.DependsOn {
			allDeps[dep] = true
		}

		// Extract implicit dependencies from spec CEL expressions
		if res.Spec.Raw != nil {
			implicitDeps := r.extractDependenciesFromSpec(res.Spec.Raw)
			for _, dep := range implicitDeps {
				allDeps[dep] = true
			}
		}

		// Also check readyWhen and skipWhen conditions for references
		for _, condition := range res.ReadyWhen {
			for _, dep := range r.extractDependenciesFromExpression(condition) {
				allDeps[dep] = true
			}
		}
		for _, condition := range res.SkipWhen {
			for _, dep := range r.extractDependenciesFromExpression(condition) {
				allDeps[dep] = true
			}
		}

		// Remove self-reference if any
		delete(allDeps, res.ID)

		// Validate and add dependencies
		for dep := range allDeps {
			if !validIDs[dep] {
				return nil, fmt.Errorf("resource %s depends on unknown resource %s", res.ID, dep)
			}
			inDegree[res.ID]++
			dependents[dep] = append(dependents[dep], res.ID)
		}
	}

	// Kahn's algorithm for topological sort
	var queue []string
	for id, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, id)
		}
	}

	var order []string
	for len(queue) > 0 {
		id := queue[0]
		queue = queue[1:]
		order = append(order, id)

		// Reduce in-degree of dependent resources
		for _, dependent := range dependents[id] {
			inDegree[dependent]--
			if inDegree[dependent] == 0 {
				queue = append(queue, dependent)
			}
		}
	}

	if len(order) != len(resources) {
		return nil, fmt.Errorf("circular dependency detected")
	}

	return order, nil
}

// syncResources creates/updates resources in dependency order
func (r *{{ .Kind }}Reconciler) syncResources(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}, order []string) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Build resource map for quick lookup
	resourceMap := make(map[string]{{ .APIVersion }}.BundleResourceSpec)
	for _, res := range bundle.Spec.Resources {
		resourceMap[res.ID] = res
	}

	// Build status map from existing resources
	statusMap := make(map[string]*{{ .APIVersion }}.BundleResourceStatus)
	for i := range bundle.Status.Resources {
		statusMap[bundle.Status.Resources[i].ID] = &bundle.Status.Resources[i]
	}

	// Process in order
	var statuses []{{ .APIVersion }}.BundleResourceStatus
	allSynced := true
	hasFailed := false
	needsRequeue := false

	for _, id := range order {
		res := resourceMap[id]

		// Check skipWhen conditions
		if len(res.SkipWhen) > 0 {
			skip, err := r.evaluateConditions(res.SkipWhen, statusMap, bundle)
			if err != nil {
				logger.Error(err, "Failed to evaluate skipWhen", "resource", id)
			}
			if skip {
				now := metav1.Now()
				statuses = append(statuses, {{ .APIVersion }}.BundleResourceStatus{
					ID:           id,
					Kind:         res.Kind,
					Name:         fmt.Sprintf("%s-%s", bundle.Name, id),
					State:        "Skipped",
					Skipped:      true,
					LastSyncTime: &now,
				})
				continue
			}
		}

		// Check if dependencies are ready
		depsReady := r.checkDependenciesReady(res.DependsOn, statusMap)
		if !depsReady {
			statuses = append(statuses, {{ .APIVersion }}.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    fmt.Sprintf("%s-%s", bundle.Name, id),
				State:   "Pending",
				Message: "Waiting for dependencies",
			})
			allSynced = false
			needsRequeue = true
			continue
		}

		// Resolve CEL expressions in spec
		resolvedSpec, err := r.resolveExpressions(res.Spec, statusMap, bundle)
		if err != nil {
			statuses = append(statuses, {{ .APIVersion }}.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    fmt.Sprintf("%s-%s", bundle.Name, id),
				State:   "Failed",
				Message: fmt.Sprintf("Expression error: %v", err),
			})
			hasFailed = true
			continue
		}

		// Create or update the child resource
		status, err := r.syncChildResource(ctx, bundle, id, res.Kind, resolvedSpec)
		if err != nil {
			statuses = append(statuses, {{ .APIVersion }}.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    fmt.Sprintf("%s-%s", bundle.Name, id),
				State:   "Failed",
				Message: err.Error(),
			})
			hasFailed = true
			continue
		}

		// Check readyWhen conditions if specified
		if len(res.ReadyWhen) > 0 && status.State == "Synced" {
			ready, err := r.evaluateConditions(res.ReadyWhen, statusMap, bundle)
			if err != nil {
				logger.Error(err, "Failed to evaluate readyWhen", "resource", id)
			}
			status.Ready = ready
		} else {
			status.Ready = status.State == "Synced"
		}

		statuses = append(statuses, *status)
		statusMap[id] = status // Update statusMap for dependent resources

		if status.State != "Synced" {
			allSynced = false
			needsRequeue = true
		}
	}

	// Update bundle status
	bundle.Status.Resources = statuses
	bundle.Status.Summary = r.calculateSummary(statuses)

	// Update resource metrics
	{{ .KindLower }}ResourcesTotal.Add(ctx, int64(bundle.Status.Summary.Total),
		metric.WithAttributes(
			attribute.String("bundle.name", bundle.Name),
			attribute.String("bundle.namespace", bundle.Namespace),
		))

	var state, message string
	if hasFailed {
		state = "Failed"
		message = fmt.Sprintf("%d resources failed", bundle.Status.Summary.Failed)
	} else if allSynced {
		state = "Synced"
		message = "All resources synced"
	} else {
		state = "Syncing"
		message = fmt.Sprintf("%d/%d resources synced", bundle.Status.Summary.Synced, bundle.Status.Summary.Total)
	}

	logger.Info("Bundle sync status",
		"state", state,
		"total", bundle.Status.Summary.Total,
		"synced", bundle.Status.Summary.Synced,
		"failed", bundle.Status.Summary.Failed)

	result, _ := r.updateBundleStatus(ctx, bundle, state, message)

	// Requeue if not all synced
	if needsRequeue {
		return ctrl.Result{RequeueAfter: {{ .KindLower }}RetryAfter}, nil
	}

	return result, nil
}

// syncChildResource creates or updates a single child resource
func (r *{{ .Kind }}Reconciler) syncChildResource(
	ctx context.Context,
	bundle *{{ .APIVersion }}.{{ .Kind }},
	id string,
	kind string,
	spec []byte,
) (*{{ .APIVersion }}.BundleResourceStatus, error) {
	// Generate child resource name
	childName := fmt.Sprintf("%s-%s", bundle.Name, id)

	// Create the appropriate typed resource based on kind
	switch kind {
{{- range .ResourceKinds }}
	case "{{ . }}":
		return r.sync{{ . }}(ctx, bundle, childName, id, spec)
{{- end }}
{{- range .QueryKinds }}
	case "{{ . }}":
		return r.sync{{ . }}(ctx, bundle, childName, id, spec)
{{- end }}
{{- range .ActionKinds }}
	case "{{ . }}":
		return r.sync{{ . }}(ctx, bundle, childName, id, spec)
{{- end }}
	default:
		return nil, fmt.Errorf("unknown kind: %s", kind)
	}
}

{{- range .ResourceKinds }}

// sync{{ . }} creates/updates a {{ . }} resource
func (r *{{ $.Kind }}Reconciler) sync{{ . }}(
	ctx context.Context,
	bundle *{{ $.APIVersion }}.{{ $.Kind }},
	name string,
	id string,
	specData []byte,
) (*{{ $.APIVersion }}.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child {{ $.APIVersion }}.{{ . }}
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for {{ . }}: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &{{ $.APIVersion }}.{{ . }}{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "{{ . }}", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &{{ $.APIVersion }}.BundleResourceStatus{
			ID:           id,
			Kind:         "{{ . }}",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "{{ . }}", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status
	return &{{ $.APIVersion }}.BundleResourceStatus{
		ID:           id,
		Kind:         "{{ . }}",
		Name:         name,
		State:        existing.Status.State,
		ExternalID:   controllerutil2.GetExternalIDIfPresent(existing),
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Synced",
		LastSyncTime: existing.Status.LastSyncTime,
	}, nil
}
{{- end }}

{{- range .QueryKinds }}

// sync{{ . }} creates/updates a {{ . }} resource
func (r *{{ $.Kind }}Reconciler) sync{{ . }}(
	ctx context.Context,
	bundle *{{ $.APIVersion }}.{{ $.Kind }},
	name string,
	id string,
	specData []byte,
) (*{{ $.APIVersion }}.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child {{ $.APIVersion }}.{{ . }}
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for {{ . }}: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &{{ $.APIVersion }}.{{ . }}{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "{{ . }}", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &{{ $.APIVersion }}.BundleResourceStatus{
			ID:           id,
			Kind:         "{{ . }}",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "{{ . }}", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Query CRDs use "Queried" as success state)
	return &{{ $.APIVersion }}.BundleResourceStatus{
		ID:           id,
		Kind:         "{{ . }}",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Queried",
		LastSyncTime: existing.Status.LastQueryTime,
	}, nil
}
{{- end }}

{{- range .ActionKinds }}

// sync{{ . }} creates/updates a {{ . }} resource
func (r *{{ $.Kind }}Reconciler) sync{{ . }}(
	ctx context.Context,
	bundle *{{ $.APIVersion }}.{{ $.Kind }},
	name string,
	id string,
	specData []byte,
) (*{{ $.APIVersion }}.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child {{ $.APIVersion }}.{{ . }}
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for {{ . }}: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &{{ $.APIVersion }}.{{ . }}{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "{{ . }}", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &{{ $.APIVersion }}.BundleResourceStatus{
			ID:           id,
			Kind:         "{{ . }}",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "{{ . }}", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Action CRDs use "Completed" as success state)
	return &{{ $.APIVersion }}.BundleResourceStatus{
		ID:           id,
		Kind:         "{{ . }}",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Completed",
		LastSyncTime: existing.Status.LastExecutionTime,
	}, nil
}
{{- end }}

// handleDeletion handles bundle deletion - child resources are cleaned up via ownerReferences
func (r *{{ .Kind }}Reconciler) handleDeletion(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	if !controllerutil.ContainsFinalizer(bundle, {{ .KindLower }}FinalizerName) {
		return ctrl.Result{}, nil
	}

	logger.Info("Handling bundle deletion")

	// Child resources are garbage collected via ownerReferences
	// Just remove the finalizer
	controllerutil.RemoveFinalizer(bundle, {{ .KindLower }}FinalizerName)
	if err := r.Update(ctx, bundle); err != nil {
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}

// checkDependenciesReady checks if all dependencies are in a ready state
func (r *{{ .Kind }}Reconciler) checkDependenciesReady(dependsOn []string, statusMap map[string]*{{ .APIVersion }}.BundleResourceStatus) bool {
	for _, dep := range dependsOn {
		status, exists := statusMap[dep]
		if !exists {
			return false
		}
		if !status.Ready && !status.Skipped {
			return false
		}
	}
	return true
}

// evaluateConditions evaluates CEL conditions against current resource status
func (r *{{ .Kind }}Reconciler) evaluateConditions(conditions []string, statusMap map[string]*{{ .APIVersion }}.BundleResourceStatus, bundle *{{ .APIVersion }}.{{ .Kind }}) (bool, error) {
	// Build variables for CEL evaluation
	resourcesVar := make(map[string]interface{})
	for id, status := range statusMap {
		resourcesVar[id] = map[string]interface{}{
			"status": map[string]interface{}{
				"state":      status.State,
				"externalID": status.ExternalID,
				"message":    status.Message,
				"ready":      status.Ready,
				"skipped":    status.Skipped,
			},
		}
	}

	// For now, evaluate conditions as simple string matches
	// TODO: Implement full CEL evaluation
	for _, condition := range conditions {
		// Simple evaluation: check if condition contains "true"
		if strings.Contains(condition, "true") {
			return true, nil
		}
	}

	return false, nil
}

// resolveExpressions replaces CEL expressions in spec with resolved values
func (r *{{ .Kind }}Reconciler) resolveExpressions(
	spec k8sruntime.RawExtension,
	statusMap map[string]*{{ .APIVersion }}.BundleResourceStatus,
	bundle *{{ .APIVersion }}.{{ .Kind }},
) ([]byte, error) {
	if spec.Raw == nil {
		return []byte("{}"), nil
	}

	// Parse spec as JSON
	var data map[string]interface{}
	if err := json.Unmarshal(spec.Raw, &data); err != nil {
		return nil, err
	}

	// Build resources map for expression resolution
	resourcesVar := make(map[string]interface{})
	for id, status := range statusMap {
		resourcesVar[id] = map[string]interface{}{
			"status": map[string]interface{}{
				"state":      status.State,
				"externalID": status.ExternalID,
				"message":    status.Message,
				"ready":      status.Ready,
			},
		}
	}

	// Recursively resolve expressions
	resolved, err := r.resolveMap(data, resourcesVar)
	if err != nil {
		return nil, err
	}

	return json.Marshal(resolved)
}

// resolveMap recursively resolves CEL expressions in a map
func (r *{{ .Kind }}Reconciler) resolveMap(
	data map[string]interface{},
	resources map[string]interface{},
) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	for key, value := range data {
		switch v := value.(type) {
		case string:
			// Check if it's a CEL expression: ${...}
			if strings.HasPrefix(v, "${") && strings.HasSuffix(v, "}") {
				expr := v[2 : len(v)-1]
				resolved, err := r.evaluateSimpleExpression(expr, resources)
				if err != nil {
					return nil, fmt.Errorf("failed to evaluate %s: %w", key, err)
				}
				result[key] = resolved
			} else {
				result[key] = v
			}
		case map[string]interface{}:
			resolved, err := r.resolveMap(v, resources)
			if err != nil {
				return nil, err
			}
			result[key] = resolved
		case []interface{}:
			resolved, err := r.resolveSlice(v, resources)
			if err != nil {
				return nil, err
			}
			result[key] = resolved
		default:
			result[key] = v
		}
	}

	return result, nil
}

// resolveSlice recursively resolves CEL expressions in a slice
func (r *{{ .Kind }}Reconciler) resolveSlice(
	data []interface{},
	resources map[string]interface{},
) ([]interface{}, error) {
	result := make([]interface{}, len(data))

	for i, value := range data {
		switch v := value.(type) {
		case string:
			if strings.HasPrefix(v, "${") && strings.HasSuffix(v, "}") {
				expr := v[2 : len(v)-1]
				resolved, err := r.evaluateSimpleExpression(expr, resources)
				if err != nil {
					return nil, err
				}
				result[i] = resolved
			} else {
				result[i] = v
			}
		case map[string]interface{}:
			resolved, err := r.resolveMap(v, resources)
			if err != nil {
				return nil, err
			}
			result[i] = resolved
		case []interface{}:
			resolved, err := r.resolveSlice(v, resources)
			if err != nil {
				return nil, err
			}
			result[i] = resolved
		default:
			result[i] = v
		}
	}

	return result, nil
}

// evaluateSimpleExpression evaluates a simple path expression like "resources.pet.status.externalID"
func (r *{{ .Kind }}Reconciler) evaluateSimpleExpression(expr string, resources map[string]interface{}) (interface{}, error) {
	// Handle resources.<id>.status.<field> pattern
	if strings.HasPrefix(expr, "resources.") {
		parts := strings.Split(expr[10:], ".")
		if len(parts) < 3 {
			return nil, fmt.Errorf("invalid expression: %s", expr)
		}

		resourceID := parts[0]
		resource, ok := resources[resourceID]
		if !ok {
			return nil, fmt.Errorf("resource not found: %s", resourceID)
		}

		// Navigate the path
		current := resource
		for _, part := range parts[1:] {
			m, ok := current.(map[string]interface{})
			if !ok {
				return nil, fmt.Errorf("cannot navigate path: %s", expr)
			}
			current = m[part]
		}

		return current, nil
	}

	return nil, fmt.Errorf("unsupported expression: %s", expr)
}

// extractDependenciesFromSpec extracts resource IDs referenced in ${resources.<id>...} patterns from spec JSON
func (r *{{ .Kind }}Reconciler) extractDependenciesFromSpec(specData []byte) []string {
	deps := make(map[string]bool)

	// Convert to string and find all ${resources.<id>...} patterns
	specStr := string(specData)
	r.findResourceReferences(specStr, deps)

	// Convert map to slice
	result := make([]string, 0, len(deps))
	for dep := range deps {
		result = append(result, dep)
	}
	return result
}

// extractDependenciesFromExpression extracts resource IDs from a CEL expression string
// Looks for patterns like: resources.<id>.status.field or resources.<id>.spec.field
func (r *{{ .Kind }}Reconciler) extractDependenciesFromExpression(expr string) []string {
	deps := make(map[string]bool)
	r.findResourceReferences(expr, deps)

	result := make([]string, 0, len(deps))
	for dep := range deps {
		result = append(result, dep)
	}
	return result
}

// findResourceReferences finds all resource ID references in a string
// Supports both ${resources.<id>...} (in specs) and resources.<id>... (in CEL expressions)
func (r *{{ .Kind }}Reconciler) findResourceReferences(s string, deps map[string]bool) {
	// Pattern 1: ${resources.<id>.anything}
	// Find all occurrences of ${resources.
	idx := 0
	for {
		start := strings.Index(s[idx:], "${resources.")
		if start == -1 {
			break
		}
		start += idx + len("${resources.")

		// Find the end of the resource ID (next . or })
		end := start
		for end < len(s) && s[end] != '.' && s[end] != '}' {
			end++
		}

		if end > start {
			resourceID := s[start:end]
			if isValidResourceID(resourceID) {
				deps[resourceID] = true
			}
		}
		idx = end
	}

	// Pattern 2: resources.<id>.anything (CEL expression without ${})
	// This handles cases like: resources.pet.status.state == 'Synced'
	idx = 0
	for {
		start := strings.Index(s[idx:], "resources.")
		if start == -1 {
			break
		}

		// Skip if this is part of ${resources. (already handled above)
		if start > 0 && s[idx+start-1] == '{' {
			idx += start + len("resources.")
			continue
		}

		start += idx + len("resources.")

		// Find the end of the resource ID (next . or non-identifier char)
		end := start
		for end < len(s) && (isIdentChar(s[end])) {
			end++
		}

		if end > start {
			resourceID := s[start:end]
			if isValidResourceID(resourceID) {
				deps[resourceID] = true
			}
		}
		idx = end
	}
}

// isIdentChar returns true if c is a valid identifier character (a-z, 0-9, -)
func isIdentChar(c byte) bool {
	return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '-'
}

// isValidResourceID checks if a string looks like a valid resource ID
func isValidResourceID(s string) bool {
	if len(s) == 0 {
		return false
	}
	// Must start with lowercase letter
	if s[0] < 'a' || s[0] > 'z' {
		return false
	}
	// Must only contain lowercase letters, numbers, and hyphens
	for i := 1; i < len(s); i++ {
		if !isIdentChar(s[i]) {
			return false
		}
	}
	return true
}

// calculateSummary computes resource counts from statuses
func (r *{{ .Kind }}Reconciler) calculateSummary(statuses []{{ .APIVersion }}.BundleResourceStatus) {{ .APIVersion }}.BundleSummary {
	var summary {{ .APIVersion }}.BundleSummary
	summary.Total = len(statuses)

	for _, s := range statuses {
		switch s.State {
		case "Synced", "Queried", "Completed":
			summary.Synced++
		case "Failed":
			summary.Failed++
		case "Skipped":
			summary.Skipped++
		default:
			summary.Pending++
		}
	}

	return summary
}

// calculateAggregatedHealth computes Aggregate CRD-compatible health status from bundle resources.
// This provides consistent health reporting semantics between Bundle and Aggregate CRDs.
func (r *{{ .Kind }}Reconciler) calculateAggregatedHealth(bundle *{{ .APIVersion }}.{{ .Kind }}) *{{ .APIVersion }}.BundleAggregatedHealth {
	now := metav1.Now()

	// Convert BundleResourceStatus to AggregatedResourceStatus for consistency
	aggregatedResources := make([]{{ .APIVersion }}.AggregatedResourceStatus, 0, len(bundle.Status.Resources))
	for _, res := range bundle.Status.Resources {
		// Map Bundle states to Aggregate-compatible states
		state := res.State
		switch res.State {
		case "Queried", "Completed":
			state = "Synced" // Normalize to Aggregate CRD's Synced state
		case "Creating":
			state = "Pending"
		}

		aggregatedResources = append(aggregatedResources, {{ .APIVersion }}.AggregatedResourceStatus{
			Kind:         res.Kind,
			Name:         res.Name,
			Namespace:    bundle.Namespace,
			State:        state,
			ExternalID:   res.ExternalID,
			Message:      res.Message,
			LastSyncTime: res.LastSyncTime,
		})
	}

	// Convert BundleSummary to AggregateSummary
	aggSummary := bundle.Status.Summary.ToAggregateSummary()

	// Determine aggregated health state using the same strategy as Aggregate CRD
	strategy := bundle.Spec.AggregationStrategy
	if strategy == "" {
		strategy = "AllHealthy"
	}

	healthState := r.evaluateAggregationStrategy(strategy, aggSummary)

	return &{{ .APIVersion }}.BundleAggregatedHealth{
		State:               healthState,
		Summary:             aggSummary,
		Resources:           aggregatedResources,
		LastAggregationTime: &now,
		// ComputedValues will be populated separately if DerivedValues are specified
	}
}

// evaluateAggregationStrategy determines the health state using Aggregate CRD semantics
func (r *{{ .Kind }}Reconciler) evaluateAggregationStrategy(strategy string, summary {{ .APIVersion }}.AggregateSummary) string {
	if summary.Total == 0 {
		return "Unknown"
	}

	switch strategy {
	case "AllHealthy":
		// All resources must be synced
		if summary.Failed > 0 {
			return "Degraded"
		}
		if summary.Pending > 0 {
			return "Pending"
		}
		if summary.Synced == summary.Total {
			return "Healthy"
		}
		return "Pending"

	case "AnyHealthy":
		// At least one resource must be synced
		if summary.Synced > 0 {
			return "Healthy"
		}
		if summary.Failed == summary.Total {
			return "Degraded"
		}
		return "Pending"

	case "Quorum":
		// Majority of resources must be synced
		quorum := (summary.Total / 2) + 1
		if summary.Synced >= quorum {
			return "Healthy"
		}
		if summary.Failed > summary.Total-quorum {
			return "Degraded" // Can't reach quorum
		}
		return "Pending"

	default:
		return "Unknown"
	}
}

func (r *{{ .Kind }}Reconciler) updateBundleStatus(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}, state, message string) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	bundle.Status.State = state
	bundle.Status.Message = message
	bundle.Status.ObservedGeneration = bundle.Generation

	// Update operation state
	if bundle.Status.OperationState == nil {
		bundle.Status.OperationState = &{{ .APIVersion }}.BundleOperationState{}
	}
	bundle.Status.OperationState.Phase = state
	bundle.Status.OperationState.Message = message
	if state == "Synced" || state == "Failed" {
		bundle.Status.OperationState.FinishedAt = &now
	}

	// Calculate and set Aggregate CRD-compatible health status
	bundle.Status.AggregatedHealth = r.calculateAggregatedHealth(bundle)

	// Evaluate derived values if configured
	if len(bundle.Spec.DerivedValues) > 0 {
		bundle.Status.AggregatedHealth.ComputedValues = r.evaluateDerivedValues(ctx, bundle)
	}

	// Set conditions
	r.setConditions(ctx, bundle, state, message)

	if err := r.Status().Update(ctx, bundle); err != nil {
		logger.Error(err, "Failed to update status")
		return ctrl.Result{}, err
	}

	return ctrl.Result{RequeueAfter: {{ .KindLower }}RequeueAfter}, nil
}

// setConditions sets the status conditions based on bundle state
func (r *{{ .Kind }}Reconciler) setConditions(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}, state, message string) {
	now := metav1.Now()

	// Ready condition
	readyCondition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Synced" {
		readyCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, readyCondition)

	// Progressing condition
	progressingCondition := metav1.Condition{
		Type:               "Progressing",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Syncing" || state == "Pending" {
		progressingCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, progressingCondition)

	// HasFailures condition
	hasFailuresCondition := metav1.Condition{
		Type:               "HasFailures",
		Status:             metav1.ConditionFalse,
		Reason:             "NoFailures",
		Message:            "No resources have failed",
		LastTransitionTime: now,
	}
	if bundle.Status.Summary.Failed > 0 {
		hasFailuresCondition.Status = metav1.ConditionTrue
		hasFailuresCondition.Reason = "ResourcesFailed"
		hasFailuresCondition.Message = fmt.Sprintf("%d resources have failed", bundle.Status.Summary.Failed)
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, hasFailuresCondition)
}

// evaluateDerivedValues evaluates CEL expressions from spec.derivedValues.
// Uses the same CEL evaluation as Aggregate CRD for consistency.
func (r *{{ .Kind }}Reconciler) evaluateDerivedValues(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}) []{{ .APIVersion }}.ComputedValue {
	logger := log.FromContext(ctx)
	var results []{{ .APIVersion }}.ComputedValue

	// Build CEL data from bundle resources
	celResources, celDataByKind := r.buildCELData(ctx, bundle)

	// Create CEL environment with custom types and aggregate functions
	envOpts := []cel.EnvOption{
		cel.Variable("resources", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("summary", cel.MapType(cel.StringType, cel.IntType)),
		// Kind-specific variables for all kinds (CRUD, Query, Action)
		{{- range .AllKinds }}
		cel.Variable("{{ . | lower }}s", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		{{- end }}
		// Custom aggregate functions for numeric lists
		cel.Function("sum",
			cel.Overload("sum_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(bundleCelSumList),
			),
		),
		cel.Function("max",
			cel.Overload("max_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(bundleCelMaxList),
			),
		),
		cel.Function("min",
			cel.Overload("min_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(bundleCelMinList),
			),
		),
		cel.Function("avg",
			cel.Overload("avg_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(bundleCelAvgList),
			),
		),
	}

	env, err := cel.NewEnv(envOpts...)
	if err != nil {
		logger.Error(err, "Failed to create CEL environment")
		for _, dv := range bundle.Spec.DerivedValues {
			results = append(results, {{ .APIVersion }}.ComputedValue{
				Name:  dv.Name,
				Error: fmt.Sprintf("failed to create CEL environment: %v", err),
			})
		}
		return results
	}

	// Convert summary to CEL-compatible format (includes skipped for Bundle)
	celSummary := map[string]int64{
		"total":   int64(bundle.Status.Summary.Total),
		"synced":  int64(bundle.Status.Summary.Synced),
		"failed":  int64(bundle.Status.Summary.Failed),
		"pending": int64(bundle.Status.Summary.Pending),
		"skipped": int64(bundle.Status.Summary.Skipped),
	}

	// Build evaluation variables map with all resources and kind-specific lists
	evalVars := map[string]interface{}{
		"resources": celResources,
		"summary":   celSummary,
	}
	// Add kind-specific lists
	for kindKey, kindData := range celDataByKind {
		evalVars[kindKey] = kindData
	}

	// Evaluate each derived value expression
	for _, dv := range bundle.Spec.DerivedValues {
		result := {{ .APIVersion }}.ComputedValue{Name: dv.Name}

		// Parse and check the expression
		ast, issues := env.Compile(dv.Expression)
		if issues != nil && issues.Err() != nil {
			result.Error = fmt.Sprintf("compile error: %v", issues.Err())
			results = append(results, result)
			continue
		}

		// Create program
		prg, err := env.Program(ast)
		if err != nil {
			result.Error = fmt.Sprintf("program error: %v", err)
			results = append(results, result)
			continue
		}

		// Evaluate the expression
		out, _, err := prg.Eval(evalVars)
		if err != nil {
			result.Error = fmt.Sprintf("eval error: %v", err)
			results = append(results, result)
			continue
		}

		// Convert result to string
		result.Value = bundleCelValueToString(out)
		results = append(results, result)

		logger.V(1).Info("Evaluated CEL expression",
			"name", dv.Name,
			"expression", dv.Expression,
			"result", result.Value)
	}

	return results
}

// buildCELData builds CEL-compatible data structures from bundle resources
func (r *{{ .Kind }}Reconciler) buildCELData(ctx context.Context, bundle *{{ .APIVersion }}.{{ .Kind }}) ([]map[string]interface{}, map[string][]map[string]interface{}) {
	celResources := make([]map[string]interface{}, 0)
	celDataByKind := make(map[string][]map[string]interface{})

	// Initialize kind-specific lists
	{{- range .AllKinds }}
	celDataByKind["{{ . | lower }}s"] = make([]map[string]interface{}, 0)
	{{- end }}

	// Convert each bundle resource status to CEL data
	for _, resStatus := range bundle.Status.Resources {
		// Find the corresponding spec to get the full data
		var resSpec *{{ .APIVersion }}.BundleResourceSpec
		for i := range bundle.Spec.Resources {
			if bundle.Spec.Resources[i].ID == resStatus.ID {
				resSpec = &bundle.Spec.Resources[i]
				break
			}
		}

		celData := r.bundleResourceToCELData(resStatus, resSpec, bundle)
		celResources = append(celResources, celData)

		// Add to kind-specific list
		kindKey := strings.ToLower(resStatus.Kind) + "s"
		if _, ok := celDataByKind[kindKey]; ok {
			celDataByKind[kindKey] = append(celDataByKind[kindKey], celData)
		}
	}

	return celResources, celDataByKind
}

// bundleResourceToCELData converts a bundle resource to a CEL-compatible map
func (r *{{ .Kind }}Reconciler) bundleResourceToCELData(
	resStatus {{ .APIVersion }}.BundleResourceStatus,
	resSpec *{{ .APIVersion }}.BundleResourceSpec,
	bundle *{{ .APIVersion }}.{{ .Kind }},
) map[string]interface{} {
	result := map[string]interface{}{
		"kind": resStatus.Kind,
		"metadata": map[string]interface{}{
			"name":      resStatus.Name,
			"namespace": bundle.Namespace,
		},
		"status": map[string]interface{}{
			"state":      resStatus.State,
			"externalID": resStatus.ExternalID,
			"message":    resStatus.Message,
			"ready":      resStatus.Ready,
			"skipped":    resStatus.Skipped,
		},
	}

	// Include spec data if available
	if resSpec != nil {
		// Parse the raw extension to get spec data
		var specData map[string]interface{}
		if resSpec.Spec.Raw != nil {
			if err := json.Unmarshal(resSpec.Spec.Raw, &specData); err == nil {
				result["spec"] = specData
			} else {
				result["spec"] = map[string]interface{}{}
			}
		} else {
			result["spec"] = map[string]interface{}{}
		}
	} else {
		result["spec"] = map[string]interface{}{}
	}

	return result
}

// SetupWithManager sets up the controller with the Manager
func (r *{{ .Kind }}Reconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&{{ .APIVersion }}.{{ .Kind }}{}).
		// Watch owned resources - they are created with ownerReferences
{{- range .ResourceKinds }}
		Owns(&{{ $.APIVersion }}.{{ . }}{}).
{{- end }}
{{- range .QueryKinds }}
		Owns(&{{ $.APIVersion }}.{{ . }}{}).
{{- end }}
{{- range .ActionKinds }}
		Owns(&{{ $.APIVersion }}.{{ . }}{}).
{{- end }}
		Complete(r)
}

// CEL helper functions for Bundle derived value evaluation
// These match the functions in Aggregate controller for consistency

// bundleCelValueToString converts a CEL value to a string representation
func bundleCelValueToString(val ref.Val) string {
	switch v := val.(type) {
	case types.Int:
		return fmt.Sprintf("%d", int64(v))
	case types.Double:
		return fmt.Sprintf("%g", float64(v))
	case types.Bool:
		return fmt.Sprintf("%t", bool(v))
	case types.String:
		return string(v)
	default:
		// For complex types, use reflection or native value
		native := val.Value()
		if native == nil {
			return "null"
		}
		rv := reflect.ValueOf(native)
		switch rv.Kind() {
		case reflect.Slice, reflect.Array:
			return fmt.Sprintf("[%d items]", rv.Len())
		case reflect.Map:
			return fmt.Sprintf("{%d entries}", rv.Len())
		default:
			return fmt.Sprintf("%v", native)
		}
	}
}

// bundleCelToFloat64 converts a CEL value to float64
func bundleCelToFloat64(val interface{}) (float64, bool) {
	switch v := val.(type) {
	case float64:
		return v, true
	case float32:
		return float64(v), true
	case int:
		return float64(v), true
	case int32:
		return float64(v), true
	case int64:
		return float64(v), true
	case uint:
		return float64(v), true
	case uint32:
		return float64(v), true
	case uint64:
		return float64(v), true
	case json.Number:
		if f, err := v.Float64(); err == nil {
			return f, true
		}
	}
	return 0, false
}

// bundleCelSumList implements sum() for a list of numbers
func bundleCelSumList(val ref.Val) ref.Val {
	list, ok := val.(ref.Val)
	if !ok {
		return types.NewErr("sum() requires a list argument")
	}

	iter, ok := list.(traits.Lister)
	if !ok {
		return types.NewErr("sum() requires a list argument")
	}

	var sum float64
	it := iter.Iterator()
	for it.HasNext() == types.True {
		elem := it.Next()
		if num, ok := bundleCelToFloat64(elem.Value()); ok {
			sum += num
		}
	}
	return types.Double(sum)
}

// bundleCelMaxList implements max() for a list of numbers
func bundleCelMaxList(val ref.Val) ref.Val {
	list, ok := val.(ref.Val)
	if !ok {
		return types.NewErr("max() requires a list argument")
	}

	iter, ok := list.(traits.Lister)
	if !ok {
		return types.NewErr("max() requires a list argument")
	}

	var max float64
	first := true
	it := iter.Iterator()
	for it.HasNext() == types.True {
		elem := it.Next()
		if num, ok := bundleCelToFloat64(elem.Value()); ok {
			if first || num > max {
				max = num
				first = false
			}
		}
	}
	if first {
		return types.Double(0) // Empty list returns 0
	}
	return types.Double(max)
}

// bundleCelMinList implements min() for a list of numbers
func bundleCelMinList(val ref.Val) ref.Val {
	list, ok := val.(ref.Val)
	if !ok {
		return types.NewErr("min() requires a list argument")
	}

	iter, ok := list.(traits.Lister)
	if !ok {
		return types.NewErr("min() requires a list argument")
	}

	var min float64
	first := true
	it := iter.Iterator()
	for it.HasNext() == types.True {
		elem := it.Next()
		if num, ok := bundleCelToFloat64(elem.Value()); ok {
			if first || num < min {
				min = num
				first = false
			}
		}
	}
	if first {
		return types.Double(0) // Empty list returns 0
	}
	return types.Double(min)
}

// bundleCelAvgList implements avg() for a list of numbers
func bundleCelAvgList(val ref.Val) ref.Val {
	list, ok := val.(ref.Val)
	if !ok {
		return types.NewErr("avg() requires a list argument")
	}

	iter, ok := list.(traits.Lister)
	if !ok {
		return types.NewErr("avg() requires a list argument")
	}

	var sum float64
	var count int
	it := iter.Iterator()
	for it.HasNext() == types.True {
		elem := it.Next()
		if num, ok := bundleCelToFloat64(elem.Value()); ok {
			sum += num
			count++
		}
	}
	if count == 0 {
		return types.Double(0) // Empty list returns 0
	}
	return types.Double(sum / float64(count))
}
