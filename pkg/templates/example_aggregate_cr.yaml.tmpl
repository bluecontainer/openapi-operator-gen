# Generated by openapi-operator-gen {{ .GeneratorVersion }}
# Example {{ .Kind }} CR - aggregates status from multiple resources
#
# Two selection methods are available:
# 1. resources: Explicit references to specific resources by name (Option 1)
# 2. resourceSelectors: Dynamic selection using labels/patterns (Option 4)
# You can use either or both methods together.

---
# Example with explicit resource references (Option 1: Reference-Based)
# Use this when you want to aggregate specific, known resources
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: specific-resources
  namespace: default
spec:
  # Explicitly reference resources by name
  resources:
{{- range $i, $kind := .ResourceKinds }}
{{- if lt $i 2 }}
    - kind: {{ $kind }}
      name: my-{{ $kind | lower }}
      # namespace: other-ns  # Optional: defaults to aggregate's namespace
{{- end }}
{{- end }}
  aggregationStrategy: AllHealthy
---
# Example with dynamic selectors (Option 4: Selector-Based)
# Use this when you want to aggregate all resources matching criteria
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: all-resources
  namespace: default
spec:
  # Select which resources to aggregate by kind
  resourceSelectors:
{{- range .ResourceKinds }}
    - kind: {{ . }}
{{- end }}
  # Strategy for determining overall health
  # Options: AllHealthy (default), AnyHealthy, Quorum
  aggregationStrategy: AllHealthy
---
# Example combining both methods (explicit + dynamic)
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: mixed-selection
  namespace: default
spec:
  # Explicitly include critical resources
  resources:
{{- range $i, $kind := .ResourceKinds }}
{{- if eq $i 0 }}
    - kind: {{ $kind }}
      name: critical-{{ $kind | lower }}
{{- end }}
{{- end }}
  # Also include all resources matching labels
  resourceSelectors:
{{- range $i, $kind := .ResourceKinds }}
{{- if eq $i 0 }}
    - kind: {{ $kind }}
      matchLabels:
        tier: backend
{{- end }}
{{- end }}
  aggregationStrategy: AllHealthy
---
# Example with label selector
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: production-resources
  namespace: default
spec:
  resourceSelectors:
{{- range $i, $kind := .ResourceKinds }}
{{- if eq $i 0 }}
    - kind: {{ $kind }}
      matchLabels:
        environment: production
{{- end }}
{{- end }}
  aggregationStrategy: AllHealthy
---
# Example with name pattern (regex)
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: filtered-by-name
  namespace: default
spec:
  resourceSelectors:
{{- range $i, $kind := .ResourceKinds }}
{{- if eq $i 0 }}
    - kind: {{ $kind }}
      namePattern: "^test-.*"
{{- end }}
{{- end }}
  aggregationStrategy: AnyHealthy
---
# Example with Quorum strategy - healthy if majority are synced
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: quorum-check
  namespace: default
spec:
  resourceSelectors:
{{- range .ResourceKinds }}
    - kind: {{ . }}
{{- end }}
  aggregationStrategy: Quorum
---
# Example with CEL expressions for derived values
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: with-derived-values
  namespace: default
spec:
  resourceSelectors:
{{- range .ResourceKinds }}
    - kind: {{ . }}
{{- end }}
  aggregationStrategy: AllHealthy
  # Derived values using CEL expressions
  # Available variables:
  #   - resources: list of resource objects, each with:
  #       - kind: resource kind (e.g., "Order", "Pet")
  #       - metadata: { name, namespace, labels, annotations }
  #       - spec: the full spec fields as a map
  #       - status: the full status fields as a map
  #   - summary: object with total, synced, failed, pending counts
  # Available aggregate functions:
  #   - sum(list): sum of numeric values
  #   - max(list): maximum value
  #   - min(list): minimum value
  #   - avg(list): average value
  derivedValues:
    # Calculate percentage of synced resources
    - name: syncPercentage
      expression: "summary.total > 0 ? (summary.synced * 100) / summary.total : 0"
    # Check if all resources are synced
    - name: allSynced
      expression: "summary.total > 0 && summary.synced == summary.total"
    # Count resources in failed state using status field
    - name: failedResources
      expression: "resources.filter(r, r.status.state == 'Failed').size()"
    # Filter resources by kind
    - name: orderCount
      expression: "resources.filter(r, r.kind == 'Order').size()"
---
# Example with aggregate functions (sum, max, min, avg)
# Uses kind-specific variables: orders, pets, users (lowercase plural)
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: with-aggregate-functions
  namespace: default
spec:
  resourceSelectors:
    - kind: Order
    - kind: Pet
  aggregationStrategy: AllHealthy
  derivedValues:
    # Sum of all order quantities using kind-specific variable
    - name: totalOrderQuantity
      expression: "sum(orders.map(r, has(r.spec.quantity) ? r.spec.quantity : 0))"
    # Maximum quantity across all orders
    - name: maxOrderQuantity
      expression: "max(orders.map(r, has(r.spec.quantity) ? r.spec.quantity : 0))"
    # Average quantity across all orders
    - name: avgOrderQuantity
      expression: "avg(orders.map(r, has(r.spec.quantity) ? r.spec.quantity : 0))"
    # Count of orders vs pets
    - name: orderCount
      expression: "orders.size()"
    - name: petCount
      expression: "pets.size()"
    # Sum of quantities for only synced orders
    - name: syncedOrdersQuantity
      expression: "sum(orders.filter(r, r.status.state == 'Synced').map(r, has(r.spec.quantity) ? r.spec.quantity : 0))"
    # Compare across kinds - still possible with resources
    - name: totalResources
      expression: "resources.size()"
{{- if or .QueryKinds .ActionKinds }}
---
# Example aggregating all resource types (CRUD, Query, Action)
# Query CRDs use "Queried" state, Action CRDs use "Completed" state
apiVersion: {{ .APIGroup }}/{{ .APIVersion }}
kind: {{ .Kind }}
metadata:
  name: all-types-aggregate
  namespace: default
spec:
  resourceSelectors:
    # CRUD Resources
{{- range .ResourceKinds }}
    - kind: {{ . }}
{{- end }}
    # Query CRDs (read-only periodic queries)
{{- range .QueryKinds }}
    - kind: {{ . }}
{{- end }}
    # Action CRDs (one-shot or periodic actions)
{{- range .ActionKinds }}
    - kind: {{ . }}
{{- end }}
  aggregationStrategy: AllHealthy
  derivedValues:
    # Count resources by type
    - name: crudResourceCount
      expression: "resources.filter(r, r.status.state == 'Synced' || r.status.state == 'Observed').size()"
    - name: queriedCount
      expression: "resources.filter(r, r.status.state == 'Queried').size()"
    - name: completedActionCount
      expression: "resources.filter(r, r.status.state == 'Completed').size()"
{{- end }}
