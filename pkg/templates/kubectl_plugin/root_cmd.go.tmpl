// Generated by openapi-operator-gen {{ .GeneratorVersion }}
// kubectl plugin for {{ .APIName }} operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"k8s.io/cli-runtime/pkg/genericclioptions"

	"{{ .ModuleName }}/pkg/client"
)

var (
	version   = "dev"
	commit    = "none"
	buildDate = "unknown"

	// Global flags
	kubeConfigFlags *genericclioptions.ConfigFlags
	outputFormat    string

	// Shared client (initialized lazily)
	k8sClient *client.Client
)

// SetVersion sets the version info from main
func SetVersion(v, c, d string) {
	version = v
	commit = c
	buildDate = d
}

var rootCmd = &cobra.Command{
	Use:   "kubectl-{{ .PluginName }}",
	Short: "kubectl plugin for managing {{ .APIName }} resources",
	Long: `kubectl {{ .PluginName }} is a kubectl plugin for managing {{ .APIName }} operator resources.

It provides commands for:
  - Viewing aggregate health status
  - Listing and describing resources
  - Running diagnostics
  - Executing queries and actions

Examples:
  # View overall status
  kubectl {{ .PluginName }} status

  # List all resources of a specific kind
  kubectl {{ .PluginName }} get pets

  # Get detailed information about a resource
  kubectl {{ .PluginName }} describe pet fluffy`,
	Version: version,
	PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
		// Skip client initialization for help and version commands
		if cmd.Name() == "help" || cmd.Name() == "version" {
			return nil
		}
		return initClient()
	},
}

func init() {
	// Initialize kubeconfig flags (includes --namespace/-n)
	kubeConfigFlags = genericclioptions.NewConfigFlags(true)
	kubeConfigFlags.AddFlags(rootCmd.PersistentFlags())

	// Add output format flag (don't use -o shorthand, conflicts with kubeconfig output)
	rootCmd.PersistentFlags().StringVar(&outputFormat, "output", "", "Output format: table, json, yaml, wide")

	// Set version template
	rootCmd.SetVersionTemplate(fmt.Sprintf("kubectl-{{ .PluginName }} version %s\n  commit: %s\n  built:  %s\n", version, commit, buildDate))

	// Add subcommands
	rootCmd.AddCommand(statusCmd)
	rootCmd.AddCommand(getCmd)
	rootCmd.AddCommand(describeCmd)
}

// initClient initializes the Kubernetes client
func initClient() error {
	var err error
	k8sClient, err = client.NewClient(kubeConfigFlags, "{{ .APIGroup }}", "{{ .APIVersion }}")
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes client: %w", err)
	}

	// Set namespace from flag or default from kubeconfig
	ns, _, err := kubeConfigFlags.ToRawKubeConfigLoader().Namespace()
	if err != nil || ns == "" {
		ns = "default"
	}
	k8sClient.SetNamespace(ns)

	return nil
}

// Execute runs the root command
func Execute() error {
	return rootCmd.Execute()
}

// exitWithError prints an error message and exits
func exitWithError(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "Error: "+format+"\n", args...)
	os.Exit(1)
}
