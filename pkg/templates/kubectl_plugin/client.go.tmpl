// Generated by openapi-operator-gen {{ .GeneratorVersion }}
// kubectl plugin for {{ .APIName }} operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package client

import (
	"context"
	"fmt"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/cli-runtime/pkg/genericclioptions"
	"k8s.io/client-go/dynamic"
)

// Client provides access to {{ .APIName }} CRDs via the Kubernetes API
type Client struct {
	dynamic   dynamic.Interface
	apiGroup  string
	apiVersion string
	namespace string
}

// NewClient creates a new Client from kubeconfig flags
func NewClient(flags *genericclioptions.ConfigFlags, apiGroup, apiVersion string) (*Client, error) {
	config, err := flags.ToRESTConfig()
	if err != nil {
		return nil, fmt.Errorf("failed to get REST config: %w", err)
	}

	dynamicClient, err := dynamic.NewForConfig(config)
	if err != nil {
		return nil, fmt.Errorf("failed to create dynamic client: %w", err)
	}

	return &Client{
		dynamic:    dynamicClient,
		apiGroup:   apiGroup,
		apiVersion: apiVersion,
		namespace:  "default",
	}, nil
}

// SetNamespace sets the default namespace for operations
func (c *Client) SetNamespace(ns string) {
	c.namespace = ns
}

// GetNamespace returns the current namespace
func (c *Client) GetNamespace() string {
	return c.namespace
}

// gvr returns the GroupVersionResource for a given resource plural name
func (c *Client) gvr(plural string) schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    c.apiGroup,
		Version:  c.apiVersion,
		Resource: plural,
	}
}

// Get retrieves a single resource by name
func (c *Client) Get(ctx context.Context, plural, name string) (*unstructured.Unstructured, error) {
	return c.dynamic.Resource(c.gvr(plural)).Namespace(c.namespace).Get(ctx, name, metav1.GetOptions{})
}

// List retrieves all resources of a kind in the current namespace
func (c *Client) List(ctx context.Context, plural string) (*unstructured.UnstructuredList, error) {
	return c.dynamic.Resource(c.gvr(plural)).Namespace(c.namespace).List(ctx, metav1.ListOptions{})
}

// ListWithSelector retrieves resources with a label selector
func (c *Client) ListWithSelector(ctx context.Context, plural, labelSelector string) (*unstructured.UnstructuredList, error) {
	opts := metav1.ListOptions{}
	if labelSelector != "" {
		opts.LabelSelector = labelSelector
	}
	return c.dynamic.Resource(c.gvr(plural)).Namespace(c.namespace).List(ctx, opts)
}

// ListAllNamespaces retrieves resources across all namespaces
func (c *Client) ListAllNamespaces(ctx context.Context, plural, labelSelector string) (*unstructured.UnstructuredList, error) {
	opts := metav1.ListOptions{}
	if labelSelector != "" {
		opts.LabelSelector = labelSelector
	}
	return c.dynamic.Resource(c.gvr(plural)).Namespace("").List(ctx, opts)
}

// Create creates a new resource
func (c *Client) Create(ctx context.Context, plural string, obj *unstructured.Unstructured) (*unstructured.Unstructured, error) {
	return c.dynamic.Resource(c.gvr(plural)).Namespace(c.namespace).Create(ctx, obj, metav1.CreateOptions{})
}

// Update updates an existing resource
func (c *Client) Update(ctx context.Context, plural string, obj *unstructured.Unstructured) (*unstructured.Unstructured, error) {
	return c.dynamic.Resource(c.gvr(plural)).Namespace(c.namespace).Update(ctx, obj, metav1.UpdateOptions{})
}

// Patch applies a patch to a resource
func (c *Client) Patch(ctx context.Context, plural, name string, patchType string, patchData []byte) (*unstructured.Unstructured, error) {
	var pt types.PatchType
	switch patchType {
	case "merge":
		pt = types.MergePatchType
	case "strategic":
		pt = types.StrategicMergePatchType
	default:
		pt = types.JSONPatchType
	}
	return c.dynamic.Resource(c.gvr(plural)).Namespace(c.namespace).Patch(ctx, name, pt, patchData, metav1.PatchOptions{})
}

// Delete removes a resource
func (c *Client) Delete(ctx context.Context, plural, name string) error {
	return c.dynamic.Resource(c.gvr(plural)).Namespace(c.namespace).Delete(ctx, name, metav1.DeleteOptions{})
}

// Watch watches for changes to resources
func (c *Client) Watch(ctx context.Context, plural string) (<-chan WatchEvent, error) {
	watcher, err := c.dynamic.Resource(c.gvr(plural)).Namespace(c.namespace).Watch(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	events := make(chan WatchEvent)
	go func() {
		defer close(events)
		defer watcher.Stop()
		for event := range watcher.ResultChan() {
			obj, ok := event.Object.(*unstructured.Unstructured)
			if !ok {
				continue
			}
			events <- WatchEvent{
				Type:   string(event.Type),
				Object: obj,
			}
		}
	}()

	return events, nil
}

// WatchEvent represents a watch event
type WatchEvent struct {
	Type   string
	Object *unstructured.Unstructured
}
