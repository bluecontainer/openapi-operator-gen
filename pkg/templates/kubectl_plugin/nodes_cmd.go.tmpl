// Generated by openapi-operator-gen {{ .GeneratorVersion }}
// kubectl plugin for {{ .APIName }} operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"os"

	"github.com/bluecontainer/kubectl-rundeck-nodes/pkg/nodes"
	"github.com/spf13/cobra"
)

const (
	// defaultClusterTokenSuffix is the default Rundeck Key Storage path suffix for the cluster token.
	// Used when --cluster-token-suffix is not specified. Jobs prepend "keys/" to this value.
	defaultClusterTokenSuffix = "project/{{ .PluginName }}-operator/k8s-token"
)

var (
	nodesAllNamespaces      bool
	nodesLabelSelector      string
	nodesClusterName        string
	nodesClusterURL         string
	nodesClusterTokenSuffix string
	nodesOutput             string

	// Phase 1: Core Filtering flags
	nodesTypes           []string
	nodesExcludeTypes    []string
	nodesExcludeLabels   []string
	nodesExcludeOperator bool
	nodesHealthyOnly     bool
	nodesUnhealthyOnly   bool

	// Phase 2: Pattern Matching flags
	nodesNamePatterns             []string
	nodesExcludePatterns          []string
	nodesExcludeNamespaces        []string
	nodesNamespacePatterns        []string
	nodesExcludeNamespacePatterns []string

	// Phase 4: Output Customization flags
	nodesAddTags              []string
	nodesLabelsAsTags         []string
	nodesLabelAttributes      []string
	nodesAnnotationAttributes []string
)

var nodesCmd = &cobra.Command{
	Use:   "nodes",
	Short: "Discover workloads as Rundeck node source JSON",
	Long: `Discover Kubernetes workloads (Helm releases, StatefulSets, Deployments) and
output them as Rundeck resource model JSON. This command is designed to be used
as a Rundeck script-based resource model source.

Each discovered workload becomes a Rundeck node with attributes that map to
the kubectl plugin's --target-* flags:

  targetType:      helm-release, statefulset, or deployment
  targetValue:     the workload or release name
  targetNamespace: the workload's namespace
  workloadKind:    StatefulSet or Deployment
  workloadName:    the underlying workload name
  podCount:        total pod count
  healthyPods:     running pod count

Examples:
  # Discover workloads in the default namespace
  kubectl {{ .PluginName }} nodes

  # Discover workloads across all namespaces
  kubectl {{ .PluginName }} nodes --all-namespaces

  # Filter by label selector
  kubectl {{ .PluginName }} nodes -l app.kubernetes.io/part-of=petstore

  # Filter by workload type
  kubectl {{ .PluginName }} nodes --types=statefulset,helm-release

  # Exclude operator workloads
  kubectl {{ .PluginName }} nodes --exclude-operator

  # Only healthy workloads
  kubectl {{ .PluginName }} nodes --healthy-only

  # Only unhealthy workloads (for alerting/remediation)
  kubectl {{ .PluginName }} nodes --unhealthy-only

  # Filter by name pattern
  kubectl {{ .PluginName }} nodes --name-pattern="myapp-*"

  # Exclude specific namespaces
  kubectl {{ .PluginName }} nodes --exclude-namespaces=kube-system,kube-public`,
	RunE: runNodes,
}

func init() {
	nodesCmd.Flags().BoolVarP(&nodesAllNamespaces, "all-namespaces", "A", false, "Discover workloads across all namespaces")
	nodesCmd.Flags().StringVarP(&nodesLabelSelector, "selector", "l", "", "Label selector to filter workloads (e.g., app=myapp)")
	nodesCmd.Flags().StringVar(&nodesClusterName, "cluster-name", "", "Cluster identifier for multi-cluster node discovery")
	nodesCmd.Flags().StringVar(&nodesClusterURL, "cluster-url", "", "Cluster API URL to embed in node attributes")
	nodesCmd.Flags().StringVar(&nodesClusterTokenSuffix, "cluster-token-suffix", "", "Rundeck Key Storage path suffix for cluster token (e.g., clusters/prod/token). Jobs prepend 'keys/' to this value.")
	nodesCmd.Flags().StringVarP(&nodesOutput, "output", "o", "json", "Output format: json, yaml, table")

	// Phase 1: Core Filtering flags
	nodesCmd.Flags().StringSliceVar(&nodesTypes, "types", nil, "Only include these workload types (helm-release, statefulset, deployment)")
	nodesCmd.Flags().StringSliceVar(&nodesExcludeTypes, "exclude-types", nil, "Exclude these workload types")
	nodesCmd.Flags().StringSliceVar(&nodesExcludeLabels, "exclude-labels", nil, "Exclude workloads matching these label selectors")
	nodesCmd.Flags().BoolVar(&nodesExcludeOperator, "exclude-operator", false, "Exclude operator controller-manager workloads")
	nodesCmd.Flags().BoolVar(&nodesHealthyOnly, "healthy-only", false, "Only include workloads with all pods running")
	nodesCmd.Flags().BoolVar(&nodesUnhealthyOnly, "unhealthy-only", false, "Only include workloads with some pods not running")

	// Phase 2: Pattern Matching flags
	nodesCmd.Flags().StringSliceVar(&nodesNamePatterns, "name-pattern", nil, "Only include workloads matching these glob patterns (e.g., myapp-*)")
	nodesCmd.Flags().StringSliceVar(&nodesExcludePatterns, "exclude-pattern", nil, "Exclude workloads matching these glob patterns")
	nodesCmd.Flags().StringSliceVar(&nodesExcludeNamespaces, "exclude-namespaces", nil, "Exclude workloads in these namespaces")
	nodesCmd.Flags().StringSliceVar(&nodesNamespacePatterns, "namespace-pattern", nil, "Only include workloads in namespaces matching these patterns")
	nodesCmd.Flags().StringSliceVar(&nodesExcludeNamespacePatterns, "exclude-namespace-pattern", nil, "Exclude workloads in namespaces matching these patterns")

	// Phase 4: Output Customization flags
	nodesCmd.Flags().StringSliceVar(&nodesAddTags, "add-tags", nil, "Add custom tags to all nodes (e.g., env:prod,team:platform)")
	nodesCmd.Flags().StringSliceVar(&nodesLabelsAsTags, "labels-as-tags", nil, "Convert these Kubernetes labels to Rundeck tags (e.g., app.kubernetes.io/name)")
	nodesCmd.Flags().StringSliceVar(&nodesLabelAttributes, "label-attributes", nil, "Add these Kubernetes labels as node attributes (e.g., app.kubernetes.io/version)")
	nodesCmd.Flags().StringSliceVar(&nodesAnnotationAttributes, "annotation-attributes", nil, "Add these Kubernetes annotations as node attributes")
}

func runNodes(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	dynClient := k8sClient.DynamicClient()
	if dynClient == nil {
		return fmt.Errorf("dynamic client not initialized (dry-run mode does not support nodes discovery)")
	}

	ns := k8sClient.GetNamespace()

	// Determine effective token suffix
	tokenSuffix := nodesClusterTokenSuffix
	if tokenSuffix == "" {
		tokenSuffix = defaultClusterTokenSuffix
	}

	opts := nodes.DiscoverOptions{
		Namespace:          ns,
		AllNamespaces:      nodesAllNamespaces,
		LabelSelector:      nodesLabelSelector,
		ClusterName:        nodesClusterName,
		ClusterURL:         nodesClusterURL,
		ClusterTokenSuffix: tokenSuffix,
		DefaultTokenSuffix: tokenSuffix,
		// Phase 1: Core Filtering
		Types:           nodesTypes,
		ExcludeTypes:    nodesExcludeTypes,
		ExcludeLabels:   nodesExcludeLabels,
		ExcludeOperator:  nodesExcludeOperator,
		HealthyOnly:      nodesHealthyOnly,
		UnhealthyOnly:    nodesUnhealthyOnly,
		// Phase 2: Pattern Matching
		NamePatterns:             nodesNamePatterns,
		ExcludePatterns:          nodesExcludePatterns,
		ExcludeNamespaces:        nodesExcludeNamespaces,
		NamespacePatterns:        nodesNamespacePatterns,
		ExcludeNamespacePatterns: nodesExcludeNamespacePatterns,
		// Phase 4: Output Customization
		AddTags:              nodesAddTags,
		LabelsAsTags:         nodesLabelsAsTags,
		LabelAttributes:      nodesLabelAttributes,
		AnnotationAttributes: nodesAnnotationAttributes,
	}

	discovered, err := nodes.Discover(ctx, dynClient, opts)
	if err != nil {
		return fmt.Errorf("discovery failed: %w", err)
	}

	format := nodes.OutputFormat(nodesOutput)
	return nodes.Write(os.Stdout, discovered, format)
}
