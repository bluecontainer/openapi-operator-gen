// Generated by openapi-operator-gen {{ .GeneratorVersion }}
// kubectl plugin for {{ .APIName }} operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"os"

	"github.com/bluecontainer/kubectl-rundeck-nodes/pkg/nodes"
	"github.com/spf13/cobra"
)

const (
	// defaultClusterTokenSuffix is the default Rundeck Key Storage path suffix for the cluster token.
	// Used when --cluster-token-suffix is not specified. Jobs prepend "keys/" to this value.
	defaultClusterTokenSuffix = "project/{{ .PluginName }}-operator/k8s-token"
)

var (
	nodesAllNamespaces      bool
	nodesLabelSelector      string
	nodesClusterName        string
	nodesClusterURL         string
	nodesClusterTokenSuffix string
	nodesOutput             string

	// Phase 1: Core Filtering flags
	nodesTypes           []string
	nodesExcludeTypes    []string
	nodesExcludeLabels   []string
	nodesExcludeOperator bool
	nodesHealthyOnly     bool
)

var nodesCmd = &cobra.Command{
	Use:   "nodes",
	Short: "Discover workloads as Rundeck node source JSON",
	Long: `Discover Kubernetes workloads (Helm releases, StatefulSets, Deployments) and
output them as Rundeck resource model JSON. This command is designed to be used
as a Rundeck script-based resource model source.

Each discovered workload becomes a Rundeck node with attributes that map to
the kubectl plugin's --target-* flags:

  targetType:      helm-release, statefulset, or deployment
  targetValue:     the workload or release name
  targetNamespace: the workload's namespace
  workloadKind:    StatefulSet or Deployment
  workloadName:    the underlying workload name
  podCount:        total pod count
  healthyPods:     running pod count

Examples:
  # Discover workloads in the default namespace
  kubectl {{ .PluginName }} nodes

  # Discover workloads across all namespaces
  kubectl {{ .PluginName }} nodes --all-namespaces

  # Filter by label selector
  kubectl {{ .PluginName }} nodes -l app.kubernetes.io/part-of=petstore

  # Filter by workload type
  kubectl {{ .PluginName }} nodes --types=statefulset,helm-release

  # Exclude operator workloads
  kubectl {{ .PluginName }} nodes --exclude-operator

  # Only healthy workloads
  kubectl {{ .PluginName }} nodes --healthy-only`,
	RunE: runNodes,
}

func init() {
	nodesCmd.Flags().BoolVarP(&nodesAllNamespaces, "all-namespaces", "A", false, "Discover workloads across all namespaces")
	nodesCmd.Flags().StringVarP(&nodesLabelSelector, "selector", "l", "", "Label selector to filter workloads (e.g., app=myapp)")
	nodesCmd.Flags().StringVar(&nodesClusterName, "cluster-name", "", "Cluster identifier for multi-cluster node discovery")
	nodesCmd.Flags().StringVar(&nodesClusterURL, "cluster-url", "", "Cluster API URL to embed in node attributes")
	nodesCmd.Flags().StringVar(&nodesClusterTokenSuffix, "cluster-token-suffix", "", "Rundeck Key Storage path suffix for cluster token (e.g., clusters/prod/token). Jobs prepend 'keys/' to this value.")
	nodesCmd.Flags().StringVarP(&nodesOutput, "output", "o", "json", "Output format: json, yaml, table")

	// Phase 1: Core Filtering flags
	nodesCmd.Flags().StringSliceVar(&nodesTypes, "types", nil, "Only include these workload types (helm-release, statefulset, deployment)")
	nodesCmd.Flags().StringSliceVar(&nodesExcludeTypes, "exclude-types", nil, "Exclude these workload types")
	nodesCmd.Flags().StringSliceVar(&nodesExcludeLabels, "exclude-labels", nil, "Exclude workloads matching these label selectors")
	nodesCmd.Flags().BoolVar(&nodesExcludeOperator, "exclude-operator", false, "Exclude operator controller-manager workloads")
	nodesCmd.Flags().BoolVar(&nodesHealthyOnly, "healthy-only", false, "Only include workloads with all pods running")
}

func runNodes(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	dynClient := k8sClient.DynamicClient()
	if dynClient == nil {
		return fmt.Errorf("dynamic client not initialized (dry-run mode does not support nodes discovery)")
	}

	ns := k8sClient.GetNamespace()

	// Determine effective token suffix
	tokenSuffix := nodesClusterTokenSuffix
	if tokenSuffix == "" {
		tokenSuffix = defaultClusterTokenSuffix
	}

	opts := nodes.DiscoverOptions{
		Namespace:          ns,
		AllNamespaces:      nodesAllNamespaces,
		LabelSelector:      nodesLabelSelector,
		ClusterName:        nodesClusterName,
		ClusterURL:         nodesClusterURL,
		ClusterTokenSuffix: tokenSuffix,
		DefaultTokenSuffix: tokenSuffix,
		// Phase 1: Core Filtering
		Types:           nodesTypes,
		ExcludeTypes:    nodesExcludeTypes,
		ExcludeLabels:   nodesExcludeLabels,
		ExcludeOperator: nodesExcludeOperator,
		HealthyOnly:     nodesHealthyOnly,
	}

	discovered, err := nodes.Discover(ctx, dynClient, opts)
	if err != nil {
		return fmt.Errorf("discovery failed: %w", err)
	}

	format := nodes.OutputFormat(nodesOutput)
	return nodes.Write(os.Stdout, discovered, format)
}
