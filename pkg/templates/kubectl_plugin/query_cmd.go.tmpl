// Generated by openapi-operator-gen {{ .GeneratorVersion }}
// kubectl plugin for {{ .APIName }} operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"{{ .ModuleName }}/pkg/output"
)

var (
	queryPodOrdinal int
	queryInterval   string
	queryName       string
	queryWait       bool
	queryTimeout    time.Duration
	queryGet        string
	queryQuiet      bool
	queryDryRun     bool
)

var queryCmd = &cobra.Command{
	Use:   "query QUERY-TYPE [flags]",
	Short: "Execute query CRDs for {{ .APIName }}",
	Long: `Execute query CRDs to fetch data from the {{ .APIName }} API.

Queries are read-only operations that fetch data from the API endpoint.
They can be run as one-shot operations or as periodic queries.

Available query types:
{{- range .QueryKinds }}
  - {{ .KindLower }} ({{ .Kind }})
{{- end }}

Examples:
  # Run a one-shot query
  kubectl {{ .PluginName }} query petfindbystatusquery --status=available

  # Run query targeting specific pod
  kubectl {{ .PluginName }} query storeinventoryquery --pod=0

  # Create a periodic query (creates persistent CR)
  kubectl {{ .PluginName }} query storeinventoryquery --interval=5m --name=inventory-monitor

  # Run query and wait for result
  kubectl {{ .PluginName }} query petfindbytagsquery --tags=cute --wait

  # Get results from an existing query CR
  kubectl {{ .PluginName }} query petfindbystatusquery --get=my-status-query

  # Dry run - show CR without creating
  kubectl {{ .PluginName }} query petfindbystatusquery --status=available --dry-run

  # Output only the result data (for scripting)
  kubectl {{ .PluginName }} query petfindbystatusquery --status=available -q --output=json`,
	Args: cobra.MinimumNArgs(1),
	RunE: runQuery,
}

func init() {
	queryCmd.Flags().IntVar(&queryPodOrdinal, "pod", -1, "Target specific pod ordinal")
	queryCmd.Flags().StringVar(&queryInterval, "interval", "", "Execution interval for periodic queries (e.g., 5m, 1h)")
	queryCmd.Flags().StringVar(&queryName, "name", "", "Name for the query CR (required for periodic queries)")
	queryCmd.Flags().BoolVar(&queryWait, "wait", false, "Wait for query to complete and show results")
	queryCmd.Flags().DurationVar(&queryTimeout, "timeout", 30*time.Second, "Timeout for waiting on query results")
	queryCmd.Flags().StringVar(&queryGet, "get", "", "Get results from an existing query CR by name (instead of creating a new one)")
	queryCmd.Flags().BoolVarP(&queryQuiet, "quiet", "q", false, "Output only the result data (no status messages)")
	queryCmd.Flags().BoolVar(&queryDryRun, "dry-run", false, "Print the CR that would be created without creating it")

	// Allow unknown flags to pass through as query parameters (parsed from os.Args)
	queryCmd.FParseErrWhitelist.UnknownFlags = true
}

func runQuery(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	queryType := strings.ToLower(args[0])

	// Resolve query type to kind
	queryKind := resolveQueryKind(queryType)
	if queryKind == "" {
		return fmt.Errorf("unknown query type: %s\nRun 'kubectl {{ .PluginName }} query --help' to see available types", queryType)
	}

	plural := resolveKindPlural(queryType)

	// If --get is specified, retrieve results from existing CR
	if queryGet != "" {
		if !queryQuiet {
			fmt.Printf("Fetching results from: %s/%s\n", plural, queryGet)
		}
		obj, err := k8sClient.Get(ctx, plural, queryGet)
		if err != nil {
			return fmt.Errorf("failed to get query %s: %w", queryGet, err)
		}
		return printQueryResult(obj)
	}

	// Parse query parameters from command line
	params := parseQueryParams()

	// Determine if this is a one-shot or periodic query
	isPeriodic := queryInterval != ""

	if isPeriodic && queryName == "" {
		return fmt.Errorf("--name is required for periodic queries")
	}

	// Generate a name if not provided (one-shot)
	name := queryName
	if name == "" {
		name = fmt.Sprintf("%s-%d", queryType, time.Now().Unix())
	}

	// Build the query CR
	queryCR := buildQueryCR(queryKind, name, params, isPeriodic)

	// Dry run - print CR and exit
	if queryDryRun {
		switch outputFormat {
		case "json":
			return output.PrintJSON(queryCR.Object)
		default:
			return output.PrintYAML(queryCR.Object)
		}
	}

	// Create the query CR
	if !queryQuiet {
		fmt.Printf("Executing query: %s\n", queryKind)
	}

	created, err := k8sClient.Create(ctx, plural, queryCR)
	if err != nil {
		return fmt.Errorf("failed to create query: %w", err)
	}

	if !queryQuiet {
		if !isPeriodic {
			// For one-shot queries, add cleanup annotation
			fmt.Printf("Query created: %s/%s\n", plural, name)
		} else {
			fmt.Printf("Periodic query created: %s/%s (interval: %s)\n", plural, name, queryInterval)
		}
	}

	// Wait for results if requested
	if queryWait || !isPeriodic {
		return waitForQueryResult(ctx, plural, name, created)
	}

	return nil
}

func resolveQueryKind(queryType string) string {
	queryType = strings.ToLower(queryType)
	queryKinds := map[string]string{
{{- range .QueryKinds }}
		"{{ .KindLower }}": "{{ .Kind }}",
		"{{ .Plural }}": "{{ .Kind }}",
{{- end }}
	}
	return queryKinds[queryType]
}

func parseQueryParams() map[string]interface{} {
	params := make(map[string]interface{})

	// Parse --key=value and --key value style args from os.Args
	// This is needed because Cobra consumes unknown flags even with FParseErrWhitelist
	args := os.Args
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if !strings.HasPrefix(arg, "--") {
			continue
		}

		stripped := strings.TrimPrefix(arg, "--")

		// Handle --key=value syntax
		if strings.Contains(stripped, "=") {
			parts := strings.SplitN(stripped, "=", 2)
			if !isCommonFlag(parts[0]) {
				params[parts[0]] = coerceQueryParamValue(parts[1])
			}
			continue
		}

		// Handle --key value syntax (space-separated)
		key := stripped
		if isCommonFlag(key) {
			continue
		}
		// Look ahead for the value (next arg that doesn't start with --)
		if i+1 < len(args) && !strings.HasPrefix(args[i+1], "--") {
			params[key] = coerceQueryParamValue(args[i+1])
			i++ // skip the value arg
		}
	}

	return params
}

// coerceQueryParamValue attempts to convert string values to appropriate Go types
// so that the Kubernetes API server receives correctly typed values.
func coerceQueryParamValue(s string) interface{} {
	// Try integer
	if i, err := strconv.ParseInt(s, 10, 64); err == nil {
		return i
	}
	// Try float
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	// Try boolean
	if b, err := strconv.ParseBool(s); err == nil {
		return b
	}
	// Return as string
	return s
}

func isCommonFlag(name string) bool {
	commonFlags := map[string]bool{
		"pod": true, "interval": true, "name": true,
		"wait": true, "timeout": true, "output": true,
		"get": true, "quiet": true, "q": true,
		"dry-run": true,
		"namespace": true, "context": true, "kubeconfig": true,
	}
	return commonFlags[name]
}

func buildQueryCR(kind, name string, params map[string]interface{}, isPeriodic bool) *unstructured.Unstructured {
	spec := make(map[string]interface{})

	// Add query parameters to spec
	for k, v := range params {
		spec[k] = v
	}

	// Add targeting if specified
	if queryPodOrdinal >= 0 {
		spec["target"] = map[string]interface{}{
			"podOrdinal": queryPodOrdinal,
		}
	}

	// Add execution interval for periodic queries
	if isPeriodic {
		spec["executionInterval"] = queryInterval
	}

	// Add one-shot annotation for cleanup
	annotations := map[string]interface{}{}
	if !isPeriodic {
		annotations["{{ .APIGroup }}/one-shot"] = "true"
		annotations["{{ .APIGroup }}/created-by"] = "kubectl-plugin"
	}

	obj := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "{{ .APIGroup }}/{{ .APIVersion }}",
			"kind":       kind,
			"metadata": map[string]interface{}{
				"name":        name,
				"namespace":   k8sClient.GetNamespace(),
				"annotations": annotations,
			},
			"spec": spec,
		},
	}

	return obj
}

func waitForQueryResult(ctx context.Context, plural, name string, original *unstructured.Unstructured) error {
	if !queryQuiet {
		fmt.Printf("Waiting for query result (timeout: %s)...\n", queryTimeout)
	}

	deadline := time.Now().Add(queryTimeout)
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
			if time.Now().After(deadline) {
				return fmt.Errorf("timeout waiting for query result")
			}

			obj, err := k8sClient.Get(ctx, plural, name)
			if err != nil {
				continue
			}

			// Check if query has completed
			state, _, _ := unstructured.NestedString(obj.Object, "status", "state")
			if state == "Completed" || state == "Synced" || state == "Queried" {
				return printQueryResult(obj)
			}
			if state == "Failed" || state == "Error" {
				msg, _, _ := unstructured.NestedString(obj.Object, "status", "message")
				return fmt.Errorf("query failed: %s", msg)
			}
		}
	}
}

func printQueryResult(obj *unstructured.Unstructured) error {
	// Check if we have per-endpoint responses (multi-endpoint mode)
	responses, hasResponses, _ := unstructured.NestedMap(obj.Object, "status", "responses")
	if hasResponses && len(responses) > 0 {
		return printMultiEndpointQueryResult(obj, responses)
	}

	// Single-endpoint mode - try status.response or status.results
	response, found, _ := unstructured.NestedMap(obj.Object, "status", "response")
	if !found {
		response, found, _ = unstructured.NestedMap(obj.Object, "status", "results")
	}

	if !found {
		if !queryQuiet {
			fmt.Println("No response data available")
		}
		return nil
	}

	// Get response data
	data, hasData := response["data"]

	// In quiet mode, output only the data
	if queryQuiet {
		if hasData {
			switch outputFormat {
			case "json":
				return output.PrintJSON(data)
			case "yaml":
				return output.PrintYAML(data)
			default:
				// Default to JSON in quiet mode for easy parsing
				return output.PrintJSON(data)
			}
		}
		return nil
	}

	// Normal mode - print with labels and metadata
	fmt.Println()

	// Check status code
	if statusCode, ok := response["statusCode"].(int64); ok {
		fmt.Printf("Status Code: %d\n", statusCode)
	}

	// Print response data
	if hasData {
		fmt.Println("\nResults:")
		switch outputFormat {
		case "json":
			return output.PrintJSON(data)
		case "yaml":
			return output.PrintYAML(data)
		default:
			printQueryData(data, "  ")
		}
	}

	// Get timing info
	lastExec, _, _ := unstructured.NestedString(obj.Object, "status", "lastExecutionTime")
	if lastExec != "" {
		fmt.Printf("\nExecuted at: %s\n", lastExec)
	}

	// Get result count if available
	resultCount, hasCount, _ := unstructured.NestedInt64(obj.Object, "status", "resultCount")
	if hasCount {
		fmt.Printf("Total results: %d\n", resultCount)
	}

	return nil
}

func printMultiEndpointQueryResult(obj *unstructured.Unstructured, responses map[string]interface{}) error {
	// Build a structured result with all endpoint responses
	allResults := make(map[string]interface{})
	successCount := 0
	failCount := 0

	for endpoint, respRaw := range responses {
		resp, ok := respRaw.(map[string]interface{})
		if !ok {
			continue
		}
		success, _ := resp["success"].(bool)
		if success {
			successCount++
			if data, hasData := resp["data"]; hasData {
				allResults[endpoint] = data
			}
		} else {
			failCount++
			errMsg, _ := resp["error"].(string)
			allResults[endpoint] = map[string]interface{}{"error": errMsg}
		}
	}

	// In quiet mode, output all endpoint data as JSON/YAML
	if queryQuiet {
		switch outputFormat {
		case "yaml":
			return output.PrintYAML(allResults)
		default:
			// Default to JSON in quiet mode
			return output.PrintJSON(allResults)
		}
	}

	// Normal mode - show summary and results per endpoint
	fmt.Printf("\nQuery executed on %d endpoints (%d successful, %d failed):\n\n",
		len(responses), successCount, failCount)

	for endpoint, respRaw := range responses {
		resp, ok := respRaw.(map[string]interface{})
		if !ok {
			continue
		}

		success, _ := resp["success"].(bool)
		statusIcon := output.Green("✓")
		if !success {
			statusIcon = output.Red("✗")
		}

		fmt.Printf("%s %s\n", statusIcon, endpoint)

		if !success {
			errMsg, _ := resp["error"].(string)
			if errMsg != "" {
				fmt.Printf("    Error: %s\n", errMsg)
			}
			continue
		}

		// Show status code if available
		if statusCode, ok := resp["statusCode"].(int64); ok {
			fmt.Printf("    Status Code: %d\n", statusCode)
		}

		// Show data
		data, hasData := resp["data"]
		if hasData {
			switch outputFormat {
			case "json":
				fmt.Print("    Data: ")
				output.PrintJSON(data)
			case "yaml":
				fmt.Println("    Data:")
				output.PrintYAML(data)
			default:
				fmt.Println("    Data:")
				printQueryData(data, "      ")
			}
		}
		fmt.Println()
	}

	// Get timing info
	lastExec, _, _ := unstructured.NestedString(obj.Object, "status", "lastExecutionTime")
	if lastExec != "" {
		fmt.Printf("Executed at: %s\n", lastExec)
	}

	return nil
}

func printQueryData(data interface{}, indent string) {
	switch v := data.(type) {
	case []interface{}:
		if len(v) == 0 {
			fmt.Printf("%s(empty list)\n", indent)
			return
		}
		fmt.Printf("%s%d items:\n", indent, len(v))
		for i, item := range v {
			if i >= 10 {
				fmt.Printf("%s  ... and %d more\n", indent, len(v)-10)
				break
			}
			printQueryData(item, indent+"  - ")
		}
	case map[string]interface{}:
		// For single items, print key-value pairs
		first := true
		for k, val := range v {
			if first {
				fmt.Printf("%s%s: %v", indent, k, formatValue(val))
				first = false
			} else {
				fmt.Printf(", %s: %v", k, formatValue(val))
			}
		}
		fmt.Println()
	default:
		fmt.Printf("%s%v\n", indent, v)
	}
}

func formatValue(v interface{}) string {
	switch val := v.(type) {
	case string:
		if len(val) > 30 {
			return val[:27] + "..."
		}
		return val
	case map[string]interface{}:
		return "{...}"
	case []interface{}:
		return fmt.Sprintf("[%d items]", len(val))
	default:
		return fmt.Sprintf("%v", val)
	}
}

// listQueryCmd lists available query types
var listQueriesCmd = &cobra.Command{
	Use:   "queries",
	Short: "List available query types",
	Long:  `List all available query types that can be executed.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		fmt.Println("Available query types:")
		fmt.Println()
{{- range .QueryKinds }}
		fmt.Printf("  %-30s %s\n", "{{ .KindLower }}", "{{ .Kind }}")
{{- end }}
		fmt.Println()
		fmt.Println("Use 'kubectl {{ .PluginName }} query <type> --help' for more information")
		return nil
	},
}

func init() {
	// Add list subcommand
	queryCmd.AddCommand(listQueriesCmd)
}
