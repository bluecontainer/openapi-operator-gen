/*
Copyright {{ .Year }} Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"context"
	"fmt"
	"regexp"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/labels"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"

	{{ .APIVersion }} "{{ .ModuleName }}/api/{{ .APIVersion }}"
)

var (
	{{ .KindLower }}Tracer = otel.Tracer("{{ .ModuleName }}/controller/{{ .KindLower }}")
	{{ .KindLower }}Meter  = otel.Meter("{{ .ModuleName }}/controller/{{ .KindLower }}")

	// Metrics
	{{ .KindLower }}ReconcileTotal    metric.Int64Counter
	{{ .KindLower }}ReconcileDuration metric.Float64Histogram
	{{ .KindLower }}ResourcesTotal    metric.Int64UpDownCounter
)

func init() {
	var err error

	{{ .KindLower }}ReconcileTotal, err = {{ .KindLower }}Meter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}ReconcileDuration, err = {{ .KindLower }}Meter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	{{ .KindLower }}ResourcesTotal, err = {{ .KindLower }}Meter.Int64UpDownCounter(
		"aggregated_resources_total",
		metric.WithDescription("Total number of resources being aggregated"),
		metric.WithUnit("{resource}"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
	{{ .KindLower }}RequeueAfter = time.Second * 30
)

// {{ .Kind }}Reconciler reconciles a {{ .Kind }} object
type {{ .Kind }}Reconciler struct {
	client.Client
	Scheme *k8sruntime.Scheme
}

// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }},verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/status,verbs=get;update;patch
// +kubebuilder:rbac:groups={{ .APIGroup }},resources={{ .Plural }}/finalizers,verbs=update
{{- range .ResourceKinds }}
// +kubebuilder:rbac:groups={{ $.APIGroup }},resources={{ . | lower }}s,verbs=get;list;watch
{{- end }}

// Reconcile is part of the main kubernetes reconciliation loop
func (r *{{ .Kind }}Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// Start tracing span
	ctx, span := {{ .KindLower }}Tracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "{{ .Kind }}"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	// Record metrics
	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	{{ .KindLower }}ReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	{{ .KindLower }}ReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

// reconcileInternal contains the actual reconciliation logic
func (r *{{ .Kind }}Reconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the {{ .Kind }} instance
	instance := &{{ .APIVersion }}.{{ .Kind }}{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("{{ .Kind }} resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get {{ .Kind }}")
		return ctrl.Result{}, err
	}

	// Aggregate status from all selected resources
	if err := r.aggregateStatus(ctx, instance); err != nil {
		r.updateStatus(ctx, instance, "Failed", err.Error())
		return ctrl.Result{RequeueAfter: {{ .KindLower }}RequeueAfter}, err
	}

	return ctrl.Result{RequeueAfter: {{ .KindLower }}RequeueAfter}, nil
}

// aggregateStatus collects and aggregates status from all selected resources
func (r *{{ .Kind }}Reconciler) aggregateStatus(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}) error {
	logger := log.FromContext(ctx)

	var allResources []{{ .APIVersion }}.AggregatedResourceStatus
	var totalCount, syncedCount, failedCount, pendingCount int

	// Process each resource selector
	for _, selector := range instance.Spec.ResourceSelectors {
		resources, err := r.listResourcesBySelector(ctx, instance.Namespace, selector)
		if err != nil {
			logger.Error(err, "Failed to list resources", "kind", selector.Kind)
			continue
		}

		for _, res := range resources {
			allResources = append(allResources, res)
			totalCount++

			switch res.State {
			case "Synced", "Observed":
				syncedCount++
			case "Failed":
				failedCount++
			default:
				pendingCount++
			}
		}
	}

	// Update resource metrics
	{{ .KindLower }}ResourcesTotal.Add(ctx, int64(totalCount),
		metric.WithAttributes(
			attribute.String("aggregate.name", instance.Name),
			attribute.String("aggregate.namespace", instance.Namespace),
		))

	// Update status summary
	now := metav1.Now()
	instance.Status.Summary = {{ .APIVersion }}.AggregateSummary{
		Total:   totalCount,
		Synced:  syncedCount,
		Failed:  failedCount,
		Pending: pendingCount,
	}
	instance.Status.Resources = allResources
	instance.Status.LastAggregationTime = &now

	// Determine overall state based on aggregation strategy
	state, message := r.evaluateAggregationStrategy(instance)

	// Set conditions based on aggregation result
	r.setConditions(ctx, instance, state, message, totalCount, syncedCount, failedCount)

	logger.Info("Aggregated status",
		"total", totalCount,
		"synced", syncedCount,
		"failed", failedCount,
		"state", state)

	r.updateStatus(ctx, instance, state, message)
	return nil
}

// listResourcesBySelector lists resources matching the selector
func (r *{{ .Kind }}Reconciler) listResourcesBySelector(ctx context.Context, namespace string, selector {{ .APIVersion }}.ResourceSelector) ([]{{ .APIVersion }}.AggregatedResourceStatus, error) {
	var results []{{ .APIVersion }}.AggregatedResourceStatus

	// Build label selector
	var labelSelector labels.Selector
	if len(selector.MatchLabels) > 0 {
		labelSelector = labels.SelectorFromSet(selector.MatchLabels)
	} else {
		labelSelector = labels.Everything()
	}

	// Compile name pattern regex if specified
	var nameRegex *regexp.Regexp
	if selector.NamePattern != "" {
		var err error
		nameRegex, err = regexp.Compile(selector.NamePattern)
		if err != nil {
			return nil, err
		}
	}

	listOpts := &client.ListOptions{
		Namespace:     namespace,
		LabelSelector: labelSelector,
	}

	// List resources based on kind
	switch selector.Kind {
	{{- range .ResourceKinds }}
	case "{{ . }}":
		list := &{{ $.APIVersion }}.{{ . }}List{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, err
		}
		for _, item := range list.Items {
			// Apply name pattern filter
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, {{ $.APIVersion }}.AggregatedResourceStatus{
				Kind:       "{{ . }}",
				Name:       item.Name,
				Namespace:  item.Namespace,
				State:      item.Status.State,
				ExternalID: item.Status.ExternalID,
				Message:    item.Status.Message,
				LastSyncTime: item.Status.LastSyncTime,
			})
		}
	{{- end }}
	}

	return results, nil
}

// evaluateAggregationStrategy determines the overall state based on the configured strategy
func (r *{{ .Kind }}Reconciler) evaluateAggregationStrategy(instance *{{ .APIVersion }}.{{ .Kind }}) (string, string) {
	summary := instance.Status.Summary
	strategy := instance.Spec.AggregationStrategy

	if strategy == "" {
		strategy = "AllHealthy" // default
	}

	switch strategy {
	case "AllHealthy":
		if summary.Total == 0 {
			return "Pending", "No resources found matching selectors"
		}
		if summary.Failed > 0 {
			return "Degraded", formatMessage("%d of %d resources failed", summary.Failed, summary.Total)
		}
		if summary.Synced == summary.Total {
			return "Healthy", formatMessage("All %d resources are synced", summary.Total)
		}
		return "Pending", formatMessage("%d of %d resources synced", summary.Synced, summary.Total)

	case "AnyHealthy":
		if summary.Total == 0 {
			return "Pending", "No resources found matching selectors"
		}
		if summary.Synced > 0 {
			return "Healthy", formatMessage("%d of %d resources are synced", summary.Synced, summary.Total)
		}
		return "Degraded", formatMessage("No healthy resources (%d total)", summary.Total)

	case "Quorum":
		if summary.Total == 0 {
			return "Pending", "No resources found matching selectors"
		}
		quorum := (summary.Total / 2) + 1
		if summary.Synced >= quorum {
			return "Healthy", formatMessage("Quorum reached: %d of %d resources synced (need %d)", summary.Synced, summary.Total, quorum)
		}
		return "Degraded", formatMessage("Quorum not reached: %d of %d resources synced (need %d)", summary.Synced, summary.Total, quorum)

	default:
		return "Unknown", formatMessage("Unknown aggregation strategy: %s", strategy)
	}
}

// formatMessage is a helper to format messages
func formatMessage(format string, args ...interface{}) string {
	return fmt.Sprintf(format, args...)
}

// setConditions sets the status conditions based on aggregation results
func (r *{{ .Kind }}Reconciler) setConditions(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, state, message string, total, synced, failed int) {
	now := metav1.Now()

	// Ready condition - True when state is Healthy
	readyCondition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Healthy" {
		readyCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, readyCondition)

	// AllHealthy condition - True when all resources are synced
	allHealthyCondition := metav1.Condition{
		Type:               "AllHealthy",
		Status:             metav1.ConditionFalse,
		Reason:             "NotAllSynced",
		Message:            formatMessage("%d of %d resources synced", synced, total),
		LastTransitionTime: now,
	}
	if total > 0 && synced == total {
		allHealthyCondition.Status = metav1.ConditionTrue
		allHealthyCondition.Reason = "AllSynced"
		allHealthyCondition.Message = formatMessage("All %d resources synced", total)
	}
	meta.SetStatusCondition(&instance.Status.Conditions, allHealthyCondition)

	// HasFailures condition - True when any resource has failed
	hasFailuresCondition := metav1.Condition{
		Type:               "HasFailures",
		Status:             metav1.ConditionFalse,
		Reason:             "NoFailures",
		Message:            "No resources have failed",
		LastTransitionTime: now,
	}
	if failed > 0 {
		hasFailuresCondition.Status = metav1.ConditionTrue
		hasFailuresCondition.Reason = "ResourcesFailed"
		hasFailuresCondition.Message = formatMessage("%d resources have failed", failed)
	}
	meta.SetStatusCondition(&instance.Status.Conditions, hasFailuresCondition)
}

func (r *{{ .Kind }}Reconciler) updateStatus(ctx context.Context, instance *{{ .APIVersion }}.{{ .Kind }}, state, message string) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	instance.Status.State = state
	instance.Status.Message = message
	instance.Status.LastAggregationTime = &now
	instance.Status.ObservedGeneration = instance.Generation

	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *{{ .Kind }}Reconciler) SetupWithManager(mgr ctrl.Manager) error {
	builder := ctrl.NewControllerManagedBy(mgr).
		For(&{{ .APIVersion }}.{{ .Kind }}{})

	// Watch all resource types that can be aggregated
	// When any of these resources change, find aggregates that might be affected
	{{- range .ResourceKinds }}
	builder = builder.Watches(
		&{{ $.APIVersion }}.{{ . }}{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesFor{{ . }}),
	)
	{{- end }}

	return builder.Complete(r)
}

{{- range .ResourceKinds }}
// findAggregatesFor{{ . }} finds all {{ $.Kind }} resources that might be affected by a {{ . }} change
func (r *{{ $.Kind }}Reconciler) findAggregatesFor{{ . }}(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &{{ $.APIVersion }}.{{ $.Kind }}List{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	for _, aggregate := range aggregateList.Items {
		// Check if this aggregate watches {{ . }} resources
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "{{ . }}" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				requests = append(requests, reconcile.Request{
					NamespacedName: client.ObjectKey{
						Name:      aggregate.Name,
						Namespace: aggregate.Namespace,
					},
				})
				break
			}
		}
	}

	return requests
}
{{- end }}
