/*
Copyright 2026 Generated by openapi-operator-gen v0.0.7-16-g065832b-dirty.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package main

import (
	"context"
	"flag"
	"fmt"
	"net/http"
	"os"
	"time"

	"k8s.io/apimachinery/pkg/runtime"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/healthz"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"

	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	"github.com/bluecontainer/openapi-operator-gen/pkg/telemetry"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
	"github.com/bluecontainer/petstore-operator/internal/controller"
)

var (
	// Version information - override at build time via ldflags:
	//   -ldflags "-X main.version=v1.0.0 -X main.commit=$(git rev-parse HEAD) -X main.date=$(date -u +%Y%m%d%H%M%S)"
	version          = "dev"
	commit           = "unknown"
	date             = "unknown"
	generatorVersion = "v0.0.7-16-g065832b-dirty"

	scheme   = runtime.NewScheme()
	setupLog = ctrl.Log.WithName("setup")
)

func init() {
	utilruntime.Must(clientgoscheme.AddToScheme(scheme))
	utilruntime.Must(v1alpha1.AddToScheme(scheme))
}

func main() {
	var metricsAddr string
	var probeAddr string
	var enableLeaderElection bool
	var showVersion bool

	// Static URL mode
	var baseURL string

	// Workload discovery mode
	var stsName string
	var deployName string
	var podName string
	var namespace string
	var stsServiceName string
	var port int
	var urlScheme string
	var strategy string
	var discoveryMode string
	var healthPath string
	var workloadKind string

	// Helm release discovery mode
	var helmRelease string

	flag.BoolVar(&showVersion, "version", false, "Print version information and exit")
	flag.StringVar(&metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
	flag.StringVar(&probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
	flag.BoolVar(&enableLeaderElection, "leader-elect", false, "Enable leader election for controller manager. Enabling this will ensure there is only one active controller manager.")

	// Static URL mode flags
	flag.StringVar(&baseURL, "base-url", "", "Base URL of the REST API (static mode)")

	// Workload discovery mode flags
	flag.StringVar(&stsName, "statefulset-name", "", "Name of the StatefulSet to discover endpoints from")
	flag.StringVar(&deployName, "deployment-name", "", "Name of the Deployment to discover endpoints from")
	flag.StringVar(&podName, "pod-name", "", "Name of a specific pod to target directly")
	flag.StringVar(&namespace, "namespace", "", "Namespace of the workload (defaults to operator namespace)")
	flag.StringVar(&stsServiceName, "service", "", "Headless service name for DNS discovery (StatefulSet only)")
	flag.IntVar(&port, "port", 8080, "Port number for REST API on pods")
	flag.StringVar(&urlScheme, "scheme", "http", "URL scheme (http or https)")
	flag.StringVar(&strategy, "strategy", "round-robin", "Endpoint selection strategy: round-robin, leader-only, any-healthy, all-healthy, by-ordinal")
	flag.StringVar(&discoveryMode, "discovery-mode", "", "Discovery mode: dns or pod-ip (defaults to dns for StatefulSet, pod-ip for Deployment)")
	flag.StringVar(&healthPath, "health-path", "/health", "Health check path (empty to disable)")
	flag.StringVar(&workloadKind, "workload-kind", "auto", "Workload type: statefulset, deployment, or auto")

	// Helm release discovery mode flags
	flag.StringVar(&helmRelease, "helm-release", "", "Helm release name to discover workload from (auto-detects StatefulSet or Deployment)")

	opts := zap.Options{Development: true}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()

	if showVersion {
		fmt.Printf("petstore-operator %s\n", version)
		fmt.Printf("  commit:    %s\n", commit)
		fmt.Printf("  built:     %s\n", date)
		fmt.Printf("  generator: %s\n", generatorVersion)
		os.Exit(0)
	}

	ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))

	// Log version information at startup
	setupLog.Info("starting petstore-operator",
		"version", version,
		"commit", commit,
		"built", date,
		"generator", generatorVersion)

	// Initialize OpenTelemetry (configured via environment variables)
	ctx := context.Background()
	otelProvider, err := telemetry.InitProviderFromEnv(ctx, "petstore-operator", version)
	if err != nil {
		setupLog.Error(err, "failed to initialize OpenTelemetry")
		os.Exit(1)
	}
	if otelProvider != nil {
		defer func() {
			shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()
			if err := otelProvider.Shutdown(shutdownCtx); err != nil {
				setupLog.Error(err, "failed to shutdown OpenTelemetry")
			}
		}()
		setupLog.Info("OpenTelemetry initialized", "endpoint", os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT"))
	}

	// Check environment variables as fallback
	if baseURL == "" {
		baseURL = os.Getenv("REST_API_BASE_URL")
	}
	if stsName == "" {
		stsName = os.Getenv("STATEFULSET_NAME")
	}
	if deployName == "" {
		deployName = os.Getenv("DEPLOYMENT_NAME")
	}
	if podName == "" {
		podName = os.Getenv("POD_NAME")
	}
	if helmRelease == "" {
		helmRelease = os.Getenv("HELM_RELEASE")
	}
	if namespace == "" {
		namespace = os.Getenv("WORKLOAD_NAMESPACE")
		if namespace == "" {
			// Try to get from downward API
			if ns, err := os.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace"); err == nil {
				namespace = string(ns)
			}
		}
	}
	if stsServiceName == "" {
		stsServiceName = os.Getenv("SERVICE_NAME")
	}

	// Check if global endpoint configuration is provided
	useWorkloadDiscovery := stsName != "" || deployName != "" || podName != "" || helmRelease != ""
	hasGlobalConfig := useWorkloadDiscovery || baseURL != ""

	if !hasGlobalConfig {
		setupLog.Info("No global endpoint configuration provided - CRs must specify targetBaseURL, targetPod, targetHelmRelease, targetStatefulSet, or targetDeployment")
	}

	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme:                 scheme,
		HealthProbeBindAddress: probeAddr,
		LeaderElection:         enableLeaderElection,
		LeaderElectionID:       "petstore.petstore.example.com",
	})
	if err != nil {
		setupLog.Error(err, "unable to start manager")
		os.Exit(1)
	}

	// Create HTTP client with OpenTelemetry instrumentation
	httpClient := &http.Client{
		Timeout:   30 * time.Second,
		Transport: otelhttp.NewTransport(http.DefaultTransport),
	}

	// Only default service name if StatefulSet name is explicitly provided
	if stsServiceName == "" && stsName != "" {
		stsServiceName = stsName
	}

	// Always create endpoint resolver for per-CR targeting support
	cfg := endpoint.Config{
		StatefulSetName: stsName,
		DeploymentName:  deployName,
		PodName:         podName,
		Namespace:       namespace,
		HelmRelease:     helmRelease,
		WorkloadKind:    endpoint.WorkloadKind(workloadKind),
		ServiceName:     stsServiceName,
		Port:            port,
		Scheme:          urlScheme,
		Strategy:        endpoint.Strategy(strategy),
		DiscoveryMode:   endpoint.DiscoveryMode(discoveryMode),
		HealthCheckPath: healthPath,
	}

	resolver := endpoint.NewResolver(mgr.GetClient(), cfg)

	// Start resolver's background refresh only if global workload discovery is configured
	// (not needed for pod-name mode since we target a specific pod)
	if useWorkloadDiscovery && podName == "" {
		if err := resolver.Start(ctx); err != nil {
			setupLog.Error(err, "unable to start endpoint resolver")
			os.Exit(1)
		}

		if helmRelease != "" {
			setupLog.Info("Using Helm release endpoint discovery",
				"helmRelease", helmRelease,
				"namespace", namespace,
				"workloadKind", workloadKind,
				"strategy", strategy,
				"discovery", discoveryMode)
		} else if deployName != "" {
			setupLog.Info("Using Deployment endpoint discovery",
				"deployment", deployName,
				"namespace", namespace,
				"strategy", strategy)
		} else {
			setupLog.Info("Using StatefulSet endpoint discovery",
				"statefulset", stsName,
				"namespace", namespace,
				"strategy", strategy,
				"discovery", discoveryMode)
		}
	} else if podName != "" {
		setupLog.Info("Using pod endpoint discovery",
			"pod", podName,
			"namespace", namespace)
	} else if baseURL != "" {
		setupLog.Info("Using static base URL", "url", baseURL)
	}

	if err = (&controller.OrderReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Order")
		os.Exit(1)
	}

	if err = (&controller.PetReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Pet")
		os.Exit(1)
	}

	if err = (&controller.UserReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "User")
		os.Exit(1)
	}

	if err = (&controller.PetFindbystatusQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "PetFindbystatusQuery")
		os.Exit(1)
	}

	if err = (&controller.PetFindbytagsQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "PetFindbytagsQuery")
		os.Exit(1)
	}

	if err = (&controller.StoreInventoryQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "StoreInventoryQuery")
		os.Exit(1)
	}

	if err = (&controller.UserLoginQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "UserLoginQuery")
		os.Exit(1)
	}

	if err = (&controller.UserLogoutQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "UserLogoutQuery")
		os.Exit(1)
	}

	if err = (&controller.PetUploadimageActionReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "PetUploadimageAction")
		os.Exit(1)
	}

	if err = (&controller.UserCreatewithlistActionReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "UserCreatewithlistAction")
		os.Exit(1)
	}

	// Setup aggregate controller (read-only, no HTTP client needed)
	if err = (&controller.PetstoreAggregateReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "PetstoreAggregate")
		os.Exit(1)
	}
	// Setup bundle controller (creates child CRs, no HTTP client needed directly)
	if err = (&controller.PetstoreBundleReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "PetstoreBundle")
		os.Exit(1)
	}

	if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil {
		setupLog.Error(err, "unable to set up health check")
		os.Exit(1)
	}
	if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil {
		setupLog.Error(err, "unable to set up ready check")
		os.Exit(1)
	}

	setupLog.Info("starting manager")
	if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {
		setupLog.Error(err, "problem running manager")
		os.Exit(1)
	}
}
