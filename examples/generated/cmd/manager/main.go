/*
Copyright 2026 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package main

import (
	"context"
	"flag"
	"net/http"
	"os"
	"time"

	"k8s.io/apimachinery/pkg/runtime"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/healthz"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"

	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
	"github.com/bluecontainer/petstore-operator/internal/controller"
)

var (
	scheme   = runtime.NewScheme()
	setupLog = ctrl.Log.WithName("setup")
)

func init() {
	utilruntime.Must(clientgoscheme.AddToScheme(scheme))
	utilruntime.Must(v1alpha1.AddToScheme(scheme))
}

func main() {
	var metricsAddr string
	var probeAddr string

	// Static URL mode
	var baseURL string

	// Workload discovery mode
	var stsName string
	var deployName string
	var namespace string
	var stsServiceName string
	var port int
	var urlScheme string
	var strategy string
	var discoveryMode string
	var healthPath string
	var workloadKind string

	// Helm release discovery mode
	var helmRelease string

	flag.StringVar(&metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
	flag.StringVar(&probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")

	// Static URL mode flags
	flag.StringVar(&baseURL, "base-url", "", "Base URL of the REST API (static mode)")

	// Workload discovery mode flags
	flag.StringVar(&stsName, "statefulset-name", "", "Name of the StatefulSet to discover endpoints from")
	flag.StringVar(&deployName, "deployment-name", "", "Name of the Deployment to discover endpoints from")
	flag.StringVar(&namespace, "namespace", "", "Namespace of the workload (defaults to operator namespace)")
	flag.StringVar(&stsServiceName, "service", "", "Headless service name for DNS discovery (StatefulSet only)")
	flag.IntVar(&port, "port", 8080, "Port number for REST API on pods")
	flag.StringVar(&urlScheme, "scheme", "http", "URL scheme (http or https)")
	flag.StringVar(&strategy, "strategy", "round-robin", "Endpoint selection strategy: round-robin, leader-only, any-healthy, all-healthy, by-ordinal")
	flag.StringVar(&discoveryMode, "discovery-mode", "", "Discovery mode: dns or pod-ip (defaults to dns for StatefulSet, pod-ip for Deployment)")
	flag.StringVar(&healthPath, "health-path", "/health", "Health check path (empty to disable)")
	flag.StringVar(&workloadKind, "workload-kind", "auto", "Workload type: statefulset, deployment, or auto")

	// Helm release discovery mode flags
	flag.StringVar(&helmRelease, "helm-release", "", "Helm release name to discover workload from (auto-detects StatefulSet or Deployment)")

	opts := zap.Options{Development: true}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()

	ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))

	// Check environment variables as fallback
	if baseURL == "" {
		baseURL = os.Getenv("REST_API_BASE_URL")
	}
	if stsName == "" {
		stsName = os.Getenv("STATEFULSET_NAME")
	}
	if deployName == "" {
		deployName = os.Getenv("DEPLOYMENT_NAME")
	}
	if helmRelease == "" {
		helmRelease = os.Getenv("HELM_RELEASE")
	}
	if namespace == "" {
		namespace = os.Getenv("WORKLOAD_NAMESPACE")
		if namespace == "" {
			// Try to get from downward API
			if ns, err := os.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace"); err == nil {
				namespace = string(ns)
			}
		}
	}
	if stsServiceName == "" {
		stsServiceName = os.Getenv("SERVICE_NAME")
	}

	// Validate configuration - need either static URL, StatefulSet name, Deployment name, or Helm release
	useWorkloadDiscovery := stsName != "" || deployName != "" || helmRelease != ""
	if !useWorkloadDiscovery && baseURL == "" {
		setupLog.Error(nil, "one of --base-url, --statefulset-name, --deployment-name, or --helm-release is required")
		os.Exit(1)
	}

	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme:                 scheme,
		HealthProbeBindAddress: probeAddr,
	})
	if err != nil {
		setupLog.Error(err, "unable to start manager")
		os.Exit(1)
	}

	httpClient := &http.Client{Timeout: 30 * time.Second}

	// Set up endpoint resolver if using workload discovery mode
	var resolver *endpoint.Resolver
	if useWorkloadDiscovery {
		// Only default service name if StatefulSet name is explicitly provided
		if stsServiceName == "" && stsName != "" {
			stsServiceName = stsName
		}

		cfg := endpoint.Config{
			StatefulSetName: stsName,
			DeploymentName:  deployName,
			Namespace:       namespace,
			HelmRelease:     helmRelease,
			WorkloadKind:    endpoint.WorkloadKind(workloadKind),
			ServiceName:     stsServiceName,
			Port:            port,
			Scheme:          urlScheme,
			Strategy:        endpoint.Strategy(strategy),
			DiscoveryMode:   endpoint.DiscoveryMode(discoveryMode),
			HealthCheckPath: healthPath,
		}

		resolver = endpoint.NewResolver(mgr.GetClient(), cfg)

		// Start the resolver
		ctx := context.Background()
		if err := resolver.Start(ctx); err != nil {
			setupLog.Error(err, "unable to start endpoint resolver")
			os.Exit(1)
		}

		if helmRelease != "" {
			setupLog.Info("Using Helm release endpoint discovery",
				"helmRelease", helmRelease,
				"namespace", namespace,
				"workloadKind", workloadKind,
				"strategy", strategy,
				"discovery", discoveryMode)
		} else if deployName != "" {
			setupLog.Info("Using Deployment endpoint discovery",
				"deployment", deployName,
				"namespace", namespace,
				"strategy", strategy)
		} else {
			setupLog.Info("Using StatefulSet endpoint discovery",
				"statefulset", stsName,
				"namespace", namespace,
				"strategy", strategy,
				"discovery", discoveryMode)
		}
	} else {
		setupLog.Info("Using static base URL", "url", baseURL)
	}

	if err = (&controller.OrderReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Order")
		os.Exit(1)
	}

	if err = (&controller.PetReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "Pet")
		os.Exit(1)
	}

	if err = (&controller.UserReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "User")
		os.Exit(1)
	}

	if err = (&controller.PetFindbystatusQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "PetFindbystatusQuery")
		os.Exit(1)
	}

	if err = (&controller.PetFindbytagsQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "PetFindbytagsQuery")
		os.Exit(1)
	}

	if err = (&controller.StoreInventoryQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "StoreInventoryQuery")
		os.Exit(1)
	}

	if err = (&controller.UserLoginQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "UserLoginQuery")
		os.Exit(1)
	}

	if err = (&controller.UserLogoutQueryReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "UserLogoutQuery")
		os.Exit(1)
	}

	if err = (&controller.PetUploadimageActionReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "PetUploadimageAction")
		os.Exit(1)
	}

	if err = (&controller.UserCreatewithlistActionReconciler{
		Client:           mgr.GetClient(),
		Scheme:           mgr.GetScheme(),
		HTTPClient:       httpClient,
		EndpointResolver: resolver,
		BaseURL:          baseURL,
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "UserCreatewithlistAction")
		os.Exit(1)
	}

	if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil {
		setupLog.Error(err, "unable to set up health check")
		os.Exit(1)
	}
	if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil {
		setupLog.Error(err, "unable to set up ready check")
		os.Exit(1)
	}

	setupLog.Info("starting manager")
	if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {
		setupLog.Error(err, "problem running manager")
		os.Exit(1)
	}
}
