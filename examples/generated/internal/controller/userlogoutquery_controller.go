/*
Copyright 2026 Generated by openapi-operator-gen v0.0.10-18-g2510b7b-dirty.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	"github.com/bluecontainer/openapi-operator-gen/pkg/runtime"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

var (
	userlogoutqueryTracer = otel.Tracer("github.com/bluecontainer/petstore-operator/controller/userlogoutquery")
	userlogoutqueryMeter  = otel.Meter("github.com/bluecontainer/petstore-operator/controller/userlogoutquery")

	userlogoutqueryReconcileTotal    metric.Int64Counter
	userlogoutqueryReconcileDuration metric.Float64Histogram
	userlogoutqueryQueryTotal        metric.Int64Counter
	userlogoutqueryQueryDuration     metric.Float64Histogram
)

func init() {
	var err error

	userlogoutqueryReconcileTotal, err = userlogoutqueryMeter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	userlogoutqueryReconcileDuration, err = userlogoutqueryMeter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	userlogoutqueryQueryTotal, err = userlogoutqueryMeter.Int64Counter(
		"query_total",
		metric.WithDescription("Total number of queries executed"),
		metric.WithUnit("{query}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	userlogoutqueryQueryDuration, err = userlogoutqueryMeter.Float64Histogram(
		"query_duration_seconds",
		metric.WithDescription("Duration of query execution in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
	userlogoutqueryFinalizer = "petstore.example.com/finalizer"
)

// UserLogoutQueryReconciler reconciles a UserLogoutQuery query object
type UserLogoutQueryReconciler struct {
	client.Client
	Scheme           *k8sruntime.Scheme
	HTTPClient       *http.Client
	EndpointResolver *endpoint.Resolver
	// BaseURL is used when EndpointResolver is nil (static URL mode)
	BaseURL string
	// BaseURLs is used for fan-out mode (writes to all URLs, reads use first success)
	BaseURLs []string
}

// +kubebuilder:rbac:groups=petstore.example.com,resources=userlogoutqueries,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=userlogoutqueries/status,verbs=get;update;patch

// Reconcile executes the query and updates the status with results
func (r *UserLogoutQueryReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	ctx, span := userlogoutqueryTracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "UserLogoutQuery"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	userlogoutqueryReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	userlogoutqueryReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

func (r *UserLogoutQueryReconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the UserLogoutQuery instance
	instance := &v1alpha1.UserLogoutQuery{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("UserLogoutQuery resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get UserLogoutQuery")
		return ctrl.Result{}, err
	}

	// Check if paused
	if instance.Spec.Paused {
		r.updateStatus(ctx, instance, "Paused", "Reconciliation paused", 0)
		return ctrl.Result{}, nil
	}

	// Determine if query should be executed
	shouldExecute := false
	var requeueAfter time.Duration

	if instance.Status.State == "" || instance.Status.State == "Pending" {
		// First execution
		shouldExecute = true
	} else if instance.Status.State == "Queried" || instance.Status.State == "Failed" {
		// Check if spec changed (always re-execute on spec change)
		if instance.Status.ObservedGeneration != instance.Generation {
			logger.Info("Spec changed, re-executing query")
			shouldExecute = true
		} else if instance.Spec.ExecutionInterval != nil && instance.Spec.ExecutionInterval.Duration > 0 {
			// Check if re-execution interval has elapsed
			if instance.Status.LastExecutionTime == nil {
				// Should not happen, but handle gracefully
				shouldExecute = true
			} else {
				elapsed := time.Since(instance.Status.LastExecutionTime.Time)
				interval := instance.Spec.ExecutionInterval.Duration

				if elapsed >= interval {
					logger.Info("Query interval elapsed, re-executing",
						"interval", interval, "elapsed", elapsed)
					shouldExecute = true
				} else {
					// Schedule next execution
					requeueAfter = interval - elapsed
					logger.V(1).Info("Scheduling next query execution", "requeueAfter", requeueAfter)
				}
			}
		} else {
			// No interval set - one-shot mode, already executed
			logger.V(1).Info("Query already executed and no interval set (one-shot mode), skipping")
			return ctrl.Result{}, nil
		}
	}

	if !shouldExecute {
		// Not time to execute yet, requeue for next interval
		return ctrl.Result{RequeueAfter: requeueAfter}, nil
	}

	// Execute the query
	if err := r.executeQuery(ctx, instance); err != nil {
		// On error, still schedule next re-execution if interval is set
		if instance.Spec.ExecutionInterval != nil && instance.Spec.ExecutionInterval.Duration > 0 {
			return ctrl.Result{RequeueAfter: instance.Spec.ExecutionInterval.Duration}, nil
		}
		return ctrl.Result{}, nil
	}

	// After successful execution, schedule next re-execution if interval is set
	if instance.Spec.ExecutionInterval != nil && instance.Spec.ExecutionInterval.Duration > 0 {
		return ctrl.Result{RequeueAfter: instance.Spec.ExecutionInterval.Duration}, nil
	}

	return ctrl.Result{}, nil
}

func (r *UserLogoutQueryReconciler) getBaseURL(ctx context.Context) (string, error) {
	// Try static BaseURL first
	if r.BaseURL != "" {
		return r.BaseURL, nil
	}
	// Try global endpoint resolver
	if r.EndpointResolver != nil {
		url, err := r.EndpointResolver.GetEndpoint()
		if err == nil {
			return url, nil
		}
	}
	return "", fmt.Errorf("no endpoint configured: set global endpoint (--base-url, --statefulset-name, --deployment-name, or --helm-release) or specify per-CR targeting (target.helmRelease, target.statefulSet, or target.deployment)")
}

func (r *UserLogoutQueryReconciler) getBaseURLByOrdinal(ctx context.Context, ordinal *int32) (string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		if ordinal == nil {
			return "", fmt.Errorf("target.podOrdinal is required when using by-ordinal strategy")
		}
		return r.EndpointResolver.GetEndpointByOrdinal(int(*ordinal))
	}
	return r.getBaseURL(ctx)
}

// resolveBaseURL determines the base URL to use for API requests based on CR targeting fields
func (r *UserLogoutQueryReconciler) resolveBaseURL(ctx context.Context, instance *v1alpha1.UserLogoutQuery) (string, error) {
	target := instance.Spec.Target

	// Per-CR static base URL takes highest priority
	if target != nil && target.BaseURL != "" {
		return target.BaseURL, nil
	}

	// Per-CR static base URLs array - return first URL for single operations
	if target != nil && len(target.BaseURLs) > 0 {
		return target.BaseURLs[0], nil
	}

	// Global static base URLs (from --base-urls flag or REST_API_BASE_URLS env var)
	// Return first URL for single operations
	if len(r.BaseURLs) > 0 {
		return r.BaseURLs[0], nil
	}

	if r.EndpointResolver != nil {
		namespace := instance.Namespace
		if target != nil && target.Namespace != "" {
			namespace = target.Namespace
		}

		// Per-CR pod targeting
		if target != nil && target.Pod != "" {
			return r.EndpointResolver.GetEndpointForPod(ctx, target.Pod, namespace)
		}

		if target != nil && target.HelmRelease != "" {
			var podOrdinal *int32
			if target != nil {
				podOrdinal = target.PodOrdinal
			}
			// Build narrowing options from co-specified StatefulSet/Deployment/Labels
			var opts *endpoint.HelmReleaseDiscoveryOptions
			if target.StatefulSet != "" || target.Deployment != "" || len(target.Labels) > 0 {
				opts = &endpoint.HelmReleaseDiscoveryOptions{
					StatefulSetName: target.StatefulSet,
					DeploymentName:  target.Deployment,
					Labels:          target.Labels,
				}
			}
			return r.EndpointResolver.GetEndpointForHelmRelease(ctx, target.HelmRelease, namespace, podOrdinal, opts)
		}

		if target != nil && target.StatefulSet != "" {
			var podOrdinal *int32
			if target != nil {
				podOrdinal = target.PodOrdinal
			}
			return r.EndpointResolver.GetEndpointForStatefulSet(ctx, target.StatefulSet, namespace, podOrdinal)
		}

		if target != nil && target.Deployment != "" {
			return r.EndpointResolver.GetEndpointForDeployment(ctx, target.Deployment, namespace)
		}

		// Global pod-name targeting (from operator flags)
		if r.EndpointResolver.IsPodConfigured() {
			return r.EndpointResolver.GetEndpointForPod(ctx, r.EndpointResolver.GetConfiguredPodName(), namespace)
		}

		if r.EndpointResolver.IsByOrdinalStrategy() {
			var podOrdinal *int32
			if target != nil {
				podOrdinal = target.PodOrdinal
			}
			return r.getBaseURLByOrdinal(ctx, podOrdinal)
		}
	}

	return r.getBaseURL(ctx)
}

// resolveAllHealthyEndpoints returns all healthy endpoint URLs based on CR targeting fields.
// This is used for all-healthy strategy fan-out operations.
func (r *UserLogoutQueryReconciler) resolveAllHealthyEndpoints(ctx context.Context, instance *v1alpha1.UserLogoutQuery) ([]string, error) {
	target := instance.Spec.Target

	// Per-CR static base URLs array takes highest priority (fan-out to all)
	if target != nil && len(target.BaseURLs) > 0 {
		return target.BaseURLs, nil
	}

	// Per-CR static base URL (single endpoint)
	if target != nil && target.BaseURL != "" {
		return []string{target.BaseURL}, nil
	}

	// Global static base URLs (from --base-urls flag or REST_API_BASE_URLS env var)
	if len(r.BaseURLs) > 0 {
		return r.BaseURLs, nil
	}

	if r.EndpointResolver == nil {
		// No resolver - return single static URL
		url, err := r.getBaseURL(ctx)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	namespace := instance.Namespace
	if target != nil && target.Namespace != "" {
		namespace = target.Namespace
	}

	// Per-CR pod targeting (returns single endpoint)
	if target != nil && target.Pod != "" {
		url, err := r.EndpointResolver.GetEndpointForPod(ctx, target.Pod, namespace)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	// Per-CR Helm release targeting
	if target != nil && target.HelmRelease != "" {
		var opts *endpoint.HelmReleaseDiscoveryOptions
		if target.StatefulSet != "" || target.Deployment != "" || len(target.Labels) > 0 {
			opts = &endpoint.HelmReleaseDiscoveryOptions{
				StatefulSetName: target.StatefulSet,
				DeploymentName:  target.Deployment,
				Labels:          target.Labels,
			}
		}
		return r.EndpointResolver.GetAllEndpointsForHelmRelease(ctx, target.HelmRelease, namespace, opts)
	}

	// Per-CR StatefulSet targeting (standalone, without Helm release)
	if target != nil && target.StatefulSet != "" {
		return r.EndpointResolver.GetAllEndpointsForStatefulSet(ctx, target.StatefulSet, namespace)
	}

	// Per-CR Deployment targeting (standalone, without Helm release)
	if target != nil && target.Deployment != "" {
		return r.EndpointResolver.GetAllEndpointsForDeployment(ctx, target.Deployment, namespace)
	}

	// Global pod-name targeting (returns single endpoint)
	if r.EndpointResolver.IsPodConfigured() {
		url, err := r.EndpointResolver.GetEndpointForPod(ctx, r.EndpointResolver.GetConfiguredPodName(), namespace)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	// Fall back to global all-healthy endpoints
	return r.EndpointResolver.GetAllHealthyEndpoints()
}

// buildQueryURL builds the query URL from the spec parameters
func (r *UserLogoutQueryReconciler) buildQueryURL(baseURL string, instance *v1alpha1.UserLogoutQuery) string {
	// Build URL with path parameters substituted
	builder := runtime.NewURLBuilder("/user/logout")

	queryURL := builder.Build(baseURL)

	return queryURL
}

// executeQueryToEndpoint executes the query against a single endpoint
func (r *UserLogoutQueryReconciler) executeQueryToEndpoint(ctx context.Context, instance *v1alpha1.UserLogoutQuery, baseURL string) ([]byte, int, error) {
	ctx, span := userlogoutqueryTracer.Start(ctx, "Query",
		trace.WithAttributes(
			attribute.String("http.method", "GET"),
			attribute.String("endpoint.url", baseURL),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	queryURL := r.buildQueryURL(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", queryURL))

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL, nil)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, 0, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")

	logger.Info("Executing query", "url", queryURL)
	logger.V(1).Info("REST API request", "method", "GET", "url", queryURL)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordQueryMetrics(ctx, "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, 0, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordQueryMetrics(ctx, "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, 0, fmt.Errorf("failed to read response: %w", err)
	}

	logger.V(1).Info("REST API response", "method", "GET", "url", queryURL, "statusCode", resp.StatusCode, "body", string(body))

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordQueryMetrics(ctx, "error", resp.StatusCode, duration)
		err := fmt.Errorf("query failed: %s - %s", resp.Status, string(body))
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, resp.StatusCode, err
	}

	r.recordQueryMetrics(ctx, "success", resp.StatusCode, duration)
	return body, resp.StatusCode, nil
}

func (r *UserLogoutQueryReconciler) recordQueryMetrics(ctx context.Context, status string, statusCode int, duration float64) {
	userlogoutqueryQueryTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.Int("status_code", statusCode),
		))
	userlogoutqueryQueryDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
		))
}
// countResults attempts to count results in the response
func (r *UserLogoutQueryReconciler) countResults(body []byte) int {
	// Try to parse as array
	var arr []interface{}
	if err := json.Unmarshal(body, &arr); err == nil {
		return len(arr)
	}

	// Try to parse as object with items/data/results field
	var obj map[string]interface{}
	if err := json.Unmarshal(body, &obj); err == nil {
		for _, key := range []string{"items", "data", "results", "content"} {
			if items, ok := obj[key].([]interface{}); ok {
				return len(items)
			}
		}
		// If it's an object, count as 1 result
		return 1
	}

	return 0
}

func (r *UserLogoutQueryReconciler) executeQuery(ctx context.Context, instance *v1alpha1.UserLogoutQuery) error {
	logger := log.FromContext(ctx)
	now := metav1.Now()

	// Check if fan-out is needed (multiple endpoints from all-healthy strategy, per-CR baseURLs, or global baseURLs)
	target := instance.Spec.Target
	usesFanOut := (r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy()) ||
		(target != nil && len(target.BaseURLs) > 1) ||
		len(r.BaseURLs) > 1
	if usesFanOut {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			r.updateStatus(ctx, instance, "Failed", fmt.Sprintf("failed to get all healthy endpoints: %v", err), 0)
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - collect responses from all
			responses := make(map[string]v1alpha1.UserLogoutQueryEndpointResponse)
			var firstSuccessResp *v1alpha1.UserLogoutQueryEndpointResponse
			var firstResultCount int
			successCount := 0

			for _, baseURL := range baseURLs {
				endpointResp := v1alpha1.UserLogoutQueryEndpointResponse{
					LastUpdated: &now,
				}

				body, statusCode, err := r.executeQueryToEndpoint(ctx, instance, baseURL)
				if err != nil {
					endpointResp.Success = false
					endpointResp.StatusCode = statusCode
					endpointResp.Error = err.Error()
					logger.Info("Query failed for endpoint", "endpoint", baseURL, "error", err)
				} else {
					endpointResp.Success = true
					endpointResp.StatusCode = statusCode
					endpointResp.Data = &k8sruntime.RawExtension{Raw: body}
					successCount++
					resultCount := r.countResults(body)
					if firstSuccessResp == nil {
						respCopy := endpointResp
						firstSuccessResp = &respCopy
						firstResultCount = resultCount
					}
					logger.Info("Query succeeded for endpoint", "endpoint", baseURL, "resultCount", resultCount)
				}

				responses[baseURL] = endpointResp
			}

			// Update status with all responses
			instance.Status.Responses = responses
			instance.Status.LastQueryTime = &now

			// Set Results to first successful response
			if firstSuccessResp != nil {
				instance.Status.Results = firstSuccessResp
				instance.Status.ResultCount = firstResultCount
			}

			if successCount == 0 {
				r.updateStatus(ctx, instance, "Failed", fmt.Sprintf("Query failed on all %d endpoints", len(baseURLs)), 0)
				return fmt.Errorf("query failed on all endpoints")
			}

			message := fmt.Sprintf("Query executed on %d/%d endpoints", successCount, len(baseURLs))
			r.updateStatus(ctx, instance, "Queried", message, instance.Status.ResultCount)
			return nil
		}
	}

	// Single endpoint case
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		r.updateStatus(ctx, instance, "Failed", fmt.Sprintf("failed to resolve base URL: %v", err), 0)
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	body, statusCode, err := r.executeQueryToEndpoint(ctx, instance, baseURL)

	// Build EndpointResponse for Results
	endpointResp := v1alpha1.UserLogoutQueryEndpointResponse{
		LastUpdated: &now,
		StatusCode:  statusCode,
	}

	if err != nil {
		endpointResp.Success = false
		endpointResp.Error = err.Error()
		instance.Status.Results = &endpointResp
		instance.Status.LastQueryTime = &now
		instance.Status.Responses = nil
		r.updateStatus(ctx, instance, "Failed", err.Error(), 0)
		return err
	}

	endpointResp.Success = true
	endpointResp.Data = &k8sruntime.RawExtension{Raw: body}
	resultCount := r.countResults(body)

	// Update status with results
	instance.Status.Results = &endpointResp
	instance.Status.LastQueryTime = &now
	instance.Status.Responses = nil // Clear multi-endpoint responses
	r.updateStatus(ctx, instance, "Queried", "Query executed successfully", resultCount)
	return nil
}

func (r *UserLogoutQueryReconciler) updateStatus(ctx context.Context, instance *v1alpha1.UserLogoutQuery, state, message string, resultCount int) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	instance.Status.State = state
	instance.Status.Message = message
	instance.Status.ResultCount = resultCount
	instance.Status.ObservedGeneration = instance.Generation

	if instance.Status.LastQueryTime == nil {
		instance.Status.LastQueryTime = &now
	}

	// Track execution for one-shot/periodic support
	if state == "Queried" || state == "Failed" {
		instance.Status.LastExecutionTime = &now
		instance.Status.ExecutionCount++

		// Calculate next execution time if interval is configured
		if instance.Spec.ExecutionInterval != nil && instance.Spec.ExecutionInterval.Duration > 0 {
			nextTime := metav1.NewTime(now.Add(instance.Spec.ExecutionInterval.Duration))
			instance.Status.NextExecutionTime = &nextTime
		} else {
			// Clear next execution time for one-shot mode
			instance.Status.NextExecutionTime = nil
		}
	}

	// Update Ready condition
	readyCondition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Queried" {
		readyCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, readyCondition)

	// Update Reconciling condition (kstatus compatibility)
	// Reconciling=True when actively working, False/absent when done
	reconcilingCondition := metav1.Condition{
		Type:               "Reconciling",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Querying" || state == "Pending" {
		reconcilingCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, reconcilingCondition)

	// Update Stalled condition (kstatus compatibility)
	// Stalled=True when encountering errors, False/absent otherwise
	stalledCondition := metav1.Condition{
		Type:               "Stalled",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Failed" {
		stalledCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, stalledCondition)

	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *UserLogoutQueryReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.UserLogoutQuery{}).
		Complete(r)
}
