/*
Copyright 2026 Generated by openapi-operator-gen v0.0.9-23-g2e477da-dirty.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/util/retry"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	"github.com/bluecontainer/openapi-operator-gen/pkg/runtime"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

var (
	userTracer = otel.Tracer("github.com/bluecontainer/petstore-operator/controller/user")
	userMeter  = otel.Meter("github.com/bluecontainer/petstore-operator/controller/user")

	// Metrics
	userReconcileTotal    metric.Int64Counter
	userReconcileDuration metric.Float64Histogram
	userAPICallTotal      metric.Int64Counter
	userAPICallDuration   metric.Float64Histogram
	userDriftDetected     metric.Int64Counter
)

func init() {
	var err error

	userReconcileTotal, err = userMeter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	userReconcileDuration, err = userMeter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	userAPICallTotal, err = userMeter.Int64Counter(
		"api_call_total",
		metric.WithDescription("Total number of REST API calls"),
		metric.WithUnit("{call}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	userAPICallDuration, err = userMeter.Float64Histogram(
		"api_call_duration_seconds",
		metric.WithDescription("Duration of REST API calls in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	userDriftDetected, err = userMeter.Int64Counter(
		"drift_detected_total",
		metric.WithDescription("Total number of drift detections"),
		metric.WithUnit("{drift}"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
	userFinalizer    = "petstore.example.com/finalizer"
	userRequeueAfter = time.Second * 30
)

// APIError represents an error from the external REST API with status code information.
// This allows the controller to distinguish between retryable errors (5xx, network errors)
// and non-retryable errors (4xx client errors).
type UserAPIError struct {
	StatusCode int
	Status     string
	Body       string
	Method     string
	URL        string
}

func (e *UserAPIError) Error() string {
	return fmt.Sprintf("%s %s failed: %s - %s", e.Method, e.URL, e.Status, e.Body)
}

// IsRetryable returns true if the error is likely transient and worth retrying.
// 5xx errors and network errors are retryable; 4xx client errors are not.
func (e *UserAPIError) IsRetryable() bool {
	return e.StatusCode >= 500 || e.StatusCode == 0 // 0 means network error
}

// isUserAPIErrorRetryable checks if an error is a retryable API error.
// Returns true for non-API errors (network issues, etc.) and 5xx API errors.
// Returns false for 4xx client errors.
func isUserAPIErrorRetryable(err error) bool {
	if err == nil {
		return false
	}
	var apiErr *UserAPIError
	if ok := errors.As(err, &apiErr); ok {
		return apiErr.IsRetryable()
	}
	// Non-API errors (network, parsing, etc.) should be retried
	return true
}

// UserReconciler reconciles a User object
type UserReconciler struct {
	client.Client
	Scheme           *k8sruntime.Scheme
	HTTPClient       *http.Client
	EndpointResolver *endpoint.Resolver
	// BaseURL is used when EndpointResolver is nil (static URL mode)
	BaseURL string
}

// +kubebuilder:rbac:groups=petstore.example.com,resources=users,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=users/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=petstore.example.com,resources=users/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop
func (r *UserReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// Start tracing span
	ctx, span := userTracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "User"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	// Record metrics
	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	userReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	userReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

// reconcileInternal contains the actual reconciliation logic
func (r *UserReconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the User instance
	instance := &v1alpha1.User{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if k8serrors.IsNotFound(err) {
			logger.Info("User resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get User")
		return ctrl.Result{}, err
	}

	// Add resource attributes to current span
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("resource.externalID", r.getExternalID(instance)),
		attribute.Bool("resource.readOnly", instance.Spec.ReadOnly),
	)

	// Check if this is a read-only resource
	isReadOnly := instance.Spec.ReadOnly
	// Check if the resource is being deleted
	if instance.GetDeletionTimestamp() != nil {
		if controllerutil.ContainsFinalizer(instance, userFinalizer) {
			// Run finalization logic (skip for read-only resources)
			// Note: We log errors but still remove the finalizer to avoid blocking CR deletion
			if !isReadOnly {
				if err := r.finalizeResource(ctx, instance); err != nil {
					logger.Error(err, "Finalization failed, but proceeding with finalizer removal to allow CR deletion")
				}
			}

			// Remove finalizer (always, even if finalization failed)
			controllerutil.RemoveFinalizer(instance, userFinalizer)
			if err := r.Update(ctx, instance); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	// Handle read-only mode: only GET and update status
	if isReadOnly {
		if err := r.observeResource(ctx, instance); err != nil {
			r.updateStatus(ctx, instance, "Failed", err.Error())
			// For retryable errors (5xx, network errors), requeue after standard interval
			// For 4xx client errors, don't auto-retry as the request won't succeed without spec changes
			// Note: We don't return err to avoid controller-runtime's aggressive exponential backoff
			if isUserAPIErrorRetryable(err) {
				logger.Error(err, "Retryable error, will retry after interval")
				return ctrl.Result{RequeueAfter: userRequeueAfter}, nil
			}
			logger.Info("Non-retryable error (client error), not requeueing until spec changes", "error", err.Error())
			return ctrl.Result{}, nil
		}
		return ctrl.Result{RequeueAfter: userRequeueAfter}, nil
	}

	// Sync with REST API (with drift detection)
	if err := r.syncResource(ctx, instance); err != nil {
		// Update status to failed
		r.updateStatus(ctx, instance, "Failed", err.Error())
		// For retryable errors (5xx, network errors), requeue after standard interval
		// For 4xx client errors, don't auto-retry as the request won't succeed without spec changes
		// Note: We don't return err to avoid controller-runtime's aggressive exponential backoff
		if isUserAPIErrorRetryable(err) {
			logger.Error(err, "Retryable error, will retry after interval")
			return ctrl.Result{RequeueAfter: userRequeueAfter}, nil
		}
		logger.Info("Non-retryable error (client error), not requeueing until spec changes", "error", err.Error())
		return ctrl.Result{}, nil
	}
	// Add finalizer after successful sync (not before, to avoid blocking deletion if creation fails)
	// Use retry to handle conflicts from concurrent reconciliations
	err = retry.RetryOnConflict(retry.DefaultRetry, func() error {
		// Re-fetch the latest version
		if err := r.Get(ctx, req.NamespacedName, instance); err != nil {
			return err
		}
		if !controllerutil.ContainsFinalizer(instance, userFinalizer) {
			controllerutil.AddFinalizer(instance, userFinalizer)
			return r.Update(ctx, instance)
		}
		return nil
	})
	if err != nil {
		return ctrl.Result{}, err
	}

	return ctrl.Result{RequeueAfter: userRequeueAfter}, nil
}

func (r *UserReconciler) getBaseURL(ctx context.Context) (string, error) {
	// Try static BaseURL first
	if r.BaseURL != "" {
		return r.BaseURL, nil
	}
	// Try global endpoint resolver
	if r.EndpointResolver != nil {
		url, err := r.EndpointResolver.GetEndpoint()
		if err == nil {
			return url, nil
		}
	}
	return "", fmt.Errorf("no endpoint configured: set global endpoint (--base-url, --statefulset-name, --deployment-name, or --helm-release) or specify per-CR targeting (targetHelmRelease, targetStatefulSet, or targetDeployment)")
}

func (r *UserReconciler) getBaseURLByOrdinal(ctx context.Context, ordinal *int32) (string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		if ordinal == nil {
			return "", fmt.Errorf("targetPodOrdinal is required when using by-ordinal strategy")
		}
		return r.EndpointResolver.GetEndpointByOrdinal(int(*ordinal))
	}
	// Fall back to regular endpoint selection if not using by-ordinal strategy
	return r.getBaseURL(ctx)
}

// buildResourceURL builds the URL for resource operations with path and query parameters
// ResourcePath is the full path template with placeholders (e.g., /pet/{petId}, /classes/{className}/variables/{variableName})
// Path parameters are substituted from the spec fields
func (r *UserReconciler) buildResourceURL(baseURL string, instance *v1alpha1.User) string {
	builder := runtime.NewURLBuilder("/user/{username}")
	// Add path parameters from spec, with ExternalID fallback for the last path param
	if instance.Spec.Username != "" {
		builder.WithPathParam("username", instance.Spec.Username)
	} else if instance.Status.ExternalID != "" {
		// Fallback to ExternalID for the last path param (e.g., after POST returns ID)
		builder.WithPathParam("username", instance.Status.ExternalID)
	}

	return builder.Build(baseURL)
}

// buildResourceURLForCreate builds the URL for resource creation (POST) with query parameters only
func (r *UserReconciler) buildResourceURLForCreate(baseURL string, instance *v1alpha1.User) string {
	builder := runtime.NewURLBuilder("/user")

	return builder.BuildForCreate(baseURL)
}

// hasValidPathParams checks if all path parameters have valid (non-zero/non-empty) values.
// This is used to determine if we can perform GET operations on a resource.
// The last path parameter can use ExternalID as a fallback (e.g., when POST returns an ID).
func (r *UserReconciler) hasValidPathParams(instance *v1alpha1.User) bool {
	// Last path param can use ExternalID as fallback
	if instance.Spec.Username == "" && instance.Status.ExternalID == "" {
		return false
	}
	return true
}

// getExternalID returns the external ID to use for GET/PUT/DELETE operations.
// It returns ExternalID from status (for resources created by the controller).
func (r *UserReconciler) getExternalID(instance *v1alpha1.User) string {
	return instance.Status.ExternalID
}

// extractExternalIDFromResponse extracts the external ID from an API response.
// It looks for common ID field names (id, ID) and returns the value as a string.
// If no ID is found in the response, it falls back to the provided fallback value.
func (r *UserReconciler) extractExternalIDFromResponse(respData map[string]interface{}, fallback string) string {
	// Try common ID field names
	for _, idField := range []string{"id", "ID", "Id"} {
		if id, ok := respData[idField]; ok {
			switch v := id.(type) {
			case string:
				return v
			case float64:
				return fmt.Sprintf("%.0f", v)
			case int:
				return fmt.Sprintf("%d", v)
			case int64:
				return fmt.Sprintf("%d", v)
			}
		}
	}
	return fallback
}

// getResource performs a GET request to fetch the current state of the resource from the REST API.
// Returns the response body as a map, or nil if the resource doesn't exist (404).
func (r *UserReconciler) getResource(ctx context.Context, baseURL string, externalID string, instance *v1alpha1.User) (map[string]interface{}, []byte, error) {
	ctx, span := userTracer.Start(ctx, "GET",
		trace.WithAttributes(
			attribute.String("http.method", "GET"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", externalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURL(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to create GET request: %w", err)
	}
	req.Header.Set("Accept", "application/json")

	logger.Info("Getting resource", "url", url)
	logger.V(1).Info("REST API request", "method", "GET", "url", url)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "GET", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to execute GET request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "GET", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to read GET response: %w", err)
	}

	// 404 means resource doesn't exist
	if resp.StatusCode == http.StatusNotFound {
		r.recordAPICallMetrics(ctx, "GET", "not_found", resp.StatusCode, duration)
		logger.Info("Resource not found in external API", "externalID", externalID)
		return nil, nil, nil
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "GET", "error", resp.StatusCode, duration)
		apiErr := &UserAPIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "GET",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return nil, nil, apiErr
	}

	r.recordAPICallMetrics(ctx, "GET", "success", resp.StatusCode, duration)

	logger.V(1).Info("REST API response", "method", "GET", "url", url, "statusCode", resp.StatusCode, "body", string(body))

	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err != nil {
		return nil, body, fmt.Errorf("failed to parse GET response: %w", err)
	}

	return respData, body, nil
}

// recordAPICallMetrics records metrics for API calls
func (r *UserReconciler) recordAPICallMetrics(ctx context.Context, method, status string, statusCode int, duration float64) {
	userAPICallTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("method", method),
			attribute.String("status", status),
			attribute.Int("status_code", statusCode),
		))
	userAPICallDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("method", method),
			attribute.String("status", status),
		))
}

// compareSpecWithResponse compares the CR spec with the API response to detect drift.
// When mergeOnUpdate is enabled (the default), it compares what the merged result would be
// against the current API state. This means fields not specified in the CR spec won't cause
// drift because they would be preserved from the API response during a merge.
// Returns true if there is drift (spec differs from current state).
func (r *UserReconciler) compareSpecWithResponse(instance *v1alpha1.User, apiResponse map[string]interface{}) bool {
	// Marshal spec to JSON for comparison
	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return true // Assume drift on error
	}

	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return true // Assume drift on error
	}

	// Remove controller-specific fields from spec that aren't part of the API resource
	delete(specMap, "targetPodOrdinal")
	delete(specMap, "targetHelmRelease")
	delete(specMap, "targetStatefulSet")
	delete(specMap, "targetDeployment")
	delete(specMap, "targetPod")
	delete(specMap, "targetNamespace")
	delete(specMap, "targetBaseURL")
	delete(specMap, "readOnly")
	delete(specMap, "mergeOnUpdate")
	delete(specMap, "onDelete")

	// Check if mergeOnUpdate is enabled (default: true)
	mergeEnabled := instance.Spec.MergeOnUpdate == nil || *instance.Spec.MergeOnUpdate

	if mergeEnabled {
		// When mergeOnUpdate is enabled, we compare what the merged result would be.
		// Start with current API state and overlay the spec fields.
		// This means only fields explicitly set in the spec can cause drift.
		mergedState := make(map[string]interface{})
		for k, v := range apiResponse {
			mergedState[k] = v
		}
		for k, v := range specMap {
			// Skip empty maps and empty slices - these represent unset Go struct fields
			// that shouldn't overwrite API values (e.g., Category{} serializes as {} but
			// shouldn't replace the API's actual category value)
			if m, ok := v.(map[string]interface{}); ok && len(m) == 0 {
				continue
			}
			if s, ok := v.([]interface{}); ok && len(s) == 0 {
				continue
			}
			mergedState[k] = v
		}

		// Compare merged state with API response
		for key, mergedValue := range mergedState {
			apiValue, exists := apiResponse[key]
			if !exists {
				// Field exists in merged but not in API - this is drift (new field being added)
				if _, inSpec := specMap[key]; inSpec {
					return true
				}
				continue
			}
			if !r.valuesEqual(mergedValue, apiValue) {
				return true // Drift detected
			}
		}
	} else {
		// When mergeOnUpdate is disabled, compare spec directly with API response.
		// Only fields present in the spec are compared.
		for key, specValue := range specMap {
			apiValue, exists := apiResponse[key]
			if !exists {
				// Field exists in spec but not in API response - could be drift or API doesn't return this field
				continue
			}
			if !r.valuesEqual(specValue, apiValue) {
				return true // Drift detected
			}
		}
	}

	return false // No drift
}

// valuesEqual compares two values for equality, with special handling for timestamps.
// If both values are strings that can be parsed as timestamps (RFC3339 or similar),
// they are compared as time.Time values to handle format differences.
func (r *UserReconciler) valuesEqual(a, b interface{}) bool {
	// Fast path: direct equality
	if reflect.DeepEqual(a, b) {
		return true
	}

	// Check if both are strings that could be timestamps
	aStr, aIsStr := a.(string)
	bStr, bIsStr := b.(string)
	if aIsStr && bIsStr {
		// Try parsing as timestamps with various formats
		aTime, aErr := r.parseTimestamp(aStr)
		bTime, bErr := r.parseTimestamp(bStr)
		if aErr == nil && bErr == nil {
			// Both are valid timestamps - compare as time values
			return aTime.Equal(bTime)
		}
	}

	// Handle nested maps recursively
	aMap, aIsMap := a.(map[string]interface{})
	bMap, bIsMap := b.(map[string]interface{})
	if aIsMap && bIsMap {
		if len(aMap) != len(bMap) {
			return false
		}
		for k, aVal := range aMap {
			bVal, exists := bMap[k]
			if !exists || !r.valuesEqual(aVal, bVal) {
				return false
			}
		}
		return true
	}

	// Handle slices recursively
	aSlice, aIsSlice := a.([]interface{})
	bSlice, bIsSlice := b.([]interface{})
	if aIsSlice && bIsSlice {
		if len(aSlice) != len(bSlice) {
			return false
		}
		for i := range aSlice {
			if !r.valuesEqual(aSlice[i], bSlice[i]) {
				return false
			}
		}
		return true
	}

	// Handle numeric types (JSON can produce float64 for all numbers)
	aFloat, aIsFloat := r.toFloat64ForComparison(a)
	bFloat, bIsFloat := r.toFloat64ForComparison(b)
	if aIsFloat && bIsFloat {
		return aFloat == bFloat
	}

	// Default: not equal (already checked reflect.DeepEqual above)
	return false
}

// parseTimestamp attempts to parse a string as a timestamp using common formats.
func (r *UserReconciler) parseTimestamp(s string) (time.Time, error) {
	// Try RFC3339 first (most common)
	if t, err := time.Parse(time.RFC3339, s); err == nil {
		return t, nil
	}
	// Try RFC3339Nano (with nanoseconds)
	if t, err := time.Parse(time.RFC3339Nano, s); err == nil {
		return t, nil
	}
	// Try format with milliseconds and explicit offset (like "2026-01-24T00:24:42.000+00:00")
	if t, err := time.Parse("2006-01-02T15:04:05.000-07:00", s); err == nil {
		return t, nil
	}
	if t, err := time.Parse("2006-01-02T15:04:05.000Z07:00", s); err == nil {
		return t, nil
	}
	return time.Time{}, fmt.Errorf("not a recognized timestamp format: %s", s)
}

// toFloat64ForComparison attempts to convert a value to float64 for numeric comparison.
func (r *UserReconciler) toFloat64ForComparison(v interface{}) (float64, bool) {
	switch n := v.(type) {
	case float64:
		return n, true
	case float32:
		return float64(n), true
	case int:
		return float64(n), true
	case int64:
		return float64(n), true
	case int32:
		return float64(n), true
	}
	return 0, false
}

// observeResource performs a GET-only observation for read-only CRs.
func (r *UserReconciler) observeResource(ctx context.Context, instance *v1alpha1.User) error {
	logger := log.FromContext(ctx)
	externalID := r.getExternalID(instance)

	now := metav1.Now()

	// Check if using all-healthy strategy (fan out GET to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - collect responses from all
			responses := make(map[string]v1alpha1.UserEndpointResponse)
			successCount := 0
			var firstSuccessBody []byte

			for _, baseURL := range baseURLs {
				endpointResp := v1alpha1.UserEndpointResponse{
					LastUpdated: &now,
				}

				respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
				if err != nil {
					endpointResp.Success = false
					endpointResp.Error = err.Error()
					logger.Info("Failed to observe from endpoint", "endpoint", baseURL, "error", err)
				} else if respData == nil {
					endpointResp.Success = false
					endpointResp.StatusCode = 404
					endpointResp.Error = fmt.Sprintf("resource %s not found", externalID)
					logger.Info("Resource not found at endpoint", "endpoint", baseURL, "externalID", externalID)
				} else {
					endpointResp.Success = true
					endpointResp.StatusCode = 200
					endpointResp.Data = &k8sruntime.RawExtension{Raw: body}
					successCount++
					if firstSuccessBody == nil {
						firstSuccessBody = body
					}
					logger.Info("Successfully observed from endpoint", "endpoint", baseURL, "externalID", externalID)
				}

				responses[baseURL] = endpointResp
			}

			// Update status with all responses
			instance.Status.ExternalID = externalID
			instance.Status.Responses = responses
			instance.Status.LastGetTime = &now
			instance.Status.DriftDetected = false

			// Also set the single Response field with first success for backwards compatibility
			if firstSuccessBody != nil {
				instance.Status.Response = &v1alpha1.UserEndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: firstSuccessBody},
					LastUpdated: &now,
				}
			}

			if successCount == 0 {
				r.updateStatus(ctx, instance, "NotFound", fmt.Sprintf("Resource %s not found in any endpoint (%d endpoints queried)", externalID, len(baseURLs)))
				return nil
			}

			message := fmt.Sprintf("Successfully observed from %d/%d endpoints", successCount, len(baseURLs))
			logger.Info(message, "externalID", externalID)
			r.updateStatus(ctx, instance, "Observed", message)
			return nil
		}
	}

	// Single endpoint case - resolve URL and observe
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return err
	}

	respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
	if err != nil {
		return err
	}

	if respData == nil {
		r.updateStatus(ctx, instance, "NotFound", fmt.Sprintf("Resource %s not found in external API", externalID))
		return nil
	}

	// Update status with fetched data
	instance.Status.ExternalID = externalID
	instance.Status.Response = &v1alpha1.UserEndpointResponse{
		Success:     true,
		StatusCode:  200,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.LastGetTime = &now
	instance.Status.DriftDetected = false // No drift concept for read-only
	instance.Status.Responses = nil       // Clear multi-endpoint responses for single endpoint

	logger.Info("Successfully observed resource", "externalID", externalID)
	r.updateStatus(ctx, instance, "Observed", "Successfully fetched resource from REST API")
	return nil
}

// resolveBaseURL determines the base URL to use for API requests based on CR targeting fields.
func (r *UserReconciler) resolveBaseURL(ctx context.Context, instance *v1alpha1.User) (string, error) {
	// Per-CR static base URL takes highest priority
	if instance.Spec.TargetBaseURL != "" {
		return instance.Spec.TargetBaseURL, nil
	}

	if r.EndpointResolver != nil {
		namespace := instance.Spec.TargetNamespace
		if namespace == "" {
			namespace = instance.Namespace
		}

		// Per-CR pod targeting
		if instance.Spec.TargetPod != "" {
			return r.EndpointResolver.GetEndpointForPod(ctx, instance.Spec.TargetPod, namespace)
		}

		// Per-CR Helm release targeting
		if instance.Spec.TargetHelmRelease != "" {
			return r.EndpointResolver.GetEndpointForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace, instance.Spec.TargetPodOrdinal)
		}

		// Per-CR StatefulSet targeting
		if instance.Spec.TargetStatefulSet != "" {
			return r.EndpointResolver.GetEndpointForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace, instance.Spec.TargetPodOrdinal)
		}

		// Per-CR Deployment targeting
		if instance.Spec.TargetDeployment != "" {
			return r.EndpointResolver.GetEndpointForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
		}

		// Global pod-name targeting (from operator flags)
		if r.EndpointResolver.IsPodConfigured() {
			return r.EndpointResolver.GetEndpointForPod(ctx, r.EndpointResolver.GetConfiguredPodName(), namespace)
		}

		// By-ordinal strategy
		if r.EndpointResolver.IsByOrdinalStrategy() {
			return r.getBaseURLByOrdinal(ctx, instance.Spec.TargetPodOrdinal)
		}
	}

	return r.getBaseURL(ctx)
}

// resolveAllHealthyEndpoints returns all healthy endpoint URLs based on CR targeting fields.
// This is used for all-healthy strategy fan-out operations.
func (r *UserReconciler) resolveAllHealthyEndpoints(ctx context.Context, instance *v1alpha1.User) ([]string, error) {
	// Per-CR static base URL takes highest priority
	if instance.Spec.TargetBaseURL != "" {
		return []string{instance.Spec.TargetBaseURL}, nil
	}

	if r.EndpointResolver == nil {
		// No resolver - return single static URL
		url, err := r.getBaseURL(ctx)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	namespace := instance.Spec.TargetNamespace
	if namespace == "" {
		namespace = instance.Namespace
	}

	// Per-CR pod targeting (returns single endpoint)
	if instance.Spec.TargetPod != "" {
		url, err := r.EndpointResolver.GetEndpointForPod(ctx, instance.Spec.TargetPod, namespace)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	// Per-CR Helm release targeting
	if instance.Spec.TargetHelmRelease != "" {
		return r.EndpointResolver.GetAllEndpointsForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace)
	}

	// Per-CR StatefulSet targeting
	if instance.Spec.TargetStatefulSet != "" {
		return r.EndpointResolver.GetAllEndpointsForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace)
	}

	// Per-CR Deployment targeting
	if instance.Spec.TargetDeployment != "" {
		return r.EndpointResolver.GetAllEndpointsForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
	}

	// Global pod-name targeting (returns single endpoint)
	if r.EndpointResolver.IsPodConfigured() {
		url, err := r.EndpointResolver.GetEndpointForPod(ctx, r.EndpointResolver.GetConfiguredPodName(), namespace)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	// Fall back to global all-healthy endpoints
	return r.EndpointResolver.GetAllHealthyEndpoints()
}

// syncToEndpoint syncs to a single endpoint URL with GET-first drift detection.
// On success, it updates instance.Status.ExternalID, instance.Status.Response, and instance.Status.DriftDetected.
// The caller is responsible for calling updateStatus after this returns.
func (r *UserReconciler) syncToEndpoint(ctx context.Context, instance *v1alpha1.User, baseURL string) error {
	ctx, span := userTracer.Start(ctx, "SyncToEndpoint",
		trace.WithAttributes(
			attribute.String("endpoint.url", baseURL),
		))
	defer span.End()

	logger := log.FromContext(ctx)

	now := metav1.Now()
	externalID := r.getExternalID(instance)
	span.SetAttributes(attribute.String("resource.externalID", externalID))

	// Determine if we should try GET first to check if resource exists
	// Path params are required to build GET URL - skip GET if path params are invalid
	shouldTryGet := r.hasValidPathParams(instance)

	if shouldTryGet {
		respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
		if err != nil {
			return fmt.Errorf("failed to get resource: %w", err)
		}

		instance.Status.LastGetTime = &now

		if respData != nil {
			// Resource exists - check for drift
			hasDrift := r.compareSpecWithResponse(instance, respData)
			instance.Status.DriftDetected = hasDrift
			span.SetAttributes(attribute.Bool("drift.detected", hasDrift))

			// Extract external ID from response if available (for resources identified by path params)
			responseExternalID := r.extractExternalIDFromResponse(respData, externalID)
			// Snapshot original state on first adoption of existing resource
			// This applies when:
			// - Using path params (e.g., id: 10 references existing pet)
			// - Using externalIDRef to adopt existing resource
			// - Resource wasn't created by this controller
			if instance.Status.OriginalState == nil && !instance.Status.CreatedByController {
				instance.Status.OriginalState = &k8sruntime.RawExtension{Raw: body}
				instance.Status.AdoptedAt = &now
				logger.Info("Captured original state for adopted resource", "externalID", responseExternalID)
			}

			if hasDrift {
				// Increment drift detected count
				instance.Status.DriftDetectedCount++
				// Record drift detection metric
				userDriftDetected.Add(ctx, 1,
					metric.WithAttributes(
						attribute.String("resource.name", instance.Name),
						attribute.String("resource.namespace", instance.Namespace),
					))
			}
			if !hasDrift {
				// No drift - skip update
				logger.Info("No drift detected, skipping update", "externalID", responseExternalID)
				instance.Status.ExternalID = responseExternalID
				instance.Status.Response = &v1alpha1.UserEndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: body},
					LastUpdated: &now,
				}
				return nil
			}

			// Drift detected - proceed with update
			logger.Info("Drift detected, updating resource", "externalID", responseExternalID)
			// Use PUT with merge support
			return r.updateResource(ctx, instance, baseURL, responseExternalID, respData)
		}
		// Resource was created by us but no longer exists - recreate it
		logger.Info("Resource no longer exists, recreating", "externalID", externalID)
		instance.Status.ExternalID = "" // Clear so we do a POST
	}
	// No external ID or resource doesn't exist - create new resource
	return r.createResource(ctx, instance, baseURL)
}

// createResource performs a POST to create a new resource.
func (r *UserReconciler) createResource(ctx context.Context, instance *v1alpha1.User, baseURL string) error {
	ctx, span := userTracer.Start(ctx, "POST",
		trace.WithAttributes(
			attribute.String("http.method", "POST"),
			attribute.String("http.url", baseURL),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURLForCreate(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(specData))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create POST request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Creating resource", "url", url)
	logger.V(1).Info("REST API request", "method", "POST", "url", url, "body", string(specData))
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "POST", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to execute POST request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "POST", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to read POST response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "POST", "error", resp.StatusCode, duration)
		apiErr := &UserAPIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "POST",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, "POST", "success", resp.StatusCode, duration)

	// Parse response to extract ID
	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err == nil {
		if id, ok := respData["id"]; ok {
			switch v := id.(type) {
			case string:
				instance.Status.ExternalID = v
			case float64:
				instance.Status.ExternalID = fmt.Sprintf("%.0f", v)
			}
		}
	}

	span.SetAttributes(attribute.String("resource.externalID", instance.Status.ExternalID))

	logger.V(1).Info("REST API response", "method", "POST", "url", url, "statusCode", resp.StatusCode, "body", string(body))

	now := metav1.Now()
	instance.Status.Response = &v1alpha1.UserEndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now
	instance.Status.LastSyncTime = &now
	instance.Status.CreatedByController = true

	logger.Info("Successfully created resource", "externalID", instance.Status.ExternalID)
	return nil
}

// updateResource performs a PUT to update an existing resource.
// If mergeOnUpdate is true (default), it merges the spec with the current API state before sending.
func (r *UserReconciler) updateResource(ctx context.Context, instance *v1alpha1.User, baseURL string, externalID string, currentState map[string]interface{}) error {
	ctx, span := userTracer.Start(ctx, "PUT",
		trace.WithAttributes(
			attribute.String("http.method", "PUT"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", externalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()
	url := r.buildResourceURL(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	// Check if mergeOnUpdate is enabled (default: true)
	mergeEnabled := instance.Spec.MergeOnUpdate == nil || *instance.Spec.MergeOnUpdate
	span.SetAttributes(attribute.Bool("merge_on_update", mergeEnabled))

	var requestBody []byte
	if mergeEnabled && currentState != nil {
		// Merge spec with current API state
		requestBody, err = r.mergeSpecWithCurrentState(specData, currentState)
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			return fmt.Errorf("failed to merge spec with current state: %w", err)
		}
		logger.Info("Merged spec with current API state for PUT")
	} else {
		requestBody = specData
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bytes.NewReader(requestBody))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create PUT request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Updating resource", "url", url, "mergeEnabled", mergeEnabled)
	logger.V(1).Info("REST API request", "method", "PUT", "url", url, "body", string(requestBody))
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "PUT", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to execute PUT request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "PUT", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to read PUT response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "PUT", "error", resp.StatusCode, duration)
		apiErr := &UserAPIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "PUT",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, "PUT", "success", resp.StatusCode, duration)

	logger.V(1).Info("REST API response", "method", "PUT", "url", url, "statusCode", resp.StatusCode, "body", string(body))

	now := metav1.Now()
	instance.Status.ExternalID = externalID
	instance.Status.Response = &v1alpha1.UserEndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now
	instance.Status.LastSyncTime = &now

	logger.Info("Successfully updated resource", "externalID", externalID)
	return nil
}

// mergeSpecWithCurrentState merges the spec fields with the current API state.
// Fields explicitly set in the spec override the current state, while unset fields are preserved.
func (r *UserReconciler) mergeSpecWithCurrentState(specData []byte, currentState map[string]interface{}) ([]byte, error) {
	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return nil, fmt.Errorf("failed to unmarshal spec: %w", err)
	}

	// Start with current state as base
	merged := make(map[string]interface{})
	for k, v := range currentState {
		merged[k] = v
	}

	// Overlay spec fields (only non-zero/non-empty values)
	for k, v := range specMap {
		if !r.isZeroValue(v) {
			merged[k] = v
		}
	}

	return json.Marshal(merged)
}

// isZeroValue checks if a value is considered "zero" or empty for merge purposes.
// Zero values are not overlaid onto the current state, preserving the API's current value.
func (r *UserReconciler) isZeroValue(v interface{}) bool {
	if v == nil {
		return true
	}
	switch val := v.(type) {
	case string:
		return val == ""
	case float64:
		return val == 0
	case bool:
		return !val
	case []interface{}:
		return len(val) == 0
	case map[string]interface{}:
		return len(val) == 0
	default:
		return false
	}
}

// marshalSpecForAPI marshals the spec for sending to the API, excluding controller-specific fields.
func (r *UserReconciler) marshalSpecForAPI(instance *v1alpha1.User) ([]byte, error) {
	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return nil, err
	}

	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return nil, err
	}

	// Remove controller-specific fields
	delete(specMap, "targetPodOrdinal")
	delete(specMap, "targetHelmRelease")
	delete(specMap, "targetStatefulSet")
	delete(specMap, "targetDeployment")
	delete(specMap, "targetPod")
	delete(specMap, "targetNamespace")
	delete(specMap, "targetBaseURL")
	delete(specMap, "readOnly")
	delete(specMap, "mergeOnUpdate")
	delete(specMap, "onDelete")
	// Remove path parameter fields (they're used in URL, not body)
	delete(specMap, "username")

	return json.Marshal(specMap)
}

func (r *UserReconciler) syncResource(ctx context.Context, instance *v1alpha1.User) error {
	logger := log.FromContext(ctx)

	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - fan out to all
			var syncErrors []error
			successCount := 0

			for _, baseURL := range baseURLs {
				if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
					syncErrors = append(syncErrors, fmt.Errorf("%s: %w", baseURL, err))
				} else {
					successCount++
				}
			}

			// If all requests failed, return error
			if successCount == 0 {
				return fmt.Errorf("all sync requests failed: %v", syncErrors)
			}

			// Log partial failures
			if len(syncErrors) > 0 {
				logger.Info("Some sync requests failed", "successCount", successCount, "errors", syncErrors)
			}

			r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
			return nil
		}
	}

	// Single endpoint case - resolve URL and sync
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	logger.Info("Syncing to endpoint", "baseURL", baseURL)
	if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
		return err
	}

	r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
	return nil
}

// deleteFromEndpoint deletes from a single endpoint URL
func (r *UserReconciler) deleteFromEndpoint(ctx context.Context, instance *v1alpha1.User, baseURL string) error {
	ctx, span := userTracer.Start(ctx, "DELETE",
		trace.WithAttributes(
			attribute.String("http.method", "DELETE"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", instance.Status.ExternalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURL(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create delete request: %w", err)
	}

	logger.Info("Deleting external resource", "url", url)
	logger.V(1).Info("REST API request", "method", "DELETE", "url", url)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "DELETE", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to delete resource: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	// 404 is OK - resource already deleted
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusNotFound {
		body, _ := io.ReadAll(resp.Body)
		r.recordAPICallMetrics(ctx, "DELETE", "error", resp.StatusCode, duration)
		apiErr := &UserAPIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     "DELETE",
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, "DELETE", "success", resp.StatusCode, duration)
	logger.V(1).Info("REST API response", "method", "DELETE", "url", url, "statusCode", resp.StatusCode)
	logger.Info("Successfully deleted external resource")
	return nil
}

func (r *UserReconciler) finalizeResource(ctx context.Context, instance *v1alpha1.User) error {
	logger := log.FromContext(ctx)
	// DELETE requires valid path parameters to build the URL
	if !r.hasValidPathParams(instance) {
		logger.Info("No valid path parameters for DELETE URL, skipping finalization")
		return nil
	}

	// Determine deletion policy
	policy := instance.Spec.OnDelete
	if policy == "" {
		// Default: Delete if we created it, Orphan if we adopted it
		if instance.Status.CreatedByController {
			policy = "Delete"
		} else {
			policy = "Orphan"
		}
	}

	logger.Info("Finalizing resource", "policy", policy, "createdByController", instance.Status.CreatedByController)

	switch policy {
	case "Restore":
		if instance.Status.OriginalState == nil {
			logger.Info("No original state to restore, orphaning instead")
			return nil
		}
		return r.restoreOriginalState(ctx, instance)
	case "Orphan":
		logger.Info("Orphaning external resource", "externalID", r.getExternalID(instance))
		return nil
	case "Delete":
		// Continue with delete logic below
	default:
		logger.Info("Unknown OnDelete policy, defaulting to Orphan", "policy", policy)
		return nil
	}

	// Delete the external resource
	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - fan out delete to all
			var deleteErrors []error
			successCount := 0

			for _, baseURL := range baseURLs {
				if err := r.deleteFromEndpoint(ctx, instance, baseURL); err != nil {
					deleteErrors = append(deleteErrors, fmt.Errorf("%s: %w", baseURL, err))
				} else {
					successCount++
				}
			}

			// If all requests failed, return error
			if successCount == 0 {
				return fmt.Errorf("all delete requests failed: %v", deleteErrors)
			}

			// Log partial failures but consider success if at least one succeeded
			if len(deleteErrors) > 0 {
				logger.Info("Some delete requests failed", "successCount", successCount, "errors", deleteErrors)
			}

			return nil
		}
	}

	// Single endpoint case - resolve URL and delete
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	return r.deleteFromEndpoint(ctx, instance, baseURL)
}

// restoreOriginalState restores the external resource to its original state captured during adoption.
// This works for resources adopted via path params (e.g., id: 10) or externalIDRef.
func (r *UserReconciler) restoreOriginalState(ctx context.Context, instance *v1alpha1.User) error {
	httpMethod := "PUT"

	ctx, span := userTracer.Start(ctx, "RestoreOriginalState",
		trace.WithAttributes(
			attribute.String("resource.externalID", r.getExternalID(instance)),
			attribute.String("http.method", httpMethod),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}
	url := r.buildResourceURL(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	req, err := http.NewRequestWithContext(ctx, httpMethod, url, bytes.NewReader(instance.Status.OriginalState.Raw))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create restore request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Restoring original state", "url", url, "method", httpMethod)
	logger.V(1).Info("REST API request", "method", httpMethod, "url", url, "body", string(instance.Status.OriginalState.Raw))
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, httpMethod, "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to restore original state: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	// 404 is acceptable - resource may have been deleted externally
	if resp.StatusCode == http.StatusNotFound {
		r.recordAPICallMetrics(ctx, httpMethod, "not_found", resp.StatusCode, duration)
		logger.Info("Resource not found during restore (may have been deleted externally)")
		return nil
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		r.recordAPICallMetrics(ctx, httpMethod, "error", resp.StatusCode, duration)
		apiErr := &UserAPIError{
			StatusCode: resp.StatusCode,
			Status:     resp.Status,
			Body:       string(body),
			Method:     httpMethod,
			URL:        url,
		}
		span.RecordError(apiErr)
		span.SetStatus(codes.Error, apiErr.Error())
		return apiErr
	}

	r.recordAPICallMetrics(ctx, httpMethod, "success", resp.StatusCode, duration)
	logger.V(1).Info("REST API response", "method", httpMethod, "url", url, "statusCode", resp.StatusCode)
	logger.Info("Successfully restored original state", "externalID", r.getExternalID(instance))
	return nil
}

func (r *UserReconciler) updateStatus(ctx context.Context, instance *v1alpha1.User, state, message string) {
	logger := log.FromContext(ctx)

	// Capture status values we want to preserve from the current instance
	// These may have been set during syncToEndpoint
	statusSnapshot := instance.Status.DeepCopy()

	// Retry on conflict - refetch and reapply status
	err := retry.RetryOnConflict(retry.DefaultRetry, func() error {
		// Fetch the latest version
		latest := &v1alpha1.User{}
		if err := r.Get(ctx, client.ObjectKeyFromObject(instance), latest); err != nil {
			return err
		}

		now := metav1.Now()
		// Apply captured status values
		latest.Status = *statusSnapshot
		latest.Status.State = state
		latest.Status.Message = message
		// Preserve LastSyncTime from snapshot - it's only updated by actual POST/PUT/PATCH operations
		// Don't overwrite it here since updateStatus is called even when no actual sync occurred
		latest.Status.ObservedGeneration = latest.Generation

		// Update condition
		condition := metav1.Condition{
			Type:               "Ready",
			Status:             metav1.ConditionFalse,
			Reason:             state,
			Message:            message,
			LastTransitionTime: now,
		}
		// Set Ready=True for successful states
		if state == "Synced" || state == "Observed" {
			condition.Status = metav1.ConditionTrue
		}
		meta.SetStatusCondition(&latest.Status.Conditions, condition)

		return r.Status().Update(ctx, latest)
	})

	if err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *UserReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.User{}).
		Complete(r)
}
