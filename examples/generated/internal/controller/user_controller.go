/*
Copyright 2026 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	"github.com/bluecontainer/openapi-operator-gen/pkg/runtime"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

const (
	userFinalizer    = "petstore.example.com/finalizer"
	userRequeueAfter = time.Second * 30
)

// UserReconciler reconciles a User object
type UserReconciler struct {
	client.Client
	Scheme           *k8sruntime.Scheme
	HTTPClient       *http.Client
	EndpointResolver *endpoint.Resolver
	// BaseURL is used when EndpointResolver is nil (static URL mode)
	BaseURL string
}

// +kubebuilder:rbac:groups=petstore.example.com,resources=users,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=users/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=petstore.example.com,resources=users/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop
func (r *UserReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the User instance
	instance := &v1alpha1.User{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("User resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get User")
		return ctrl.Result{}, err
	}

	// Check if this is a read-only resource
	isReadOnly := instance.Spec.ReadOnly

	// Check if the resource is being deleted
	if instance.GetDeletionTimestamp() != nil {
		if controllerutil.ContainsFinalizer(instance, userFinalizer) {
			// Run finalization logic (skip for read-only resources)
			if !isReadOnly {
				if err := r.finalizeResource(ctx, instance); err != nil {
					return ctrl.Result{}, err
				}
			}

			// Remove finalizer
			controllerutil.RemoveFinalizer(instance, userFinalizer)
			if err := r.Update(ctx, instance); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	// Add finalizer if not present (skip for read-only resources)
	if !isReadOnly && !controllerutil.ContainsFinalizer(instance, userFinalizer) {
		controllerutil.AddFinalizer(instance, userFinalizer)
		if err := r.Update(ctx, instance); err != nil {
			return ctrl.Result{}, err
		}
	}

	// Handle read-only mode: only GET and update status
	if isReadOnly {
		if instance.Spec.ExternalIDRef == "" {
			r.updateStatus(ctx, instance, "Failed", "ReadOnly mode requires ExternalIDRef to be set")
			return ctrl.Result{RequeueAfter: userRequeueAfter}, fmt.Errorf("readOnly mode requires externalIDRef")
		}
		if err := r.observeResource(ctx, instance); err != nil {
			r.updateStatus(ctx, instance, "Failed", err.Error())
			return ctrl.Result{RequeueAfter: userRequeueAfter}, err
		}
		return ctrl.Result{RequeueAfter: userRequeueAfter}, nil
	}

	// Sync with REST API (with drift detection)
	if err := r.syncResource(ctx, instance); err != nil {
		// Update status to failed
		r.updateStatus(ctx, instance, "Failed", err.Error())
		return ctrl.Result{RequeueAfter: userRequeueAfter}, err
	}

	return ctrl.Result{RequeueAfter: userRequeueAfter}, nil
}

func (r *UserReconciler) getBaseURL(ctx context.Context) (string, error) {
	if r.EndpointResolver != nil {
		return r.EndpointResolver.GetEndpoint()
	}
	if r.BaseURL == "" {
		return "", fmt.Errorf("no base URL configured")
	}
	return r.BaseURL, nil
}

func (r *UserReconciler) getBaseURLByOrdinal(ctx context.Context, ordinal *int32) (string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		if ordinal == nil {
			return "", fmt.Errorf("targetPodOrdinal is required when using by-ordinal strategy")
		}
		return r.EndpointResolver.GetEndpointByOrdinal(int(*ordinal))
	}
	// Fall back to regular endpoint selection if not using by-ordinal strategy
	return r.getBaseURL(ctx)
}

// buildResourceURL builds the URL for resource operations with path and query parameters
// BasePath is the base path without path parameter placeholders (e.g., /pet, not /pet/{petId})
// The resourceID is appended to the path for GET/PUT/DELETE operations
func (r *UserReconciler) buildResourceURL(baseURL string, instance *v1alpha1.User, resourceID string) string {
	builder := runtime.NewURLBuilder("/user")

	// Add resource ID for operations that need it (appended to path)
	builder.WithResourceID(resourceID)

	return builder.Build(baseURL)
}

// buildResourceURLForCreate builds the URL for resource creation (POST) with query parameters only
func (r *UserReconciler) buildResourceURLForCreate(baseURL string, instance *v1alpha1.User) string {
	builder := runtime.NewURLBuilder("/user")

	return builder.BuildForCreate(baseURL)
}

// getExternalID returns the external ID to use for GET/PUT/DELETE operations.
// It prefers ExternalIDRef from spec (for importing existing resources),
// then falls back to ExternalID from status (for resources created by the controller).
func (r *UserReconciler) getExternalID(instance *v1alpha1.User) string {
	if instance.Spec.ExternalIDRef != "" {
		return instance.Spec.ExternalIDRef
	}
	return instance.Status.ExternalID
}

// getResource performs a GET request to fetch the current state of the resource from the REST API.
// Returns the response body as a map, or nil if the resource doesn't exist (404).
func (r *UserReconciler) getResource(ctx context.Context, baseURL string, externalID string, instance *v1alpha1.User) (map[string]interface{}, []byte, error) {
	logger := log.FromContext(ctx)

	url := r.buildResourceURL(baseURL, instance, externalID)
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create GET request: %w", err)
	}
	req.Header.Set("Accept", "application/json")

	logger.Info("Getting resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to execute GET request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read GET response: %w", err)
	}

	// 404 means resource doesn't exist
	if resp.StatusCode == http.StatusNotFound {
		logger.Info("Resource not found in external API", "externalID", externalID)
		return nil, nil, nil
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return nil, nil, fmt.Errorf("GET failed: %s - %s", resp.Status, string(body))
	}

	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err != nil {
		return nil, body, fmt.Errorf("failed to parse GET response: %w", err)
	}

	return respData, body, nil
}

// compareSpecWithResponse compares the CR spec with the API response to detect drift.
// Returns true if there is drift (spec differs from current state).
func (r *UserReconciler) compareSpecWithResponse(instance *v1alpha1.User, apiResponse map[string]interface{}) bool {
	// Marshal spec to JSON for comparison
	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return true // Assume drift on error
	}

	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return true // Assume drift on error
	}

	// Remove controller-specific fields from spec that aren't part of the API resource
	delete(specMap, "targetPodOrdinal")
	delete(specMap, "targetHelmRelease")
	delete(specMap, "targetStatefulSet")
	delete(specMap, "targetDeployment")
	delete(specMap, "targetNamespace")
	delete(specMap, "externalIDRef")
	delete(specMap, "readOnly")

	// Compare each field in spec with API response
	for key, specValue := range specMap {
		apiValue, exists := apiResponse[key]
		if !exists {
			// Field exists in spec but not in API response - could be drift or API doesn't return this field
			continue
		}
		if !reflect.DeepEqual(specValue, apiValue) {
			return true // Drift detected
		}
	}

	return false // No drift
}

// observeResource performs a GET-only observation for read-only CRs.
func (r *UserReconciler) observeResource(ctx context.Context, instance *v1alpha1.User) error {
	logger := log.FromContext(ctx)

	externalID := r.getExternalID(instance)
	if externalID == "" {
		return fmt.Errorf("no external ID available for observation")
	}

	now := metav1.Now()

	// Check if using all-healthy strategy (fan out GET to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.EndpointResolver.GetAllHealthyEndpoints()
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - collect responses from all
			responses := make(map[string]v1alpha1.UserEndpointResponse)
			successCount := 0
			var firstSuccessBody []byte

			for _, baseURL := range baseURLs {
				endpointResp := v1alpha1.UserEndpointResponse{
					LastUpdated: &now,
				}

				respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
				if err != nil {
					endpointResp.Success = false
					endpointResp.Error = err.Error()
					logger.Info("Failed to observe from endpoint", "endpoint", baseURL, "error", err)
				} else if respData == nil {
					endpointResp.Success = false
					endpointResp.StatusCode = 404
					endpointResp.Error = fmt.Sprintf("resource %s not found", externalID)
					logger.Info("Resource not found at endpoint", "endpoint", baseURL, "externalID", externalID)
				} else {
					endpointResp.Success = true
					endpointResp.StatusCode = 200
					endpointResp.Data = &k8sruntime.RawExtension{Raw: body}
					successCount++
					if firstSuccessBody == nil {
						firstSuccessBody = body
					}
					logger.Info("Successfully observed from endpoint", "endpoint", baseURL, "externalID", externalID)
				}

				responses[baseURL] = endpointResp
			}

			// Update status with all responses
			instance.Status.ExternalID = externalID
			instance.Status.Responses = responses
			instance.Status.LastGetTime = &now
			instance.Status.DriftDetected = false

			// Also set the single Response field with first success for backwards compatibility
			if firstSuccessBody != nil {
				instance.Status.Response = &v1alpha1.UserEndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: firstSuccessBody},
					LastUpdated: &now,
				}
			}

			if successCount == 0 {
				r.updateStatus(ctx, instance, "NotFound", fmt.Sprintf("Resource %s not found in any endpoint (%d endpoints queried)", externalID, len(baseURLs)))
				return nil
			}

			message := fmt.Sprintf("Successfully observed from %d/%d endpoints", successCount, len(baseURLs))
			logger.Info(message, "externalID", externalID)
			r.updateStatus(ctx, instance, "Observed", message)
			return nil
		}
	}

	// Single endpoint case - resolve URL and observe
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return err
	}

	respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
	if err != nil {
		return err
	}

	if respData == nil {
		r.updateStatus(ctx, instance, "NotFound", fmt.Sprintf("Resource %s not found in external API", externalID))
		return nil
	}

	// Update status with fetched data
	instance.Status.ExternalID = externalID
	instance.Status.Response = &v1alpha1.UserEndpointResponse{
		Success:     true,
		StatusCode:  200,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.LastGetTime = &now
	instance.Status.DriftDetected = false // No drift concept for read-only
	instance.Status.Responses = nil       // Clear multi-endpoint responses for single endpoint

	logger.Info("Successfully observed resource", "externalID", externalID)
	r.updateStatus(ctx, instance, "Observed", "Successfully fetched resource from REST API")
	return nil
}

// resolveBaseURL determines the base URL to use for API requests based on CR targeting fields.
func (r *UserReconciler) resolveBaseURL(ctx context.Context, instance *v1alpha1.User) (string, error) {
	if r.EndpointResolver != nil {
		namespace := instance.Spec.TargetNamespace
		if namespace == "" {
			namespace = instance.Namespace
		}

		// Per-CR Helm release targeting
		if instance.Spec.TargetHelmRelease != "" {
			return r.EndpointResolver.GetEndpointForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace, instance.Spec.TargetPodOrdinal)
		}

		// Per-CR StatefulSet targeting
		if instance.Spec.TargetStatefulSet != "" {
			return r.EndpointResolver.GetEndpointForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace, instance.Spec.TargetPodOrdinal)
		}

		// Per-CR Deployment targeting
		if instance.Spec.TargetDeployment != "" {
			return r.EndpointResolver.GetEndpointForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
		}

		// By-ordinal strategy
		if r.EndpointResolver.IsByOrdinalStrategy() {
			return r.getBaseURLByOrdinal(ctx, instance.Spec.TargetPodOrdinal)
		}
	}

	return r.getBaseURL(ctx)
}

// syncToEndpoint syncs to a single endpoint URL with GET-first drift detection.
// On success, it updates instance.Status.ExternalID, instance.Status.Response, and instance.Status.DriftDetected.
// The caller is responsible for calling updateStatus after this returns.
func (r *UserReconciler) syncToEndpoint(ctx context.Context, instance *v1alpha1.User, baseURL string) error {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	externalID := r.getExternalID(instance)

	// If we have an external ID (from spec.externalIDRef or status.externalID), try GET first
	if externalID != "" {
		respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
		if err != nil {
			return fmt.Errorf("failed to get resource: %w", err)
		}

		instance.Status.LastGetTime = &now

		if respData != nil {
			// Resource exists - check for drift
			hasDrift := r.compareSpecWithResponse(instance, respData)
			instance.Status.DriftDetected = hasDrift

			if !hasDrift {
				// No drift - skip update
				logger.Info("No drift detected, skipping update", "externalID", externalID)
				instance.Status.ExternalID = externalID
				instance.Status.Response = &v1alpha1.UserEndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: body},
					LastUpdated: &now,
				}
				return nil
			}

			// Drift detected - proceed with PUT
			logger.Info("Drift detected, updating resource", "externalID", externalID)
			return r.updateResource(ctx, instance, baseURL, externalID)
		}

		// Resource doesn't exist (404) - if we're using externalIDRef, this is an error
		if instance.Spec.ExternalIDRef != "" {
			return fmt.Errorf("resource with externalIDRef %s not found", instance.Spec.ExternalIDRef)
		}

		// Resource was created by us but no longer exists - recreate it
		logger.Info("Resource no longer exists, recreating", "externalID", externalID)
		instance.Status.ExternalID = "" // Clear so we do a POST
	}

	// No external ID or resource doesn't exist - create new resource
	return r.createResource(ctx, instance, baseURL)
}

// createResource performs a POST to create a new resource.
func (r *UserReconciler) createResource(ctx context.Context, instance *v1alpha1.User, baseURL string) error {
	logger := log.FromContext(ctx)

	url := r.buildResourceURLForCreate(baseURL, instance)

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(specData))
	if err != nil {
		return fmt.Errorf("failed to create POST request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Creating resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to execute POST request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read POST response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("POST failed: %s - %s", resp.Status, string(body))
	}

	// Parse response to extract ID
	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err == nil {
		if id, ok := respData["id"]; ok {
			switch v := id.(type) {
			case string:
				instance.Status.ExternalID = v
			case float64:
				instance.Status.ExternalID = fmt.Sprintf("%.0f", v)
			}
		}
	}

	now := metav1.Now()
	instance.Status.Response = &v1alpha1.UserEndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now

	logger.Info("Successfully created resource", "externalID", instance.Status.ExternalID)
	return nil
}

// updateResource performs a PUT to update an existing resource.
func (r *UserReconciler) updateResource(ctx context.Context, instance *v1alpha1.User, baseURL string, externalID string) error {
	logger := log.FromContext(ctx)

	url := r.buildResourceURL(baseURL, instance, externalID)

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bytes.NewReader(specData))
	if err != nil {
		return fmt.Errorf("failed to create PUT request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Updating resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to execute PUT request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read PUT response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("PUT failed: %s - %s", resp.Status, string(body))
	}

	now := metav1.Now()
	instance.Status.ExternalID = externalID
	instance.Status.Response = &v1alpha1.UserEndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now

	logger.Info("Successfully updated resource", "externalID", externalID)
	return nil
}

// marshalSpecForAPI marshals the spec for sending to the API, excluding controller-specific fields.
func (r *UserReconciler) marshalSpecForAPI(instance *v1alpha1.User) ([]byte, error) {
	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return nil, err
	}

	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return nil, err
	}

	// Remove controller-specific fields
	delete(specMap, "targetPodOrdinal")
	delete(specMap, "targetHelmRelease")
	delete(specMap, "targetStatefulSet")
	delete(specMap, "targetDeployment")
	delete(specMap, "targetNamespace")
	delete(specMap, "externalIDRef")
	delete(specMap, "readOnly")
	// Remove path parameter fields (they're used in URL, not body)
	delete(specMap, "username")

	return json.Marshal(specMap)
}

func (r *UserReconciler) syncResource(ctx context.Context, instance *v1alpha1.User) error {
	logger := log.FromContext(ctx)

	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.EndpointResolver.GetAllHealthyEndpoints()
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - fan out to all
			var syncErrors []error
			successCount := 0

			for _, baseURL := range baseURLs {
				if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
					syncErrors = append(syncErrors, fmt.Errorf("%s: %w", baseURL, err))
				} else {
					successCount++
				}
			}

			// If all requests failed, return error
			if successCount == 0 {
				return fmt.Errorf("all sync requests failed: %v", syncErrors)
			}

			// Log partial failures
			if len(syncErrors) > 0 {
				logger.Info("Some sync requests failed", "successCount", successCount, "errors", syncErrors)
			}

			r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
			return nil
		}
	}

	// Single endpoint case - resolve URL and sync
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	logger.Info("Syncing to endpoint", "baseURL", baseURL)
	if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
		return err
	}

	r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
	return nil
}

// deleteFromEndpoint deletes from a single endpoint URL
func (r *UserReconciler) deleteFromEndpoint(ctx context.Context, instance *v1alpha1.User, baseURL string) error {
	logger := log.FromContext(ctx)

	url := r.buildResourceURL(baseURL, instance, instance.Status.ExternalID)
	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return fmt.Errorf("failed to create delete request: %w", err)
	}

	logger.Info("Deleting external resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to delete resource: %w", err)
	}
	defer resp.Body.Close()

	// 404 is OK - resource already deleted
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusNotFound {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("failed to delete: %s - %s", resp.Status, string(body))
	}

	logger.Info("Successfully deleted external resource")
	return nil
}

func (r *UserReconciler) finalizeResource(ctx context.Context, instance *v1alpha1.User) error {
	logger := log.FromContext(ctx)

	if instance.Status.ExternalID == "" {
		logger.Info("No external ID, skipping delete")
		return nil
	}

	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.EndpointResolver.GetAllHealthyEndpoints()
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - fan out delete to all
			var deleteErrors []error
			successCount := 0

			for _, baseURL := range baseURLs {
				if err := r.deleteFromEndpoint(ctx, instance, baseURL); err != nil {
					deleteErrors = append(deleteErrors, fmt.Errorf("%s: %w", baseURL, err))
				} else {
					successCount++
				}
			}

			// If all requests failed, return error
			if successCount == 0 {
				return fmt.Errorf("all delete requests failed: %v", deleteErrors)
			}

			// Log partial failures but consider success if at least one succeeded
			if len(deleteErrors) > 0 {
				logger.Info("Some delete requests failed", "successCount", successCount, "errors", deleteErrors)
			}

			return nil
		}
	}

	// Single endpoint case - resolve URL and delete
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	return r.deleteFromEndpoint(ctx, instance, baseURL)
}

func (r *UserReconciler) updateStatus(ctx context.Context, instance *v1alpha1.User, state, message string) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	instance.Status.State = state
	instance.Status.Message = message
	instance.Status.LastSyncTime = &now
	instance.Status.ObservedGeneration = instance.Generation

	// Update condition
	condition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	// Set Ready=True for successful states
	if state == "Synced" || state == "Observed" {
		condition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, condition)

	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *UserReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.User{}).
		Complete(r)
}
