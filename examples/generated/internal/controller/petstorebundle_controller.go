/*
Copyright 2026 Generated by openapi-operator-gen v0.0.9-10-g81b13bf-dirty.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/bluecontainer/openapi-operator-gen/pkg/aggregate"
	"github.com/bluecontainer/openapi-operator-gen/pkg/bundle"
	celutil "github.com/bluecontainer/openapi-operator-gen/pkg/cel"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	k8stypes "k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	controllerutil2 "github.com/bluecontainer/openapi-operator-gen/pkg/controller"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

var (
	petstorebundleTracer = otel.Tracer("github.com/bluecontainer/petstore-operator/controller/petstorebundle")
	petstorebundleMeter  = otel.Meter("github.com/bluecontainer/petstore-operator/controller/petstorebundle")

	// Metrics
	petstorebundleReconcileTotal    metric.Int64Counter
	petstorebundleReconcileDuration metric.Float64Histogram
	petstorebundleResourcesTotal    metric.Int64UpDownCounter
)

func init() {
	var err error

	petstorebundleReconcileTotal, err = petstorebundleMeter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	petstorebundleReconcileDuration, err = petstorebundleMeter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	petstorebundleResourcesTotal, err = petstorebundleMeter.Int64UpDownCounter(
		"bundle_resources_total",
		metric.WithDescription("Total number of resources in the bundle"),
		metric.WithUnit("{resource}"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
	petstorebundleFinalizerName = "petstore.example.com/bundle-finalizer"
	petstorebundleRequeueAfter  = time.Second * 30
	petstorebundleRetryAfter    = time.Second * 5
)

// PetstoreBundleReconciler reconciles a PetstoreBundle object
type PetstoreBundleReconciler struct {
	client.Client
	Scheme *k8sruntime.Scheme
}

// +kubebuilder:rbac:groups=petstore.example.com,resources=petstorebundles,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=petstorebundles/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=petstore.example.com,resources=petstorebundles/finalizers,verbs=update
// +kubebuilder:rbac:groups=petstore.example.com,resources=orders,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=pets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=users,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=petfindbystatusqueries,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=petfindbytagsqueries,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=storeinventoryqueries,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=userloginqueries,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=userlogoutqueries,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=petuploadimageactions,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=usercreatewithlistactions,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop
func (r *PetstoreBundleReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// Start tracing span
	ctx, span := petstorebundleTracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "PetstoreBundle"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	// Record metrics
	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	petstorebundleReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	petstorebundleReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

// reconcileInternal contains the actual reconciliation logic
func (r *PetstoreBundleReconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the PetstoreBundle instance
	bundle := &v1alpha1.PetstoreBundle{}
	err := r.Get(ctx, req.NamespacedName, bundle)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("PetstoreBundle resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get PetstoreBundle")
		return ctrl.Result{}, err
	}

	// Handle deletion
	if !bundle.DeletionTimestamp.IsZero() {
		return r.handleDeletion(ctx, bundle)
	}

	// Add finalizer if not present
	if !controllerutil.ContainsFinalizer(bundle, petstorebundleFinalizerName) {
		controllerutil.AddFinalizer(bundle, petstorebundleFinalizerName)
		if err := r.Update(ctx, bundle); err != nil {
			return ctrl.Result{}, err
		}
		return ctrl.Result{Requeue: true}, nil
	}

	// Check if paused
	if bundle.Spec.Paused {
		return r.updateBundleStatus(ctx, bundle, "Paused", "Reconciliation paused")
	}

	// Build dependency graph and determine execution order
	order, err := r.buildExecutionOrder(bundle.Spec.Resources)
	if err != nil {
		return r.updateBundleStatus(ctx, bundle, "Failed", fmt.Sprintf("Invalid dependencies: %v", err))
	}

	// Process resources in dependency order
	return r.syncResources(ctx, bundle, order)
}

// buildExecutionOrder builds a DAG and returns topologically sorted resource IDs
// Dependencies are derived from:
// 1. Explicit dependsOn declarations
// 2. Implicit references in spec via ${resources.<id>...} patterns
// Uses shared bundle package for dependency extraction and validation.
func (r *PetstoreBundleReconciler) buildExecutionOrder(resources []v1alpha1.BundleResourceSpec) ([]string, error) {
	if len(resources) == 0 {
		return []string{}, nil
	}

	// Build set of valid resource IDs for validation
	validIDs := make(map[string]bool)
	for _, res := range resources {
		validIDs[res.ID] = true
	}

	// Build adjacency list
	inDegree := make(map[string]int)
	dependents := make(map[string][]string) // Maps resource ID to IDs that depend on it

	// Initialize all resources with 0 in-degree
	for _, res := range resources {
		inDegree[res.ID] = 0
	}

	// Build dependency graph from explicit dependsOn and implicit references
	for _, res := range resources {
		// Collect all dependencies (explicit + implicit) using shared bundle package
		allDeps := make(map[string]bool)

		// Add explicit dependencies
		for _, dep := range res.DependsOn {
			allDeps[dep] = true
		}

		// Extract implicit dependencies from spec using shared bundle package
		if res.Spec.Raw != nil {
			for _, dep := range bundle.ExtractDependenciesFromBytes(res.Spec.Raw, false) {
				allDeps[dep] = true
			}
		}

		// Also check readyWhen and skipWhen conditions for references (include bare refs)
		for _, condition := range res.ReadyWhen {
			for _, dep := range bundle.ExtractDependenciesFromExpression(condition) {
				allDeps[dep] = true
			}
		}
		for _, condition := range res.SkipWhen {
			for _, dep := range bundle.ExtractDependenciesFromExpression(condition) {
				allDeps[dep] = true
			}
		}

		// Remove self-reference if any
		delete(allDeps, res.ID)

		// Validate and add dependencies
		for dep := range allDeps {
			if !validIDs[dep] {
				return nil, fmt.Errorf("resource %s depends on unknown resource %s", res.ID, dep)
			}
			inDegree[res.ID]++
			dependents[dep] = append(dependents[dep], res.ID)
		}
	}

	// Kahn's algorithm for topological sort with deterministic ordering
	var queue []string
	for id, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, id)
		}
	}

	// Sort queue for deterministic ordering
	sort.Strings(queue)

	var order []string
	for len(queue) > 0 {
		// Take from front of sorted queue
		id := queue[0]
		queue = queue[1:]
		order = append(order, id)

		// Get dependents and sort for determinism
		deps := dependents[id]
		sort.Strings(deps)

		// Reduce in-degree of dependent resources
		for _, dependent := range deps {
			inDegree[dependent]--
			if inDegree[dependent] == 0 {
				queue = append(queue, dependent)
				// Re-sort queue to maintain deterministic order
				sort.Strings(queue)
			}
		}
	}

	if len(order) != len(resources) {
		return nil, fmt.Errorf("circular dependency detected")
	}

	return order, nil
}

// syncResources creates/updates resources in dependency order
func (r *PetstoreBundleReconciler) syncResources(ctx context.Context, bundle *v1alpha1.PetstoreBundle, order []string) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Build resource map for quick lookup
	resourceMap := make(map[string]v1alpha1.BundleResourceSpec)
	for _, res := range bundle.Spec.Resources {
		resourceMap[res.ID] = res
	}

	// Build status map from existing resources
	statusMap := make(map[string]*v1alpha1.BundleResourceStatus)
	for i := range bundle.Status.Resources {
		statusMap[bundle.Status.Resources[i].ID] = &bundle.Status.Resources[i]
	}

	// Process in order
	var statuses []v1alpha1.BundleResourceStatus
	allSynced := true
	hasFailed := false
	needsRequeue := false

	for _, id := range order {
		res := resourceMap[id]

		// Check skipWhen conditions
		if len(res.SkipWhen) > 0 {
			skip, err := r.evaluateConditions(res.SkipWhen, statusMap, bundle)
			if err != nil {
				logger.Error(err, "Failed to evaluate skipWhen", "resource", id)
			}
			if skip {
				now := metav1.Now()
				statuses = append(statuses, v1alpha1.BundleResourceStatus{
					ID:           id,
					Kind:         res.Kind,
					Name:         fmt.Sprintf("%s-%s", bundle.Name, id),
					State:        "Skipped",
					Skipped:      true,
					LastSyncTime: &now,
				})
				continue
			}
		}

		// Check if dependencies are ready
		depsReady := r.checkDependenciesReady(res.DependsOn, statusMap)
		if !depsReady {
			statuses = append(statuses, v1alpha1.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    fmt.Sprintf("%s-%s", bundle.Name, id),
				State:   "Pending",
				Message: "Waiting for dependencies",
			})
			allSynced = false
			needsRequeue = true
			continue
		}

		// Resolve CEL expressions in spec
		resolvedSpec, err := r.resolveExpressions(res.Spec, statusMap, bundle)
		if err != nil {
			statuses = append(statuses, v1alpha1.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    fmt.Sprintf("%s-%s", bundle.Name, id),
				State:   "Failed",
				Message: fmt.Sprintf("Expression error: %v", err),
			})
			hasFailed = true
			continue
		}

		// Create or update the child resource
		status, err := r.syncChildResource(ctx, bundle, id, res.Kind, resolvedSpec)
		if err != nil {
			statuses = append(statuses, v1alpha1.BundleResourceStatus{
				ID:      id,
				Kind:    res.Kind,
				Name:    fmt.Sprintf("%s-%s", bundle.Name, id),
				State:   "Failed",
				Message: err.Error(),
			})
			hasFailed = true
			continue
		}

		// Check readyWhen conditions if specified
		if len(res.ReadyWhen) > 0 && status.State == "Synced" {
			ready, err := r.evaluateConditions(res.ReadyWhen, statusMap, bundle)
			if err != nil {
				logger.Error(err, "Failed to evaluate readyWhen", "resource", id)
			}
			status.Ready = ready
		} else {
			status.Ready = status.State == "Synced"
		}

		statuses = append(statuses, *status)
		statusMap[id] = status // Update statusMap for dependent resources

		if status.State != "Synced" {
			allSynced = false
			needsRequeue = true
		}
	}

	// Update bundle status
	bundle.Status.Resources = statuses
	bundle.Status.Summary = r.calculateSummary(statuses)

	// Update resource metrics
	petstorebundleResourcesTotal.Add(ctx, int64(bundle.Status.Summary.Total),
		metric.WithAttributes(
			attribute.String("bundle.name", bundle.Name),
			attribute.String("bundle.namespace", bundle.Namespace),
		))

	var state, message string
	if hasFailed {
		state = "Failed"
		message = fmt.Sprintf("%d resources failed", bundle.Status.Summary.Failed)
	} else if allSynced {
		state = "Synced"
		message = "All resources synced"
	} else {
		state = "Syncing"
		message = fmt.Sprintf("%d/%d resources synced", bundle.Status.Summary.Synced, bundle.Status.Summary.Total)
	}

	logger.Info("Bundle sync status",
		"state", state,
		"total", bundle.Status.Summary.Total,
		"synced", bundle.Status.Summary.Synced,
		"failed", bundle.Status.Summary.Failed)

	result, _ := r.updateBundleStatus(ctx, bundle, state, message)

	// Requeue if not all synced
	if needsRequeue {
		return ctrl.Result{RequeueAfter: petstorebundleRetryAfter}, nil
	}

	return result, nil
}

// syncChildResource creates or updates a single child resource
func (r *PetstoreBundleReconciler) syncChildResource(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	id string,
	kind string,
	spec []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	// Generate child resource name
	childName := fmt.Sprintf("%s-%s", bundle.Name, id)

	// Create the appropriate typed resource based on kind
	switch kind {
	case "Order":
		return r.syncOrder(ctx, bundle, childName, id, spec)
	case "Pet":
		return r.syncPet(ctx, bundle, childName, id, spec)
	case "User":
		return r.syncUser(ctx, bundle, childName, id, spec)
	case "PetFindbystatusQuery":
		return r.syncPetFindbystatusQuery(ctx, bundle, childName, id, spec)
	case "PetFindbytagsQuery":
		return r.syncPetFindbytagsQuery(ctx, bundle, childName, id, spec)
	case "StoreInventoryQuery":
		return r.syncStoreInventoryQuery(ctx, bundle, childName, id, spec)
	case "UserLoginQuery":
		return r.syncUserLoginQuery(ctx, bundle, childName, id, spec)
	case "UserLogoutQuery":
		return r.syncUserLogoutQuery(ctx, bundle, childName, id, spec)
	case "PetUploadimageAction":
		return r.syncPetUploadimageAction(ctx, bundle, childName, id, spec)
	case "UserCreatewithlistAction":
		return r.syncUserCreatewithlistAction(ctx, bundle, childName, id, spec)
	default:
		return nil, fmt.Errorf("unknown kind: %s", kind)
	}
}

// syncOrder creates/updates a Order resource
func (r *PetstoreBundleReconciler) syncOrder(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.Order
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for Order: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.Order{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "Order", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "Order",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "Order", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "Order",
		Name:         name,
		State:        existing.Status.State,
		ExternalID:   controllerutil2.GetExternalIDIfPresent(existing),
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Synced",
		LastSyncTime: existing.Status.LastSyncTime,
	}, nil
}

// syncPet creates/updates a Pet resource
func (r *PetstoreBundleReconciler) syncPet(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.Pet
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for Pet: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.Pet{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "Pet", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "Pet",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "Pet", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "Pet",
		Name:         name,
		State:        existing.Status.State,
		ExternalID:   controllerutil2.GetExternalIDIfPresent(existing),
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Synced",
		LastSyncTime: existing.Status.LastSyncTime,
	}, nil
}

// syncUser creates/updates a User resource
func (r *PetstoreBundleReconciler) syncUser(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.User
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for User: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.User{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "User", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "User",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "User", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "User",
		Name:         name,
		State:        existing.Status.State,
		ExternalID:   controllerutil2.GetExternalIDIfPresent(existing),
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Synced",
		LastSyncTime: existing.Status.LastSyncTime,
	}, nil
}

// syncPetFindbystatusQuery creates/updates a PetFindbystatusQuery resource
func (r *PetstoreBundleReconciler) syncPetFindbystatusQuery(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.PetFindbystatusQuery
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for PetFindbystatusQuery: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.PetFindbystatusQuery{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "PetFindbystatusQuery", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "PetFindbystatusQuery",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "PetFindbystatusQuery", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Query CRDs use "Queried" as success state)
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "PetFindbystatusQuery",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Queried",
		LastSyncTime: existing.Status.LastQueryTime,
	}, nil
}

// syncPetFindbytagsQuery creates/updates a PetFindbytagsQuery resource
func (r *PetstoreBundleReconciler) syncPetFindbytagsQuery(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.PetFindbytagsQuery
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for PetFindbytagsQuery: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.PetFindbytagsQuery{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "PetFindbytagsQuery", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "PetFindbytagsQuery",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "PetFindbytagsQuery", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Query CRDs use "Queried" as success state)
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "PetFindbytagsQuery",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Queried",
		LastSyncTime: existing.Status.LastQueryTime,
	}, nil
}

// syncStoreInventoryQuery creates/updates a StoreInventoryQuery resource
func (r *PetstoreBundleReconciler) syncStoreInventoryQuery(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.StoreInventoryQuery
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for StoreInventoryQuery: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.StoreInventoryQuery{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "StoreInventoryQuery", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "StoreInventoryQuery",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "StoreInventoryQuery", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Query CRDs use "Queried" as success state)
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "StoreInventoryQuery",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Queried",
		LastSyncTime: existing.Status.LastQueryTime,
	}, nil
}

// syncUserLoginQuery creates/updates a UserLoginQuery resource
func (r *PetstoreBundleReconciler) syncUserLoginQuery(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.UserLoginQuery
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for UserLoginQuery: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.UserLoginQuery{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "UserLoginQuery", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "UserLoginQuery",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "UserLoginQuery", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Query CRDs use "Queried" as success state)
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "UserLoginQuery",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Queried",
		LastSyncTime: existing.Status.LastQueryTime,
	}, nil
}

// syncUserLogoutQuery creates/updates a UserLogoutQuery resource
func (r *PetstoreBundleReconciler) syncUserLogoutQuery(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.UserLogoutQuery
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for UserLogoutQuery: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.UserLogoutQuery{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "UserLogoutQuery", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "UserLogoutQuery",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "UserLogoutQuery", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Query CRDs use "Queried" as success state)
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "UserLogoutQuery",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Queried",
		LastSyncTime: existing.Status.LastQueryTime,
	}, nil
}

// syncPetUploadimageAction creates/updates a PetUploadimageAction resource
func (r *PetstoreBundleReconciler) syncPetUploadimageAction(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.PetUploadimageAction
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for PetUploadimageAction: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.PetUploadimageAction{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "PetUploadimageAction", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "PetUploadimageAction",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "PetUploadimageAction", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Action CRDs use "Completed" as success state)
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "PetUploadimageAction",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Completed",
		LastSyncTime: existing.Status.LastExecutionTime,
	}, nil
}

// syncUserCreatewithlistAction creates/updates a UserCreatewithlistAction resource
func (r *PetstoreBundleReconciler) syncUserCreatewithlistAction(
	ctx context.Context,
	bundle *v1alpha1.PetstoreBundle,
	name string,
	id string,
	specData []byte,
) (*v1alpha1.BundleResourceStatus, error) {
	logger := log.FromContext(ctx)

	var child v1alpha1.UserCreatewithlistAction
	child.Name = name
	child.Namespace = bundle.Namespace

	// Parse spec
	if err := json.Unmarshal(specData, &child.Spec); err != nil {
		return nil, fmt.Errorf("invalid spec for UserCreatewithlistAction: %w", err)
	}

	// Copy target settings from bundle
	if bundle.Spec.TargetHelmRelease != "" && child.Spec.TargetHelmRelease == "" {
		child.Spec.TargetHelmRelease = bundle.Spec.TargetHelmRelease
	}
	if bundle.Spec.TargetNamespace != "" && child.Spec.TargetNamespace == "" {
		child.Spec.TargetNamespace = bundle.Spec.TargetNamespace
	}

	// Set owner reference for garbage collection
	if err := controllerutil.SetControllerReference(bundle, &child, r.Scheme); err != nil {
		return nil, err
	}

	// Check if resource exists
	existing := &v1alpha1.UserCreatewithlistAction{}
	err := r.Get(ctx, k8stypes.NamespacedName{Name: name, Namespace: bundle.Namespace}, existing)

	now := metav1.Now()
	if errors.IsNotFound(err) {
		// Create new resource
		logger.Info("Creating child resource", "kind", "UserCreatewithlistAction", "name", name)
		if err := r.Create(ctx, &child); err != nil {
			return nil, err
		}
		return &v1alpha1.BundleResourceStatus{
			ID:           id,
			Kind:         "UserCreatewithlistAction",
			Name:         name,
			State:        "Pending",
			LastSyncTime: &now,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Update if spec changed
	if !reflect.DeepEqual(existing.Spec, child.Spec) {
		logger.Info("Updating child resource", "kind", "UserCreatewithlistAction", "name", name)
		existing.Spec = child.Spec
		if err := r.Update(ctx, existing); err != nil {
			return nil, err
		}
	}

	// Return current status (Action CRDs use "Completed" as success state)
	return &v1alpha1.BundleResourceStatus{
		ID:           id,
		Kind:         "UserCreatewithlistAction",
		Name:         name,
		State:        existing.Status.State,
		Message:      existing.Status.Message,
		Ready:        existing.Status.State == "Completed",
		LastSyncTime: existing.Status.LastExecutionTime,
	}, nil
}

// handleDeletion handles bundle deletion - child resources are cleaned up via ownerReferences
func (r *PetstoreBundleReconciler) handleDeletion(ctx context.Context, bundle *v1alpha1.PetstoreBundle) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	if !controllerutil.ContainsFinalizer(bundle, petstorebundleFinalizerName) {
		return ctrl.Result{}, nil
	}

	logger.Info("Handling bundle deletion")

	// Child resources are garbage collected via ownerReferences
	// Just remove the finalizer
	controllerutil.RemoveFinalizer(bundle, petstorebundleFinalizerName)
	if err := r.Update(ctx, bundle); err != nil {
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}

// checkDependenciesReady checks if all dependencies are in a ready state
func (r *PetstoreBundleReconciler) checkDependenciesReady(dependsOn []string, statusMap map[string]*v1alpha1.BundleResourceStatus) bool {
	for _, dep := range dependsOn {
		status, exists := statusMap[dep]
		if !exists {
			return false
		}
		if !status.Ready && !status.Skipped {
			return false
		}
	}
	return true
}

// evaluateConditions evaluates CEL conditions against current resource status
func (r *PetstoreBundleReconciler) evaluateConditions(conditions []string, statusMap map[string]*v1alpha1.BundleResourceStatus, bundle *v1alpha1.PetstoreBundle) (bool, error) {
	// Build variables for CEL evaluation
	resourcesVar := make(map[string]interface{})
	for id, status := range statusMap {
		resourcesVar[id] = map[string]interface{}{
			"status": map[string]interface{}{
				"state":      status.State,
				"externalID": status.ExternalID,
				"message":    status.Message,
				"ready":      status.Ready,
				"skipped":    status.Skipped,
			},
		}
	}

	// For now, evaluate conditions as simple string matches
	// TODO: Implement full CEL evaluation
	for _, condition := range conditions {
		// Simple evaluation: check if condition contains "true"
		if strings.Contains(condition, "true") {
			return true, nil
		}
	}

	return false, nil
}

// resolveExpressions replaces CEL expressions in spec with resolved values
func (r *PetstoreBundleReconciler) resolveExpressions(
	spec k8sruntime.RawExtension,
	statusMap map[string]*v1alpha1.BundleResourceStatus,
	bundle *v1alpha1.PetstoreBundle,
) ([]byte, error) {
	if spec.Raw == nil {
		return []byte("{}"), nil
	}

	// Parse spec as JSON
	var data map[string]interface{}
	if err := json.Unmarshal(spec.Raw, &data); err != nil {
		return nil, err
	}

	// Build resources map for expression resolution
	resourcesVar := make(map[string]interface{})
	for id, status := range statusMap {
		resourcesVar[id] = map[string]interface{}{
			"status": map[string]interface{}{
				"state":      status.State,
				"externalID": status.ExternalID,
				"message":    status.Message,
				"ready":      status.Ready,
			},
		}
	}

	// Recursively resolve expressions
	resolved, err := r.resolveMap(data, resourcesVar)
	if err != nil {
		return nil, err
	}

	return json.Marshal(resolved)
}

// resolveMap recursively resolves CEL expressions in a map
func (r *PetstoreBundleReconciler) resolveMap(
	data map[string]interface{},
	resources map[string]interface{},
) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	for key, value := range data {
		switch v := value.(type) {
		case string:
			// Check if it's a standalone CEL expression: ${...}
			if strings.HasPrefix(v, "${") && strings.HasSuffix(v, "}") && strings.Count(v, "${") == 1 {
				expr := v[2 : len(v)-1]
				resolved, err := r.evaluateSimpleExpression(expr, resources)
				if err != nil {
					return nil, fmt.Errorf("failed to evaluate %s: %w", key, err)
				}
				result[key] = resolved
			} else if strings.Contains(v, "${") {
				// Handle embedded expressions like "prefix-${resources.x.status.y}-suffix"
				resolved, err := r.resolveEmbeddedExpressions(v, resources)
				if err != nil {
					return nil, fmt.Errorf("failed to evaluate embedded expression in %s: %w", key, err)
				}
				result[key] = resolved
			} else {
				result[key] = v
			}
		case map[string]interface{}:
			resolved, err := r.resolveMap(v, resources)
			if err != nil {
				return nil, err
			}
			result[key] = resolved
		case []interface{}:
			resolved, err := r.resolveSlice(v, resources)
			if err != nil {
				return nil, err
			}
			result[key] = resolved
		default:
			result[key] = v
		}
	}

	return result, nil
}

// resolveSlice recursively resolves CEL expressions in a slice
func (r *PetstoreBundleReconciler) resolveSlice(
	data []interface{},
	resources map[string]interface{},
) ([]interface{}, error) {
	result := make([]interface{}, len(data))

	for i, value := range data {
		switch v := value.(type) {
		case string:
			if strings.HasPrefix(v, "${") && strings.HasSuffix(v, "}") && strings.Count(v, "${") == 1 {
				expr := v[2 : len(v)-1]
				resolved, err := r.evaluateSimpleExpression(expr, resources)
				if err != nil {
					return nil, err
				}
				result[i] = resolved
			} else if strings.Contains(v, "${") {
				// Handle embedded expressions
				resolved, err := r.resolveEmbeddedExpressions(v, resources)
				if err != nil {
					return nil, err
				}
				result[i] = resolved
			} else {
				result[i] = v
			}
		case map[string]interface{}:
			resolved, err := r.resolveMap(v, resources)
			if err != nil {
				return nil, err
			}
			result[i] = resolved
		case []interface{}:
			resolved, err := r.resolveSlice(v, resources)
			if err != nil {
				return nil, err
			}
			result[i] = resolved
		default:
			result[i] = v
		}
	}

	return result, nil
}

// evaluateSimpleExpression evaluates a simple path expression like "resources.pet.status.externalID"
// or a CEL function call like "now()" or "addDuration(now(), '24h')"
func (r *PetstoreBundleReconciler) evaluateSimpleExpression(expr string, resources map[string]interface{}) (interface{}, error) {
	// Handle resources.<id>.status.<field> pattern
	if strings.HasPrefix(expr, "resources.") {
		parts := strings.Split(expr[10:], ".")
		if len(parts) < 3 {
			return nil, fmt.Errorf("invalid expression: %s", expr)
		}

		resourceID := parts[0]
		resource, ok := resources[resourceID]
		if !ok {
			return nil, fmt.Errorf("resource not found: %s", resourceID)
		}

		// Navigate the path
		current := resource
		for _, part := range parts[1:] {
			m, ok := current.(map[string]interface{})
			if !ok {
				return nil, fmt.Errorf("cannot navigate path: %s", expr)
			}
			current = m[part]
		}

		// Convert numeric strings to actual numbers for proper JSON marshaling
		// This allows expressions like ${resources.parent.status.externalID} to work
		// with numeric fields like petId: int64
		if str, ok := current.(string); ok {
			// Try to parse as integer first
			if i, err := strconv.ParseInt(str, 10, 64); err == nil {
				return i, nil
			}
			// Try to parse as float
			if f, err := strconv.ParseFloat(str, 64); err == nil {
				return f, nil
			}
			// Not a number, return as string
		}

		return current, nil
	}

	// Handle CEL function calls (expressions containing parentheses)
	// Examples: now(), nowUnix(), addDuration(now(), "24h"), formatTime(nowUnix(), "2006-01-02")
	if strings.Contains(expr, "(") {
		// Create a CEL environment with datetime functions
		env, err := celutil.NewEnvironment([]string{})
		if err != nil {
			return nil, fmt.Errorf("failed to create CEL environment: %w", err)
		}

		// Provide empty variables (CEL functions like now() don't need variables)
		vars := map[string]interface{}{
			"resources": []map[string]interface{}{},
			"summary":   map[string]int64{"total": 0},
		}

		result := celutil.Evaluate(env, expr, vars)
		if result.Error != nil {
			return nil, fmt.Errorf("CEL evaluation failed: %w", result.Error)
		}

		return result.Value, nil
	}

	return nil, fmt.Errorf("unsupported expression: %s", expr)
}

// resolveEmbeddedExpressions handles strings with embedded expressions like "prefix-${resources.x.status.y}-suffix".
// It replaces all ${...} patterns within the string with their resolved values.
// The result is always a string since we're doing string interpolation.
func (r *PetstoreBundleReconciler) resolveEmbeddedExpressions(s string, resources map[string]interface{}) (string, error) {
	result := s
	for {
		start := strings.Index(result, "${")
		if start == -1 {
			break
		}
		end := strings.Index(result[start:], "}")
		if end == -1 {
			return "", fmt.Errorf("unclosed expression in: %s", s)
		}
		end += start // Adjust to absolute position

		expr := result[start+2 : end]
		resolved, err := r.evaluateSimpleExpression(expr, resources)
		if err != nil {
			return "", err
		}

		// Convert resolved value to string for interpolation
		var strValue string
		switch v := resolved.(type) {
		case string:
			strValue = v
		case int64:
			strValue = strconv.FormatInt(v, 10)
		case float64:
			strValue = strconv.FormatFloat(v, 'f', -1, 64)
		case bool:
			strValue = strconv.FormatBool(v)
		default:
			strValue = fmt.Sprintf("%v", v)
		}

		result = result[:start] + strValue + result[end+1:]
	}
	return result, nil
}

// calculateSummary computes resource counts from statuses using shared classification logic
func (r *PetstoreBundleReconciler) calculateSummary(statuses []v1alpha1.BundleResourceStatus) v1alpha1.BundleSummary {
	var counter celutil.SummaryCounter
	for _, s := range statuses {
		counter.Add(s.State)
	}

	return v1alpha1.BundleSummary{
		Total:   int(counter.Total),
		Synced:  int(counter.Synced),
		Failed:  int(counter.Failed),
		Pending: int(counter.Pending),
		Skipped: int(counter.Skipped),
	}
}

// calculateAggregatedHealth computes Aggregate CRD-compatible health status from bundle resources.
// This provides consistent health reporting semantics between Bundle and Aggregate CRDs.
func (r *PetstoreBundleReconciler) calculateAggregatedHealth(bundle *v1alpha1.PetstoreBundle) *v1alpha1.BundleAggregatedHealth {
	now := metav1.Now()

	// Convert BundleResourceStatus to AggregatedResourceStatus for consistency
	aggregatedResources := make([]v1alpha1.AggregatedResourceStatus, 0, len(bundle.Status.Resources))
	for _, res := range bundle.Status.Resources {
		// Map Bundle states to Aggregate-compatible states
		state := res.State
		switch res.State {
		case "Queried", "Completed":
			state = "Synced" // Normalize to Aggregate CRD's Synced state
		case "Creating":
			state = "Pending"
		}

		aggregatedResources = append(aggregatedResources, v1alpha1.AggregatedResourceStatus{
			Kind:         res.Kind,
			Name:         res.Name,
			Namespace:    bundle.Namespace,
			State:        state,
			ExternalID:   res.ExternalID,
			Message:      res.Message,
			LastSyncTime: res.LastSyncTime,
		})
	}

	// Convert BundleSummary to AggregateSummary
	aggSummary := bundle.Status.Summary.ToAggregateSummary()

	// Determine aggregated health state using the same strategy as Aggregate CRD
	strategy := bundle.Spec.AggregationStrategy
	if strategy == "" {
		strategy = "AllHealthy"
	}

	healthState := r.evaluateAggregationStrategy(strategy, aggSummary)

	return &v1alpha1.BundleAggregatedHealth{
		State:               healthState,
		Summary:             aggSummary,
		Resources:           aggregatedResources,
		LastAggregationTime: &now,
		// ComputedValues will be populated separately if DerivedValues are specified
	}
}

// evaluateAggregationStrategy determines the health state using Aggregate CRD semantics
func (r *PetstoreBundleReconciler) evaluateAggregationStrategy(strategy string, summary v1alpha1.AggregateSummary) string {
	if summary.Total == 0 {
		return "Unknown"
	}

	switch strategy {
	case "AllHealthy":
		// All resources must be synced
		if summary.Failed > 0 {
			return "Degraded"
		}
		if summary.Pending > 0 {
			return "Pending"
		}
		if summary.Synced == summary.Total {
			return "Healthy"
		}
		return "Pending"

	case "AnyHealthy":
		// At least one resource must be synced
		if summary.Synced > 0 {
			return "Healthy"
		}
		if summary.Failed == summary.Total {
			return "Degraded"
		}
		return "Pending"

	case "Quorum":
		// Majority of resources must be synced
		quorum := (summary.Total / 2) + 1
		if summary.Synced >= quorum {
			return "Healthy"
		}
		if summary.Failed > summary.Total-quorum {
			return "Degraded" // Can't reach quorum
		}
		return "Pending"

	default:
		return "Unknown"
	}
}

func (r *PetstoreBundleReconciler) updateBundleStatus(ctx context.Context, bundle *v1alpha1.PetstoreBundle, state, message string) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	bundle.Status.State = state
	bundle.Status.Message = message
	bundle.Status.ObservedGeneration = bundle.Generation

	// Update operation state
	if bundle.Status.OperationState == nil {
		bundle.Status.OperationState = &v1alpha1.BundleOperationState{}
	}
	// Map bundle state to operation phase (Phase enum: Pending, Running, Succeeded, Failed)
	switch state {
	case "Synced":
		bundle.Status.OperationState.Phase = "Succeeded"
	case "Failed":
		bundle.Status.OperationState.Phase = "Failed"
	case "Pending", "Creating":
		bundle.Status.OperationState.Phase = "Running"
	default:
		bundle.Status.OperationState.Phase = "Pending"
	}
	bundle.Status.OperationState.Message = message
	if state == "Synced" || state == "Failed" {
		bundle.Status.OperationState.FinishedAt = &now
	}

	// Calculate and set Aggregate CRD-compatible health status
	bundle.Status.AggregatedHealth = r.calculateAggregatedHealth(bundle)

	// Evaluate derived values if configured
	if len(bundle.Spec.DerivedValues) > 0 {
		bundle.Status.AggregatedHealth.ComputedValues = r.evaluateDerivedValues(ctx, bundle)
	}

	// Set conditions
	r.setConditions(ctx, bundle, state, message)

	if err := r.Status().Update(ctx, bundle); err != nil {
		logger.Error(err, "Failed to update status")
		return ctrl.Result{}, err
	}

	return ctrl.Result{RequeueAfter: petstorebundleRequeueAfter}, nil
}

// setConditions sets the status conditions based on bundle state
func (r *PetstoreBundleReconciler) setConditions(ctx context.Context, bundle *v1alpha1.PetstoreBundle, state, message string) {
	now := metav1.Now()

	// Ready condition
	readyCondition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Synced" {
		readyCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, readyCondition)

	// Progressing condition
	progressingCondition := metav1.Condition{
		Type:               "Progressing",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Syncing" || state == "Pending" {
		progressingCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, progressingCondition)

	// HasFailures condition
	hasFailuresCondition := metav1.Condition{
		Type:               "HasFailures",
		Status:             metav1.ConditionFalse,
		Reason:             "NoFailures",
		Message:            "No resources have failed",
		LastTransitionTime: now,
	}
	if bundle.Status.Summary.Failed > 0 {
		hasFailuresCondition.Status = metav1.ConditionTrue
		hasFailuresCondition.Reason = "ResourcesFailed"
		hasFailuresCondition.Message = fmt.Sprintf("%d resources have failed", bundle.Status.Summary.Failed)
	}
	meta.SetStatusCondition(&bundle.Status.Conditions, hasFailuresCondition)
}

// evaluateDerivedValues evaluates CEL expressions from spec.derivedValues.
// Uses the same CEL evaluation as Aggregate CRD for consistency.
func (r *PetstoreBundleReconciler) evaluateDerivedValues(ctx context.Context, bundle *v1alpha1.PetstoreBundle) []v1alpha1.ComputedValue {
	logger := log.FromContext(ctx)
	var results []v1alpha1.ComputedValue

	// Build CEL data from bundle resources
	celResources, celDataByKind := r.buildCELData(ctx, bundle)

	// Create CEL environment using the shared utility
	kindNames := []string{
		"orders",
		"pets",
		"users",
		"petfindbystatusqueries",
		"petfindbytagsqueries",
		"storeinventoryqueries",
		"userloginqueries",
		"userlogoutqueries",
		"petuploadimageactions",
		"usercreatewithlistactions",
	}
	// Collect resource-specific keys using {kind}-{name} convention
	resourceKeys := celutil.CollectResourceKeys(celResources)
	env, err := celutil.NewEnvironmentWithResources(kindNames, resourceKeys)
	if err != nil {
		logger.Error(err, "Failed to create CEL environment")
		for _, dv := range bundle.Spec.DerivedValues {
			results = append(results, v1alpha1.ComputedValue{
				Name:  dv.Name,
				Error: fmt.Sprintf("failed to create CEL environment: %v", err),
			})
		}
		return results
	}

	// Build evaluation variables using the shared utility (includes skipped for Bundle and resource-specific variables)
	celSummary := celutil.BuildSummaryWithSkipped(
		int64(bundle.Status.Summary.Total),
		int64(bundle.Status.Summary.Synced),
		int64(bundle.Status.Summary.Failed),
		int64(bundle.Status.Summary.Pending),
		int64(bundle.Status.Summary.Skipped),
	)
	evalVars := celutil.BuildVariablesWithResources(celResources, celSummary, celDataByKind)

	// Evaluate each derived value expression
	for _, dv := range bundle.Spec.DerivedValues {
		result := v1alpha1.ComputedValue{Name: dv.Name}

		// Use the shared evaluation function
		evalResult := celutil.Evaluate(env, dv.Expression, evalVars)
		if evalResult.Error != nil {
			result.Error = evalResult.Error.Error()
			results = append(results, result)
			continue
		}

		// Convert result to string using the shared utility
		result.Value = celutil.ValueToString(evalResult.RawValue)
		results = append(results, result)

		logger.V(1).Info("Evaluated CEL expression",
			"name", dv.Name,
			"expression", dv.Expression,
			"result", result.Value)
	}

	return results
}

// buildCELData builds CEL-compatible data structures from bundle resources
func (r *PetstoreBundleReconciler) buildCELData(ctx context.Context, bundle *v1alpha1.PetstoreBundle) ([]map[string]interface{}, map[string][]map[string]interface{}) {
	celResources := make([]map[string]interface{}, 0)
	celDataByKind := make(map[string][]map[string]interface{})

	// Initialize kind-specific lists
	celDataByKind["orders"] = make([]map[string]interface{}, 0)
	celDataByKind["pets"] = make([]map[string]interface{}, 0)
	celDataByKind["users"] = make([]map[string]interface{}, 0)
	celDataByKind["petfindbystatusqueries"] = make([]map[string]interface{}, 0)
	celDataByKind["petfindbytagsqueries"] = make([]map[string]interface{}, 0)
	celDataByKind["storeinventoryqueries"] = make([]map[string]interface{}, 0)
	celDataByKind["userloginqueries"] = make([]map[string]interface{}, 0)
	celDataByKind["userlogoutqueries"] = make([]map[string]interface{}, 0)
	celDataByKind["petuploadimageactions"] = make([]map[string]interface{}, 0)
	celDataByKind["usercreatewithlistactions"] = make([]map[string]interface{}, 0)

	// Convert each bundle resource status to CEL data
	for _, resStatus := range bundle.Status.Resources {
		// Find the corresponding spec to get the full data
		var resSpec *v1alpha1.BundleResourceSpec
		for i := range bundle.Spec.Resources {
			if bundle.Spec.Resources[i].ID == resStatus.ID {
				resSpec = &bundle.Spec.Resources[i]
				break
			}
		}

		celData := r.bundleResourceToCELData(resStatus, resSpec, bundle)
		celResources = append(celResources, celData)

		// Add to kind-specific list
		kindKey := aggregate.KindToVariableName(resStatus.Kind)
		if _, ok := celDataByKind[kindKey]; ok {
			celDataByKind[kindKey] = append(celDataByKind[kindKey], celData)
		}
	}

	return celResources, celDataByKind
}

// bundleResourceToCELData converts a bundle resource to a CEL-compatible map
func (r *PetstoreBundleReconciler) bundleResourceToCELData(
	resStatus v1alpha1.BundleResourceStatus,
	resSpec *v1alpha1.BundleResourceSpec,
	bundle *v1alpha1.PetstoreBundle,
) map[string]interface{} {
	result := map[string]interface{}{
		"kind": resStatus.Kind,
		"metadata": map[string]interface{}{
			"name":      resStatus.Name,
			"namespace": bundle.Namespace,
		},
		"status": map[string]interface{}{
			"state":      resStatus.State,
			"externalID": resStatus.ExternalID,
			"message":    resStatus.Message,
			"ready":      resStatus.Ready,
			"skipped":    resStatus.Skipped,
		},
	}

	// Include spec data if available
	if resSpec != nil {
		// Parse the raw extension to get spec data
		var specData map[string]interface{}
		if resSpec.Spec.Raw != nil {
			if err := json.Unmarshal(resSpec.Spec.Raw, &specData); err == nil {
				result["spec"] = specData
			} else {
				result["spec"] = map[string]interface{}{}
			}
		} else {
			result["spec"] = map[string]interface{}{}
		}
	} else {
		result["spec"] = map[string]interface{}{}
	}

	return result
}

// SetupWithManager sets up the controller with the Manager
func (r *PetstoreBundleReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.PetstoreBundle{}).
		// Watch owned resources - they are created with ownerReferences
		Owns(&v1alpha1.Order{}).
		Owns(&v1alpha1.Pet{}).
		Owns(&v1alpha1.User{}).
		Owns(&v1alpha1.PetFindbystatusQuery{}).
		Owns(&v1alpha1.PetFindbytagsQuery{}).
		Owns(&v1alpha1.StoreInventoryQuery{}).
		Owns(&v1alpha1.UserLoginQuery{}).
		Owns(&v1alpha1.UserLogoutQuery{}).
		Owns(&v1alpha1.PetUploadimageAction{}).
		Owns(&v1alpha1.UserCreatewithlistAction{}).
		Complete(r)
}
