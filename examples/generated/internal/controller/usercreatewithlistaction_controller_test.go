/*
Copyright 2026 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"

	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

// =============================================================================
// E2E Testing with Fake Client
// =============================================================================

// reconcileUntilComplete runs the reconciler in a loop until no requeue is requested
// or maxIterations is reached. This simulates the controller-runtime behavior.
func reconcileUserCreatewithlistActionUntilComplete(
	t *testing.T,
	ctx context.Context,
	reconciler *UserCreatewithlistActionReconciler,
	req ctrl.Request,
	maxIterations int,
) (finalResult ctrl.Result, finalErr error, iterations int) {
	t.Helper()

	for i := 0; i < maxIterations; i++ {
		iterations = i + 1
		result, err := reconciler.Reconcile(ctx, req)

		if err != nil {
			return result, err, iterations
		}

		// If no requeue requested, we're done
		if !result.Requeue && result.RequeueAfter == 0 {
			return result, nil, iterations
		}

		t.Logf("Reconcile iteration %d: Requeue=%v, RequeueAfter=%v", iterations, result.Requeue, result.RequeueAfter)

		// In tests, we don't actually wait for RequeueAfter duration
		// Just continue to next iteration immediately
	}

	return ctrl.Result{}, nil, iterations
}

func TestUserCreatewithlistActionReconciler_E2E(t *testing.T) {
	// Setup scheme
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	// Create mock HTTP server that returns appropriate response types
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		// Sample resource object
		sampleResource := map[string]interface{}{
			"id":   123,
			"name": "TestUserCreatewithlistAction",
		}

		switch r.Method {
		case http.MethodGet:
			// Response is a single object per OpenAPI spec
			json.NewEncoder(w).Encode(sampleResource)
		case http.MethodPost:
			// Return created resource
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(sampleResource)
		case http.MethodPut:
			// Return updated resource
			json.NewEncoder(w).Encode(map[string]interface{}{
				"id":   123,
				"name": "UpdatedUserCreatewithlistAction",
			})
		case http.MethodDelete:
			w.WriteHeader(http.StatusNoContent)
		default:
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
	}))
	defer server.Close()

	// Create test CR
	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	// Create fake client with the object
	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	// Create reconciler
	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	// Run reconcile loop until complete (max 10 iterations)
	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	result, err, iterations := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 10)

	// Verify no error
	if err != nil {
		t.Fatalf("Reconcile returned error after %d iterations: %v", iterations, err)
	}

	t.Logf("Reconcile completed after %d iterations", iterations)

	// Verify final result (should have periodic requeue for sync)
	if result.RequeueAfter > 0 {
		t.Logf("Final result requests requeue after %v", result.RequeueAfter)
	}

	// Verify status was updated
	var updated v1alpha1.UserCreatewithlistAction
	if err := fakeClient.Get(ctx, types.NamespacedName{Name: "test-usercreatewithlistaction", Namespace: "default"}, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	if updated.Status.State == "" {
		t.Error("expected status.state to be set")
	}
}

func TestUserCreatewithlistActionReconciler_RequeueBehavior(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	// Track request count
	requestCount := 0

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestCount++
		w.Header().Set("Content-Type", "application/json")

		sampleResource := map[string]interface{}{
			"id":   123,
			"name": "TestUserCreatewithlistAction",
		}

		switch r.Method {
		case http.MethodPost:
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(sampleResource)
		case http.MethodGet:
			json.NewEncoder(w).Encode(sampleResource)
		default:
			json.NewEncoder(w).Encode(sampleResource)
		}
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	// First reconcile
	result1, err := reconciler.Reconcile(ctx, req)
	if err != nil {
		t.Fatalf("First reconcile failed: %v", err)
	}

	// Check if requeue was requested
	if result1.Requeue || result1.RequeueAfter > 0 {
		t.Logf("First reconcile requested requeue: Requeue=%v, RequeueAfter=%v", result1.Requeue, result1.RequeueAfter)

		// Simulate the requeue by running reconcile again
		result2, err := reconciler.Reconcile(ctx, req)
		if err != nil {
			t.Fatalf("Second reconcile failed: %v", err)
		}
		t.Logf("Second reconcile: Requeue=%v, RequeueAfter=%v", result2.Requeue, result2.RequeueAfter)
	}

	t.Logf("Total HTTP requests made: %d", requestCount)
}

func TestUserCreatewithlistActionReconciler_CreateResource(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	// Track HTTP requests
	var receivedMethod string
	var receivedPath string
	var receivedBody map[string]interface{}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		receivedMethod = r.Method
		receivedPath = r.URL.Path
		w.Header().Set("Content-Type", "application/json")

		sampleResource := map[string]interface{}{
			"id":   456,
			"name": "NewUserCreatewithlistAction",
		}

		switch r.Method {
		case http.MethodPost:
			json.NewDecoder(r.Body).Decode(&receivedBody)
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(sampleResource)
		case http.MethodGet:
			json.NewEncoder(w).Encode(sampleResource)
		default:
			json.NewEncoder(w).Encode(sampleResource)
		}
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "new-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "new-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	// Run reconcile loop to handle any requeues
	_, err, iterations := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 10)

	if err != nil {
		t.Fatalf("Reconcile returned error: %v", err)
	}

	// Verify HTTP request was made
	if receivedMethod == "" {
		t.Error("expected HTTP request to be made")
	}

	t.Logf("HTTP request: %s %s (after %d iterations)", receivedMethod, receivedPath, iterations)
}

// =============================================================================
// Controller HTTP Error Handling Tests
// =============================================================================

func TestUserCreatewithlistActionReconciler_HTTPNotFound(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	// Server returns 404 Not Found
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusNotFound)
		json.NewEncoder(w).Encode(map[string]string{
			"error": "resource not found",
		})
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	_, err, _ := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 5)

	// Verify the reconciler handled the 404 (may or may not be an error depending on implementation)
	if err != nil {
		t.Logf("Reconciler returned error on 404: %v", err)
	}

	// Check that status was updated to reflect the error
	var updated v1alpha1.UserCreatewithlistAction
	if err := fakeClient.Get(ctx, req.NamespacedName, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	t.Logf("Status after 404: State=%s, Message=%s", updated.Status.State, updated.Status.Message)
}

func TestUserCreatewithlistActionReconciler_HTTPServerError(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	requestCount := 0

	// Server returns 500 Internal Server Error
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestCount++
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{
			"error": "internal server error",
		})
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	result, err, iterations := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 3)

	t.Logf("After %d iterations: err=%v, requeue=%v, requeueAfter=%v", iterations, err, result.Requeue, result.RequeueAfter)
	t.Logf("Total HTTP requests made: %d", requestCount)

	// Check status reflects the error
	var updated v1alpha1.UserCreatewithlistAction
	if err := fakeClient.Get(ctx, req.NamespacedName, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	// Status should indicate an error state
	if updated.Status.State == "" {
		t.Log("Warning: status.state not set after server error")
	} else {
		t.Logf("Status after 500: State=%s", updated.Status.State)
	}
}

func TestUserCreatewithlistActionReconciler_HTTPUnauthorized(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	// Server returns 401 Unauthorized
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnauthorized)
		json.NewEncoder(w).Encode(map[string]string{
			"error": "unauthorized",
		})
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	_, err, _ := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 3)

	// Check status reflects auth error
	var updated v1alpha1.UserCreatewithlistAction
	if fetchErr := fakeClient.Get(ctx, req.NamespacedName, &updated); fetchErr != nil {
		t.Fatalf("failed to get updated object: %v", fetchErr)
	}

	t.Logf("Reconciler result on 401: err=%v, status.State=%s", err, updated.Status.State)
}

func TestUserCreatewithlistActionReconciler_HTTPRateLimited(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	requestCount := 0

	// Server returns 429 Too Many Requests, then succeeds
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestCount++
		w.Header().Set("Content-Type", "application/json")

		if requestCount <= 2 {
			w.Header().Set("Retry-After", "1")
			w.WriteHeader(http.StatusTooManyRequests)
			json.NewEncoder(w).Encode(map[string]string{
				"error": "rate limited",
			})
			return
		}

		// After rate limiting, return success
		json.NewEncoder(w).Encode(map[string]interface{}{
			"id":   123,
			"name": "TestUserCreatewithlistAction",
		})
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	_, err, iterations := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 5)

	t.Logf("Completed after %d iterations, %d HTTP requests, err=%v", iterations, requestCount, err)

	// Verify eventual success after rate limiting
	var updated v1alpha1.UserCreatewithlistAction
	if err := fakeClient.Get(ctx, req.NamespacedName, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	t.Logf("Final status: State=%s", updated.Status.State)
}

func TestUserCreatewithlistActionReconciler_HTTPInvalidJSON(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	// Server returns invalid JSON
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("this is not valid json"))
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	_, err, _ := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 3)

	// Check how controller handles invalid JSON
	var updated v1alpha1.UserCreatewithlistAction
	if fetchErr := fakeClient.Get(ctx, req.NamespacedName, &updated); fetchErr != nil {
		t.Fatalf("failed to get updated object: %v", fetchErr)
	}

	t.Logf("Reconciler result on invalid JSON: err=%v, status.State=%s", err, updated.Status.State)
}

func TestUserCreatewithlistActionReconciler_HTTPTimeout(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	// Server that delays response
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(200 * time.Millisecond)
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"id":   123,
			"name": "TestUserCreatewithlistAction",
		})
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	// Create HTTP client with short timeout
	httpClient := &http.Client{
		Timeout: 50 * time.Millisecond,
	}

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: httpClient,
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	result, err, iterations := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 3)

	t.Logf("After %d iterations: err=%v, requeue=%v", iterations, err, result.Requeue || result.RequeueAfter > 0)

	// Check status reflects timeout
	var updated v1alpha1.UserCreatewithlistAction
	if fetchErr := fakeClient.Get(ctx, req.NamespacedName, &updated); fetchErr != nil {
		t.Fatalf("failed to get updated object: %v", fetchErr)
	}

	t.Logf("Status after timeout: State=%s, Message=%s", updated.Status.State, updated.Status.Message)
}

// =============================================================================
// URL Construction and Consistency Tests
// =============================================================================

// httpRequestUserCreatewithlistAction captures details of an HTTP request for test validation
type httpRequestUserCreatewithlistAction struct {
	Method string
	URL    string
	Body   map[string]interface{}
}

// TestUserCreatewithlistActionReconciler_URLAndResponseConsistency verifies that:
// 1. CR spec values are correctly used in HTTP request URLs
// 2. HTTP response values match what was requested
// 3. The correct HTTP method is used for the endpoint type
func TestUserCreatewithlistActionReconciler_URLAndResponseConsistency(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	// Define test ID that will be used consistently across spec, URL, and response
	const testResourceID = "test-resource-42"
	const testResourceIDNumeric int64 = 42

	// Track all received requests
	var receivedRequests []httpRequestUserCreatewithlistAction

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Capture request details
		fullURL := r.URL.Path
		if r.URL.RawQuery != "" {
			fullURL += "?" + r.URL.RawQuery
		}

		var bodyMap map[string]interface{}
		if r.Body != nil && r.Method != http.MethodGet && r.Method != http.MethodDelete {
			json.NewDecoder(r.Body).Decode(&bodyMap)
		}

		receivedRequests = append(receivedRequests, httpRequestUserCreatewithlistAction{
			Method: r.Method,
			URL:    fullURL,
			Body:   bodyMap,
		})

		w.Header().Set("Content-Type", "application/json")

		// Response with consistent ID matching what was requested
		responseResource := map[string]interface{}{
			"id":   testResourceIDNumeric,
			"name": "TestUserCreatewithlistAction",
		}

		switch r.Method {
		case http.MethodPost:
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(responseResource)
		case http.MethodGet:
			json.NewEncoder(w).Encode(responseResource)
		case http.MethodPut:
			json.NewEncoder(w).Encode(responseResource)
		case http.MethodDelete:
			w.WriteHeader(http.StatusNoContent)
		default:
			json.NewEncoder(w).Encode(responseResource)
		}
	}))
	defer server.Close()

	// Create CR with specific values that should appear in the URL
	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{
		},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	_, err, iterations := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 10)

	if err != nil {
		t.Fatalf("Reconcile returned error after %d iterations: %v", iterations, err)
	}

	// === Validation 1: At least one request was made ===
	if len(receivedRequests) == 0 {
		t.Fatal("expected at least one HTTP request to be made")
	}

	// Log all received requests for debugging
	t.Logf("Received %d HTTP requests:", len(receivedRequests))
	for i, req := range receivedRequests {
		t.Logf("  [%d] %s %s", i+1, req.Method, req.URL)
		if req.Body != nil {
			t.Logf("      Body: %v", req.Body)
		}
	}

	// === Validation 2: Correct HTTP method was used ===
	methodCounts := make(map[string]int)
	for _, req := range receivedRequests {
		methodCounts[req.Method]++
	}
	t.Logf("HTTP method counts: %v", methodCounts)
	expectedMethod := "POST"
	if expectedMethod == "" {
		expectedMethod = http.MethodPost
	}
	if methodCounts[expectedMethod] == 0 {
		t.Errorf("expected at least one %s request for action endpoint, got methods: %v", expectedMethod, methodCounts)
	}

	// === Validation 3: Correct path was used ===
	expectedPath := "/user/createWithList"

	foundCorrectPath := false
	for _, req := range receivedRequests {
		// Extract just the path part (without query string) for comparison
		reqPath := req.URL
		if idx := strings.Index(reqPath, "?"); idx != -1 {
			reqPath = reqPath[:idx]
		}

		if reqPath == expectedPath || strings.HasPrefix(reqPath, expectedPath) || strings.HasPrefix(reqPath+"/", expectedPath) {
			foundCorrectPath = true
			t.Logf("Found expected path %q in URL: %s", expectedPath, req.URL)
			break
		}
	}

	if !foundCorrectPath {
		t.Errorf("expected URL path %q, but none of the requests matched. Received URLs:", expectedPath)
		for _, req := range receivedRequests {
			t.Errorf("  %s %s", req.Method, req.URL)
		}
	}

	// === Validation 4: Verify status was updated correctly ===
	var updated v1alpha1.UserCreatewithlistAction
	if err := fakeClient.Get(ctx, types.NamespacedName{Name: "test-usercreatewithlistaction", Namespace: "default"}, &updated); err != nil {
		t.Fatalf("failed to get updated object: %v", err)
	}

	if updated.Status.State == "" {
		t.Error("expected status.State to be set after reconciliation")
	}
	t.Logf("Final status: State=%s, Message=%s", updated.Status.State, updated.Status.Message)
}
// TestUserCreatewithlistActionReconciler_ActionPathParams verifies that action endpoints
// correctly use path parameters from spec in the URL
func TestUserCreatewithlistActionReconciler_ActionPathParams(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = v1alpha1.AddToScheme(scheme)

	var receivedRequests []httpRequestUserCreatewithlistAction

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fullURL := r.URL.Path
		if r.URL.RawQuery != "" {
			fullURL += "?" + r.URL.RawQuery
		}

		var bodyMap map[string]interface{}
		if r.Body != nil {
			json.NewDecoder(r.Body).Decode(&bodyMap)
		}

		receivedRequests = append(receivedRequests, httpRequestUserCreatewithlistAction{
			Method: r.Method,
			URL:    fullURL,
			Body:   bodyMap,
		})

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
		})
	}))
	defer server.Close()

	obj := &v1alpha1.UserCreatewithlistAction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
		Spec: v1alpha1.UserCreatewithlistActionSpec{
		},
	}

	fakeClient := fake.NewClientBuilder().
		WithScheme(scheme).
		WithObjects(obj).
		WithStatusSubresource(obj).
		Build()

	reconciler := &UserCreatewithlistActionReconciler{
		Client:     fakeClient,
		Scheme:     scheme,
		HTTPClient: server.Client(),
		BaseURL:    server.URL,
	}

	ctx := context.Background()
	req := ctrl.Request{
		NamespacedName: types.NamespacedName{
			Name:      "test-usercreatewithlistaction",
			Namespace: "default",
		},
	}

	_, err, iterations := reconcileUserCreatewithlistActionUntilComplete(t, ctx, reconciler, req, 10)

	if err != nil {
		t.Fatalf("Reconcile returned error after %d iterations: %v", iterations, err)
	}

	// Log requests
	t.Logf("Received %d HTTP requests:", len(receivedRequests))
	for i, req := range receivedRequests {
		t.Logf("  [%d] %s %s", i+1, req.Method, req.URL)
		if req.Body != nil {
			t.Logf("      Body: %v", req.Body)
		}
	}

	// Verify at least one request was made
	if len(receivedRequests) == 0 {
		t.Fatal("expected at least one HTTP request")
	}

	// Verify correct HTTP method
	expectedMethod := "POST"
	if expectedMethod == "" {
		expectedMethod = http.MethodPost
	}

	foundMethod := false
	for _, req := range receivedRequests {
		if req.Method == expectedMethod {
			foundMethod = true
			break
		}
	}

	if !foundMethod {
		t.Errorf("expected %s request for action endpoint", expectedMethod)
	}

	// Build expected URL by replacing path parameter placeholders with actual values
	expectedActionPath := "/user/createWithList"

	foundActionPath := false
	for _, req := range receivedRequests {
		// Extract just the path part (without query string)
		reqPath := req.URL
		if idx := strings.Index(reqPath, "?"); idx != -1 {
			reqPath = reqPath[:idx]
		}

		if reqPath == expectedActionPath {
			foundActionPath = true
			t.Logf("Found expected action path %q in URL: %s", expectedActionPath, req.URL)
			break
		}
	}

	if !foundActionPath {
		t.Errorf("expected action path %q, but none of the requests matched. Received URLs:", expectedActionPath)
		for _, req := range receivedRequests {
			t.Errorf("  %s %s", req.Method, req.URL)
		}
	}
}

