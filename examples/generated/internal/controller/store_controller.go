/*
Copyright 2026 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

const (
	storeFinalizer    = "petstore.example.com/finalizer"
	storeRequeueAfter = time.Second * 30
)

// StoreReconciler reconciles a Store object
type StoreReconciler struct {
	client.Client
	Scheme           *runtime.Scheme
	HTTPClient       *http.Client
	EndpointResolver *endpoint.Resolver
	// BaseURL is used when EndpointResolver is nil (static URL mode)
	BaseURL string
}

// +kubebuilder:rbac:groups=petstore.example.com,resources=stores,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=stores/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=petstore.example.com,resources=stores/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop
func (r *StoreReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the Store instance
	instance := &v1alpha1.Store{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("Store resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get Store")
		return ctrl.Result{}, err
	}

	// Check if the resource is being deleted
	if instance.GetDeletionTimestamp() != nil {
		if controllerutil.ContainsFinalizer(instance, storeFinalizer) {
			// Run finalization logic
			if err := r.finalizeResource(ctx, instance); err != nil {
				return ctrl.Result{}, err
			}

			// Remove finalizer
			controllerutil.RemoveFinalizer(instance, storeFinalizer)
			if err := r.Update(ctx, instance); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	// Add finalizer if not present
	if !controllerutil.ContainsFinalizer(instance, storeFinalizer) {
		controllerutil.AddFinalizer(instance, storeFinalizer)
		if err := r.Update(ctx, instance); err != nil {
			return ctrl.Result{}, err
		}
	}

	// Sync with REST API
	if err := r.syncResource(ctx, instance); err != nil {
		// Update status to failed
		r.updateStatus(ctx, instance, "Failed", err.Error())
		return ctrl.Result{RequeueAfter: storeRequeueAfter}, err
	}

	return ctrl.Result{RequeueAfter: storeRequeueAfter}, nil
}

func (r *StoreReconciler) getBaseURL(ctx context.Context) (string, error) {
	if r.EndpointResolver != nil {
		return r.EndpointResolver.GetEndpoint()
	}
	if r.BaseURL == "" {
		return "", fmt.Errorf("no base URL configured")
	}
	return r.BaseURL, nil
}

func (r *StoreReconciler) getAllBaseURLs(ctx context.Context) ([]string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		return r.EndpointResolver.GetAllHealthyEndpoints()
	}
	// For non-all-healthy strategies, return single endpoint as slice
	url, err := r.getBaseURL(ctx)
	if err != nil {
		return nil, err
	}
	return []string{url}, nil
}

func (r *StoreReconciler) getBaseURLByOrdinal(ctx context.Context, ordinal *int32) (string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		if ordinal == nil {
			return "", fmt.Errorf("targetPodOrdinal is required when using by-ordinal strategy")
		}
		return r.EndpointResolver.GetEndpointByOrdinal(int(*ordinal))
	}
	// Fall back to regular endpoint selection if not using by-ordinal strategy
	return r.getBaseURL(ctx)
}

// syncToEndpoint syncs to a single endpoint URL.
// On success, it updates instance.Status.ExternalID and instance.Status.Response.
// The caller is responsible for calling updateStatus after this returns.
func (r *StoreReconciler) syncToEndpoint(ctx context.Context, instance *v1alpha1.Store, baseURL string) error {
	logger := log.FromContext(ctx)

	isCreate := instance.Status.ExternalID == ""
	var method, url string
	if isCreate {
		method = "POST"
		url = baseURL + "/store"
	} else {
		method = "PUT"
		url = baseURL + "/store/" + instance.Status.ExternalID
	}

	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, method, url, bytes.NewReader(specData))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Syncing resource", "method", method, "url", url)
	resp, err := r.HTTPClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("API error: %s - %s", resp.Status, string(body))
	}

	// Parse response to extract ID
	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err == nil {
		if id, ok := respData["id"]; ok {
			switch v := id.(type) {
			case string:
				instance.Status.ExternalID = v
			case float64:
				instance.Status.ExternalID = fmt.Sprintf("%.0f", v)
			}
		}
	}

	instance.Status.Response = &runtime.RawExtension{Raw: body}
	return nil
}

func (r *StoreReconciler) syncResource(ctx context.Context, instance *v1alpha1.Store) error {
	logger := log.FromContext(ctx)

	// Handle per-CR targeting (Helm release, StatefulSet, or Deployment)
	if r.EndpointResolver != nil {
		namespace := instance.Spec.TargetNamespace
		if namespace == "" {
			namespace = instance.Namespace
		}

		// Per-CR Helm release targeting
		if instance.Spec.TargetHelmRelease != "" {
			baseURL, err := r.EndpointResolver.GetEndpointForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace, instance.Spec.TargetPodOrdinal)
			if err != nil {
				return fmt.Errorf("failed to get endpoint for Helm release %s: %w", instance.Spec.TargetHelmRelease, err)
			}
			logger.Info("Using per-CR Helm release endpoint", "helmRelease", instance.Spec.TargetHelmRelease, "namespace", namespace, "baseURL", baseURL)
			if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
				return err
			}
			r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
			return nil
		}

		// Per-CR StatefulSet targeting
		if instance.Spec.TargetStatefulSet != "" {
			baseURL, err := r.EndpointResolver.GetEndpointForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace, instance.Spec.TargetPodOrdinal)
			if err != nil {
				return fmt.Errorf("failed to get endpoint for StatefulSet %s: %w", instance.Spec.TargetStatefulSet, err)
			}
			logger.Info("Using per-CR StatefulSet endpoint", "statefulset", instance.Spec.TargetStatefulSet, "namespace", namespace, "baseURL", baseURL)
			if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
				return err
			}
			r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
			return nil
		}

		// Per-CR Deployment targeting
		if instance.Spec.TargetDeployment != "" {
			baseURL, err := r.EndpointResolver.GetEndpointForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
			if err != nil {
				return fmt.Errorf("failed to get endpoint for Deployment %s: %w", instance.Spec.TargetDeployment, err)
			}
			logger.Info("Using per-CR Deployment endpoint", "deployment", instance.Spec.TargetDeployment, "namespace", namespace, "baseURL", baseURL)
			if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
				return err
			}
			r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
			return nil
		}
	}

	// Handle by-ordinal strategy
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		baseURL, err := r.getBaseURLByOrdinal(ctx, instance.Spec.TargetPodOrdinal)
		if err != nil {
			return fmt.Errorf("failed to get base URL by ordinal: %w", err)
		}
		if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
			return err
		}
		r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
		return nil
	}

	// Get base URLs (multiple for all-healthy strategy)
	baseURLs, err := r.getAllBaseURLs(ctx)
	if err != nil {
		return fmt.Errorf("failed to get base URLs: %w", err)
	}

	// Single endpoint case
	if len(baseURLs) == 1 {
		if err := r.syncToEndpoint(ctx, instance, baseURLs[0]); err != nil {
			return err
		}
		r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
		return nil
	}

	// Multiple endpoints (all-healthy strategy) - fan out to all
	var syncErrors []error
	successCount := 0

	for _, baseURL := range baseURLs {
		if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
			syncErrors = append(syncErrors, fmt.Errorf("%s: %w", baseURL, err))
		} else {
			successCount++
		}
	}

	// If all requests failed, return error
	if successCount == 0 {
		return fmt.Errorf("all sync requests failed: %v", syncErrors)
	}

	// Log partial failures
	if len(syncErrors) > 0 {
		logger.Info("Some sync requests failed", "successCount", successCount, "errors", syncErrors)
	}

	r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
	return nil
}

// deleteFromEndpoint deletes from a single endpoint URL
func (r *StoreReconciler) deleteFromEndpoint(ctx context.Context, instance *v1alpha1.Store, baseURL string) error {
	logger := log.FromContext(ctx)

	url := baseURL + "/store/" + instance.Status.ExternalID
	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return fmt.Errorf("failed to create delete request: %w", err)
	}

	logger.Info("Deleting external resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to delete resource: %w", err)
	}
	defer resp.Body.Close()

	// 404 is OK - resource already deleted
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusNotFound {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("failed to delete: %s - %s", resp.Status, string(body))
	}

	logger.Info("Successfully deleted external resource")
	return nil
}

func (r *StoreReconciler) finalizeResource(ctx context.Context, instance *v1alpha1.Store) error {
	logger := log.FromContext(ctx)

	if instance.Status.ExternalID == "" {
		logger.Info("No external ID, skipping delete")
		return nil
	}

	// Handle per-CR targeting (Helm release, StatefulSet, or Deployment)
	if r.EndpointResolver != nil {
		namespace := instance.Spec.TargetNamespace
		if namespace == "" {
			namespace = instance.Namespace
		}

		// Per-CR Helm release targeting
		if instance.Spec.TargetHelmRelease != "" {
			baseURL, err := r.EndpointResolver.GetEndpointForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace, instance.Spec.TargetPodOrdinal)
			if err != nil {
				return fmt.Errorf("failed to get endpoint for Helm release %s: %w", instance.Spec.TargetHelmRelease, err)
			}
			logger.Info("Using per-CR Helm release endpoint for delete", "helmRelease", instance.Spec.TargetHelmRelease, "namespace", namespace, "baseURL", baseURL)
			return r.deleteFromEndpoint(ctx, instance, baseURL)
		}

		// Per-CR StatefulSet targeting
		if instance.Spec.TargetStatefulSet != "" {
			baseURL, err := r.EndpointResolver.GetEndpointForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace, instance.Spec.TargetPodOrdinal)
			if err != nil {
				return fmt.Errorf("failed to get endpoint for StatefulSet %s: %w", instance.Spec.TargetStatefulSet, err)
			}
			logger.Info("Using per-CR StatefulSet endpoint for delete", "statefulset", instance.Spec.TargetStatefulSet, "namespace", namespace, "baseURL", baseURL)
			return r.deleteFromEndpoint(ctx, instance, baseURL)
		}

		// Per-CR Deployment targeting
		if instance.Spec.TargetDeployment != "" {
			baseURL, err := r.EndpointResolver.GetEndpointForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
			if err != nil {
				return fmt.Errorf("failed to get endpoint for Deployment %s: %w", instance.Spec.TargetDeployment, err)
			}
			logger.Info("Using per-CR Deployment endpoint for delete", "deployment", instance.Spec.TargetDeployment, "namespace", namespace, "baseURL", baseURL)
			return r.deleteFromEndpoint(ctx, instance, baseURL)
		}
	}

	// Handle by-ordinal strategy
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		baseURL, err := r.getBaseURLByOrdinal(ctx, instance.Spec.TargetPodOrdinal)
		if err != nil {
			return fmt.Errorf("failed to get base URL by ordinal: %w", err)
		}
		return r.deleteFromEndpoint(ctx, instance, baseURL)
	}

	// Get base URLs (multiple for all-healthy strategy)
	baseURLs, err := r.getAllBaseURLs(ctx)
	if err != nil {
		return fmt.Errorf("failed to get base URLs: %w", err)
	}

	// Single endpoint case
	if len(baseURLs) == 1 {
		return r.deleteFromEndpoint(ctx, instance, baseURLs[0])
	}

	// Multiple endpoints (all-healthy strategy) - fan out to all
	var deleteErrors []error
	successCount := 0

	for _, baseURL := range baseURLs {
		if err := r.deleteFromEndpoint(ctx, instance, baseURL); err != nil {
			deleteErrors = append(deleteErrors, fmt.Errorf("%s: %w", baseURL, err))
		} else {
			successCount++
		}
	}

	// If all requests failed, return error
	if successCount == 0 {
		return fmt.Errorf("all delete requests failed: %v", deleteErrors)
	}

	// Log partial failures but consider success if at least one succeeded
	if len(deleteErrors) > 0 {
		logger.Info("Some delete requests failed", "successCount", successCount, "errors", deleteErrors)
	}

	return nil
}

func (r *StoreReconciler) updateStatus(ctx context.Context, instance *v1alpha1.Store, state, message string) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	instance.Status.State = state
	instance.Status.Message = message
	instance.Status.LastSyncTime = &now
	instance.Status.ObservedGeneration = instance.Generation

	// Update condition
	condition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Synced" {
		condition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, condition)

	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *StoreReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.Store{}).
		Complete(r)
}
