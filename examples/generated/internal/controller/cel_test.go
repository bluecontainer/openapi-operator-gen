/*
Copyright 2026 Generated by openapi-operator-gen v0.0.9-23-g2e477da-dirty.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"encoding/json"
	"fmt"
	"reflect"
	"testing"

	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/common/types"
	"github.com/google/cel-go/common/types/ref"
	"github.com/google/cel-go/common/types/traits"
)

// TestCELEnvironment tests that CEL environment can be created with all required variables
func TestCELEnvironment(t *testing.T) {
	envOpts := []cel.EnvOption{
		cel.Variable("resources", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("summary", cel.MapType(cel.StringType, cel.IntType)),
		// Kind-specific variables
		cel.Variable("orders", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("pets", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("users", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("petfindbystatusqueries", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("petfindbytagsqueries", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("storeinventoryqueries", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("userloginqueries", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("userlogoutqueries", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("petuploadimageactions", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("usercreatewithlistactions", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		// Custom aggregate functions
		cel.Function("sum",
			cel.Overload("sum_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(testCelSumList),
			),
		),
		cel.Function("max",
			cel.Overload("max_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(testCelMaxList),
			),
		),
		cel.Function("min",
			cel.Overload("min_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(testCelMinList),
			),
		),
		cel.Function("avg",
			cel.Overload("avg_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(testCelAvgList),
			),
		),
	}

	env, err := cel.NewEnv(envOpts...)
	if err != nil {
		t.Fatalf("Failed to create CEL environment: %v", err)
	}
	if env == nil {
		t.Fatal("CEL environment is nil")
	}
}

// TestCELSummaryExpressions tests CEL expressions using the summary variable
func TestCELSummaryExpressions(t *testing.T) {
	tests := []struct {
		name       string
		expression string
		summary    map[string]int64
		want       interface{}
		wantErr    bool
	}{
		{
			name:       "simple total",
			expression: "summary.total",
			summary:    map[string]int64{"total": 10, "synced": 8, "failed": 2, "pending": 0},
			want:       int64(10),
		},
		{
			name:       "percentage calculation",
			expression: "summary.synced * 100 / summary.total",
			summary:    map[string]int64{"total": 10, "synced": 8, "failed": 2, "pending": 0},
			want:       int64(80),
		},
		{
			name:       "conditional with ternary",
			expression: "summary.total > 0 ? summary.synced * 100 / summary.total : 0",
			summary:    map[string]int64{"total": 10, "synced": 8, "failed": 2, "pending": 0},
			want:       int64(80),
		},
		{
			name:       "zero total with ternary guard",
			expression: "summary.total > 0 ? summary.synced * 100 / summary.total : 0",
			summary:    map[string]int64{"total": 0, "synced": 0, "failed": 0, "pending": 0},
			want:       int64(0),
		},
		{
			name:       "boolean all synced",
			expression: "summary.synced == summary.total",
			summary:    map[string]int64{"total": 10, "synced": 10, "failed": 0, "pending": 0},
			want:       true,
		},
		{
			name:       "boolean not all synced",
			expression: "summary.synced == summary.total",
			summary:    map[string]int64{"total": 10, "synced": 8, "failed": 2, "pending": 0},
			want:       false,
		},
		{
			name:       "failed count check",
			expression: "summary.failed > 0",
			summary:    map[string]int64{"total": 10, "synced": 8, "failed": 2, "pending": 0},
			want:       true,
		},
		{
			name:       "arithmetic with multiple fields",
			expression: "summary.synced + summary.pending",
			summary:    map[string]int64{"total": 10, "synced": 8, "failed": 0, "pending": 2},
			want:       int64(10),
		},
	}

	env := createTestCELEnv(t)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := evaluateTestCEL(env, tt.expression, map[string]interface{}{
				"resources": []map[string]interface{}{},
				"summary":   tt.summary,
			})

			if (err != nil) != tt.wantErr {
				t.Errorf("evaluateTestCEL() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr && !reflect.DeepEqual(result, tt.want) {
				t.Errorf("evaluateTestCEL() = %v (%T), want %v (%T)", result, result, tt.want, tt.want)
			}
		})
	}
}

// TestCELResourceExpressions tests CEL expressions using the resources variable
func TestCELResourceExpressions(t *testing.T) {
	resources := []map[string]interface{}{
		{
			"kind": "Pet",
			"metadata": map[string]interface{}{
				"name":      "fluffy",
				"namespace": "default",
			},
			"spec": map[string]interface{}{
				"name":   "Fluffy",
				"status": "available",
			},
			"status": map[string]interface{}{
				"state":      "Synced",
				"externalID": "123",
			},
		},
		{
			"kind": "Pet",
			"metadata": map[string]interface{}{
				"name":      "buddy",
				"namespace": "default",
			},
			"spec": map[string]interface{}{
				"name":   "Buddy",
				"status": "pending",
			},
			"status": map[string]interface{}{
				"state":      "Failed",
				"externalID": "",
				"message":    "API error",
			},
		},
		{
			"kind": "Order",
			"metadata": map[string]interface{}{
				"name":      "order-1",
				"namespace": "default",
			},
			"spec": map[string]interface{}{
				"quantity": 5,
				"petId":    "123",
			},
			"status": map[string]interface{}{
				"state":      "Synced",
				"externalID": "ord-1",
			},
		},
	}

	tests := []struct {
		name       string
		expression string
		want       interface{}
		wantErr    bool
	}{
		{
			name:       "resources size",
			expression: "resources.size()",
			want:       int64(3),
		},
		{
			name:       "filter by kind",
			expression: "resources.filter(r, r.kind == 'Pet').size()",
			want:       int64(2),
		},
		{
			name:       "filter by state",
			expression: "resources.filter(r, r.status.state == 'Synced').size()",
			want:       int64(2),
		},
		{
			name:       "filter by failed state",
			expression: "resources.filter(r, r.status.state == 'Failed').size()",
			want:       int64(1),
		},
		{
			name:       "exists check",
			expression: "resources.exists(r, r.kind == 'Order')",
			want:       true,
		},
		{
			name:       "all check false",
			expression: "resources.all(r, r.status.state == 'Synced')",
			want:       false,
		},
		{
			name:       "map and filter",
			expression: "resources.filter(r, r.kind == 'Pet').map(r, r.spec.name).size()",
			want:       int64(2),
		},
	}

	env := createTestCELEnv(t)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := evaluateTestCEL(env, tt.expression, map[string]interface{}{
				"resources": resources,
				"summary":   map[string]int64{"total": 3, "synced": 2, "failed": 1, "pending": 0},
			})

			if (err != nil) != tt.wantErr {
				t.Errorf("evaluateTestCEL() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr && !reflect.DeepEqual(result, tt.want) {
				t.Errorf("evaluateTestCEL() = %v (%T), want %v (%T)", result, result, tt.want, tt.want)
			}
		})
	}
}

// TestCELAggregateFunctions tests custom aggregate functions (sum, max, min, avg)
func TestCELAggregateFunctions(t *testing.T) {
	orders := []map[string]interface{}{
		{
			"kind": "Order",
			"spec": map[string]interface{}{
				"quantity": 5,
			},
			"status": map[string]interface{}{
				"state": "Synced",
			},
		},
		{
			"kind": "Order",
			"spec": map[string]interface{}{
				"quantity": 10,
			},
			"status": map[string]interface{}{
				"state": "Synced",
			},
		},
		{
			"kind": "Order",
			"spec": map[string]interface{}{
				"quantity": 15,
			},
			"status": map[string]interface{}{
				"state": "Failed",
			},
		},
	}

	tests := []struct {
		name       string
		expression string
		want       float64
		wantErr    bool
	}{
		{
			name:       "sum of quantities",
			expression: "sum(orders.map(r, r.spec.quantity))",
			want:       30.0,
		},
		{
			name:       "max quantity",
			expression: "max(orders.map(r, r.spec.quantity))",
			want:       15.0,
		},
		{
			name:       "min quantity",
			expression: "min(orders.map(r, r.spec.quantity))",
			want:       5.0,
		},
		{
			name:       "avg quantity",
			expression: "avg(orders.map(r, r.spec.quantity))",
			want:       10.0,
		},
		{
			name:       "sum with filter",
			expression: "sum(orders.filter(r, r.status.state == 'Synced').map(r, r.spec.quantity))",
			want:       15.0,
		},
		{
			name:       "sum of empty list",
			expression: "sum(orders.filter(r, r.status.state == 'Unknown').map(r, r.spec.quantity))",
			want:       0.0,
		},
	}

	env := createTestCELEnvWithKinds(t, []string{"orders"}, []string{})

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := evaluateTestCEL(env, tt.expression, map[string]interface{}{
				"resources": orders,
				"summary":   map[string]int64{"total": 3, "synced": 2, "failed": 1, "pending": 0},
				"orders":    orders,
			})

			if (err != nil) != tt.wantErr {
				t.Errorf("evaluateTestCEL() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr {
				// Convert to float64 for comparison
				got, ok := result.(float64)
				if !ok {
					t.Errorf("expected float64, got %T", result)
					return
				}
				if got != tt.want {
					t.Errorf("evaluateTestCEL() = %v, want %v", got, tt.want)
				}
			}
		})
	}
}

// TestCELKindSpecificVariables tests kind-specific list variables
func TestCELKindSpecificVariables(t *testing.T) {
	pets := []map[string]interface{}{
		{
			"kind":   "Pet",
			"spec":   map[string]interface{}{"name": "Fluffy"},
			"status": map[string]interface{}{"state": "Synced"},
		},
		{
			"kind":   "Pet",
			"spec":   map[string]interface{}{"name": "Buddy"},
			"status": map[string]interface{}{"state": "Synced"},
		},
	}

	orders := []map[string]interface{}{
		{
			"kind":   "Order",
			"spec":   map[string]interface{}{"quantity": 5},
			"status": map[string]interface{}{"state": "Synced"},
		},
	}

	tests := []struct {
		name       string
		expression string
		want       interface{}
	}{
		{
			name:       "pets size",
			expression: "pets.size()",
			want:       int64(2),
		},
		{
			name:       "orders size",
			expression: "orders.size()",
			want:       int64(1),
		},
		{
			name:       "combined size",
			expression: "pets.size() + orders.size()",
			want:       int64(3),
		},
	}

	env := createTestCELEnvWithKinds(t, []string{"pets", "orders"}, []string{})

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := evaluateTestCEL(env, tt.expression, map[string]interface{}{
				"resources": append(pets, orders...),
				"summary":   map[string]int64{"total": 3, "synced": 3, "failed": 0, "pending": 0},
				"pets":      pets,
				"orders":    orders,
			})

			if err != nil {
				t.Errorf("evaluateTestCEL() error = %v", err)
				return
			}

			if !reflect.DeepEqual(result, tt.want) {
				t.Errorf("evaluateTestCEL() = %v (%T), want %v (%T)", result, result, tt.want, tt.want)
			}
		})
	}
}

// TestCELCompileErrors tests that invalid expressions produce compile errors
func TestCELCompileErrors(t *testing.T) {
	tests := []struct {
		name       string
		expression string
	}{
		{
			name:       "undefined variable",
			expression: "undefined_var.size()",
		},
		{
			name:       "syntax error",
			expression: "summary.total +",
		},
		{
			name:       "type mismatch",
			expression: "summary.total + 'string'",
		},
	}

	env := createTestCELEnv(t)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ast, issues := env.Compile(tt.expression)
			if issues == nil || issues.Err() == nil {
				// If compile succeeded, try to evaluate - should fail
				if ast != nil {
					prg, err := env.Program(ast)
					if err == nil && prg != nil {
						_, _, err = prg.Eval(map[string]interface{}{
							"resources": []map[string]interface{}{},
							"summary":   map[string]int64{"total": 0},
						})
						if err == nil {
							t.Errorf("expected error for expression %q, but got none", tt.expression)
						}
					}
				}
			}
			// Expected: either compile error or eval error
		})
	}
}

// TestCELHasFunction tests the CEL has() function for optional field access
func TestCELHasFunction(t *testing.T) {
	resources := []map[string]interface{}{
		{
			"kind": "Order",
			"spec": map[string]interface{}{
				"quantity": 5,
			},
		},
		{
			"kind": "Order",
			"spec": map[string]interface{}{
				// No quantity field
			},
		},
	}

	tests := []struct {
		name       string
		expression string
		want       interface{}
	}{
		{
			name:       "has check true",
			expression: "resources.filter(r, has(r.spec.quantity)).size()",
			want:       int64(1),
		},
		{
			name:       "conditional with has",
			expression: "sum(resources.map(r, has(r.spec.quantity) ? r.spec.quantity : 0))",
			want:       5.0,
		},
	}

	env := createTestCELEnvWithKinds(t, []string{"orders"}, []string{})

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := evaluateTestCEL(env, tt.expression, map[string]interface{}{
				"resources": resources,
				"summary":   map[string]int64{"total": 2},
				"orders":    resources,
			})

			if err != nil {
				t.Errorf("evaluateTestCEL() error = %v", err)
				return
			}

			if !reflect.DeepEqual(result, tt.want) {
				t.Errorf("evaluateTestCEL() = %v (%T), want %v (%T)", result, result, tt.want, tt.want)
			}
		})
	}
}

// TestCELResourceSpecificVariables tests the {kind}-{name} variable naming convention
// for direct access to individual resources
func TestCELResourceSpecificVariables(t *testing.T) {
	// Create resources with different kinds and names
	petFluffy := map[string]interface{}{
		"kind": "Pet",
		"metadata": map[string]interface{}{
			"name":      "fluffy",
			"namespace": "default",
		},
		"spec": map[string]interface{}{
			"name":   "Fluffy",
			"status": "available",
		},
		"status": map[string]interface{}{
			"state":      "Synced",
			"externalID": "123",
		},
	}

	petBuddy := map[string]interface{}{
		"kind": "Pet",
		"metadata": map[string]interface{}{
			"name":      "buddy",
			"namespace": "default",
		},
		"spec": map[string]interface{}{
			"name":   "Buddy",
			"status": "pending",
		},
		"status": map[string]interface{}{
			"state":      "Synced",
			"externalID": "456",
		},
	}

	orderSample := map[string]interface{}{
		"kind": "Order",
		"metadata": map[string]interface{}{
			"name":      "sample",
			"namespace": "default",
		},
		"spec": map[string]interface{}{
			"quantity": 10,
			"petId":    "123",
		},
		"status": map[string]interface{}{
			"state":      "Synced",
			"externalID": "ord-1",
		},
	}

	allResources := []map[string]interface{}{petFluffy, petBuddy, orderSample}

	tests := []struct {
		name       string
		expression string
		want       interface{}
	}{
		{
			name:       "direct access to pet_fluffy status",
			expression: `pet_fluffy.status.state`,
			want:       "Synced",
		},
		{
			name:       "direct access to pet_fluffy externalID",
			expression: `pet_fluffy.status.externalID`,
			want:       "123",
		},
		{
			name:       "direct access to pet_buddy spec name",
			expression: `pet_buddy.spec.name`,
			want:       "Buddy",
		},
		{
			name:       "direct access to order_sample quantity",
			expression: `order_sample.spec.quantity`,
			want:       int64(10),
		},
		{
			name:       "compare two resource values",
			expression: `pet_fluffy.status.externalID == order_sample.spec.petId`,
			want:       true,
		},
		{
			name:       "use resource-specific var in condition",
			expression: `pet_fluffy.status.state == "Synced" && pet_buddy.status.state == "Synced"`,
			want:       true,
		},
		{
			name:       "access metadata name",
			expression: `pet_fluffy.metadata.name`,
			want:       "fluffy",
		},
	}

	// Resource keys use {kind}-{name} convention with lowercase kind
	resourceKeys := []string{"pet_fluffy", "pet_buddy", "order_sample"}
	env := createTestCELEnvWithKinds(t, []string{"pets", "orders"}, resourceKeys)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := evaluateTestCEL(env, tt.expression, map[string]interface{}{
				"resources":    allResources,
				"summary":      map[string]int64{"total": 3, "synced": 3, "failed": 0, "pending": 0},
				"pets":         []map[string]interface{}{petFluffy, petBuddy},
				"orders":       []map[string]interface{}{orderSample},
				"pet_fluffy":   petFluffy,
				"pet_buddy":    petBuddy,
				"order_sample": orderSample,
			})

			if err != nil {
				t.Errorf("evaluateTestCEL() error = %v", err)
				return
			}

			if !reflect.DeepEqual(result, tt.want) {
				t.Errorf("evaluateTestCEL() = %v (%T), want %v (%T)", result, result, tt.want, tt.want)
			}
		})
	}
}

// Helper functions

func createTestCELEnv(t *testing.T) *cel.Env {
	return createTestCELEnvWithKinds(t, []string{}, []string{})
}

func createTestCELEnvWithKinds(t *testing.T, kinds []string, resourceKeys []string) *cel.Env {
	envOpts := []cel.EnvOption{
		cel.Variable("resources", cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		cel.Variable("summary", cel.MapType(cel.StringType, cel.IntType)),
	}

	// Add kind-specific variables (lists)
	for _, kind := range kinds {
		envOpts = append(envOpts,
			cel.Variable(kind, cel.ListType(cel.MapType(cel.StringType, cel.DynType))),
		)
	}

	// Add resource-specific variables using {kind}-{name} convention (individual maps)
	for _, resourceKey := range resourceKeys {
		envOpts = append(envOpts,
			cel.Variable(resourceKey, cel.MapType(cel.StringType, cel.DynType)),
		)
	}

	// Add custom aggregate functions
	envOpts = append(envOpts,
		cel.Function("sum",
			cel.Overload("sum_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(testCelSumList),
			),
		),
		cel.Function("max",
			cel.Overload("max_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(testCelMaxList),
			),
		),
		cel.Function("min",
			cel.Overload("min_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(testCelMinList),
			),
		),
		cel.Function("avg",
			cel.Overload("avg_list",
				[]*cel.Type{cel.ListType(cel.DynType)},
				cel.DoubleType,
				cel.UnaryBinding(testCelAvgList),
			),
		),
	)

	env, err := cel.NewEnv(envOpts...)
	if err != nil {
		t.Fatalf("Failed to create CEL environment: %v", err)
	}
	return env
}

func evaluateTestCEL(env *cel.Env, expression string, vars map[string]interface{}) (interface{}, error) {
	ast, issues := env.Compile(expression)
	if issues != nil && issues.Err() != nil {
		return nil, fmt.Errorf("compile error: %w", issues.Err())
	}

	prg, err := env.Program(ast)
	if err != nil {
		return nil, fmt.Errorf("program error: %w", err)
	}

	out, _, err := prg.Eval(vars)
	if err != nil {
		return nil, fmt.Errorf("eval error: %w", err)
	}

	return out.Value(), nil
}

// CEL helper functions for testing (same as in controllers)

func testCelToFloat64(val interface{}) (float64, bool) {
	switch v := val.(type) {
	case float64:
		return v, true
	case float32:
		return float64(v), true
	case int:
		return float64(v), true
	case int32:
		return float64(v), true
	case int64:
		return float64(v), true
	case uint:
		return float64(v), true
	case uint32:
		return float64(v), true
	case uint64:
		return float64(v), true
	case json.Number:
		if f, err := v.Float64(); err == nil {
			return f, true
		}
	}
	return 0, false
}

func testCelSumList(val ref.Val) ref.Val {
	iter, ok := val.(traits.Lister)
	if !ok {
		return types.NewErr("sum() requires a list argument")
	}

	var sum float64
	it := iter.Iterator()
	for it.HasNext() == types.True {
		elem := it.Next()
		if num, ok := testCelToFloat64(elem.Value()); ok {
			sum += num
		}
	}
	return types.Double(sum)
}

func testCelMaxList(val ref.Val) ref.Val {
	iter, ok := val.(traits.Lister)
	if !ok {
		return types.NewErr("max() requires a list argument")
	}

	var max float64
	first := true
	it := iter.Iterator()
	for it.HasNext() == types.True {
		elem := it.Next()
		if num, ok := testCelToFloat64(elem.Value()); ok {
			if first || num > max {
				max = num
				first = false
			}
		}
	}
	if first {
		return types.Double(0)
	}
	return types.Double(max)
}

func testCelMinList(val ref.Val) ref.Val {
	iter, ok := val.(traits.Lister)
	if !ok {
		return types.NewErr("min() requires a list argument")
	}

	var min float64
	first := true
	it := iter.Iterator()
	for it.HasNext() == types.True {
		elem := it.Next()
		if num, ok := testCelToFloat64(elem.Value()); ok {
			if first || num < min {
				min = num
				first = false
			}
		}
	}
	if first {
		return types.Double(0)
	}
	return types.Double(min)
}

func testCelAvgList(val ref.Val) ref.Val {
	iter, ok := val.(traits.Lister)
	if !ok {
		return types.NewErr("avg() requires a list argument")
	}

	var sum float64
	var count int
	it := iter.Iterator()
	for it.HasNext() == types.True {
		elem := it.Next()
		if num, ok := testCelToFloat64(elem.Value()); ok {
			sum += num
			count++
		}
	}
	if count == 0 {
		return types.Double(0)
	}
	return types.Double(sum / float64(count))
}
