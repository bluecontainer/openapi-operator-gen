/*
Copyright 2026 Generated by openapi-operator-gen v0.0.7-5-g00a112e-dirty.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	"github.com/bluecontainer/openapi-operator-gen/pkg/runtime"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

var (
	petTracer = otel.Tracer("github.com/bluecontainer/petstore-operator/controller/pet")
	petMeter  = otel.Meter("github.com/bluecontainer/petstore-operator/controller/pet")

	// Metrics
	petReconcileTotal    metric.Int64Counter
	petReconcileDuration metric.Float64Histogram
	petAPICallTotal      metric.Int64Counter
	petAPICallDuration   metric.Float64Histogram
	petDriftDetected     metric.Int64Counter
)

func init() {
	var err error

	petReconcileTotal, err = petMeter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	petReconcileDuration, err = petMeter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	petAPICallTotal, err = petMeter.Int64Counter(
		"api_call_total",
		metric.WithDescription("Total number of REST API calls"),
		metric.WithUnit("{call}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	petAPICallDuration, err = petMeter.Float64Histogram(
		"api_call_duration_seconds",
		metric.WithDescription("Duration of REST API calls in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	petDriftDetected, err = petMeter.Int64Counter(
		"drift_detected_total",
		metric.WithDescription("Total number of drift detections"),
		metric.WithUnit("{drift}"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
	petFinalizer    = "petstore.example.com/finalizer"
	petRequeueAfter = time.Second * 30
)

// PetReconciler reconciles a Pet object
type PetReconciler struct {
	client.Client
	Scheme           *k8sruntime.Scheme
	HTTPClient       *http.Client
	EndpointResolver *endpoint.Resolver
	// BaseURL is used when EndpointResolver is nil (static URL mode)
	BaseURL string
}

// +kubebuilder:rbac:groups=petstore.example.com,resources=pets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=pets/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=petstore.example.com,resources=pets/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop
func (r *PetReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// Start tracing span
	ctx, span := petTracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "Pet"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	// Record metrics
	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	petReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	petReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

// reconcileInternal contains the actual reconciliation logic
func (r *PetReconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the Pet instance
	instance := &v1alpha1.Pet{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("Pet resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get Pet")
		return ctrl.Result{}, err
	}

	// Add resource attributes to current span
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("resource.externalID", r.getExternalID(instance)),
		attribute.Bool("resource.readOnly", instance.Spec.ReadOnly),
	)

	// Check if this is a read-only resource
	isReadOnly := instance.Spec.ReadOnly

	// Check if the resource is being deleted
	if instance.GetDeletionTimestamp() != nil {
		if controllerutil.ContainsFinalizer(instance, petFinalizer) {
			// Run finalization logic (skip for read-only resources)
			if !isReadOnly {
				if err := r.finalizeResource(ctx, instance); err != nil {
					return ctrl.Result{}, err
				}
			}

			// Remove finalizer
			controllerutil.RemoveFinalizer(instance, petFinalizer)
			if err := r.Update(ctx, instance); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{}, nil
	}

	// Add finalizer if not present (skip for read-only resources)
	if !isReadOnly && !controllerutil.ContainsFinalizer(instance, petFinalizer) {
		controllerutil.AddFinalizer(instance, petFinalizer)
		if err := r.Update(ctx, instance); err != nil {
			return ctrl.Result{}, err
		}
	}

	// Handle read-only mode: only GET and update status
	if isReadOnly {
		if instance.Spec.ExternalIDRef == "" {
			r.updateStatus(ctx, instance, "Failed", "ReadOnly mode requires ExternalIDRef to be set")
			return ctrl.Result{RequeueAfter: petRequeueAfter}, fmt.Errorf("readOnly mode requires externalIDRef")
		}
		if err := r.observeResource(ctx, instance); err != nil {
			r.updateStatus(ctx, instance, "Failed", err.Error())
			return ctrl.Result{RequeueAfter: petRequeueAfter}, err
		}
		return ctrl.Result{RequeueAfter: petRequeueAfter}, nil
	}

	// Sync with REST API (with drift detection)
	if err := r.syncResource(ctx, instance); err != nil {
		// Update status to failed
		r.updateStatus(ctx, instance, "Failed", err.Error())
		return ctrl.Result{RequeueAfter: petRequeueAfter}, err
	}

	return ctrl.Result{RequeueAfter: petRequeueAfter}, nil
}

func (r *PetReconciler) getBaseURL(ctx context.Context) (string, error) {
	// Try static BaseURL first
	if r.BaseURL != "" {
		return r.BaseURL, nil
	}
	// Try global endpoint resolver
	if r.EndpointResolver != nil {
		url, err := r.EndpointResolver.GetEndpoint()
		if err == nil {
			return url, nil
		}
	}
	return "", fmt.Errorf("no endpoint configured: set global endpoint (--base-url, --statefulset-name, --deployment-name, or --helm-release) or specify per-CR targeting (targetHelmRelease, targetStatefulSet, or targetDeployment)")
}

func (r *PetReconciler) getBaseURLByOrdinal(ctx context.Context, ordinal *int32) (string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		if ordinal == nil {
			return "", fmt.Errorf("targetPodOrdinal is required when using by-ordinal strategy")
		}
		return r.EndpointResolver.GetEndpointByOrdinal(int(*ordinal))
	}
	// Fall back to regular endpoint selection if not using by-ordinal strategy
	return r.getBaseURL(ctx)
}

// buildResourceURL builds the URL for resource operations with path and query parameters
// BasePath is the base path without path parameter placeholders (e.g., /pet, not /pet/{petId})
// The resourceID is appended to the path for GET/PUT/DELETE operations
func (r *PetReconciler) buildResourceURL(baseURL string, instance *v1alpha1.Pet, resourceID string) string {
	builder := runtime.NewURLBuilder("/pet")

	// Add resource ID for operations that need it (appended to path)
	builder.WithResourceID(resourceID)
	// Add query parameters from spec
	builder.WithQueryParam("name", instance.Spec.Name)
	builder.WithQueryParam("status", instance.Spec.Status)

	return builder.Build(baseURL)
}

// buildResourceURLForCreate builds the URL for resource creation (POST) with query parameters only
func (r *PetReconciler) buildResourceURLForCreate(baseURL string, instance *v1alpha1.Pet) string {
	builder := runtime.NewURLBuilder("/pet")
	// Add query parameters from spec
	builder.WithQueryParam("name", instance.Spec.Name)
	builder.WithQueryParam("status", instance.Spec.Status)

	return builder.BuildForCreate(baseURL)
}

// getExternalID returns the external ID to use for GET/PUT/DELETE operations.
// It prefers ExternalIDRef from spec (for importing existing resources),
// then falls back to ExternalID from status (for resources created by the controller).
func (r *PetReconciler) getExternalID(instance *v1alpha1.Pet) string {
	if instance.Spec.ExternalIDRef != "" {
		return instance.Spec.ExternalIDRef
	}
	return instance.Status.ExternalID
}

// getResource performs a GET request to fetch the current state of the resource from the REST API.
// Returns the response body as a map, or nil if the resource doesn't exist (404).
func (r *PetReconciler) getResource(ctx context.Context, baseURL string, externalID string, instance *v1alpha1.Pet) (map[string]interface{}, []byte, error) {
	ctx, span := petTracer.Start(ctx, "GET",
		trace.WithAttributes(
			attribute.String("http.method", "GET"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", externalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURL(baseURL, instance, externalID)
	span.SetAttributes(attribute.String("http.url", url))

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to create GET request: %w", err)
	}
	req.Header.Set("Accept", "application/json")

	logger.Info("Getting resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "GET", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to execute GET request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "GET", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, fmt.Errorf("failed to read GET response: %w", err)
	}

	// 404 means resource doesn't exist
	if resp.StatusCode == http.StatusNotFound {
		r.recordAPICallMetrics(ctx, "GET", "not_found", resp.StatusCode, duration)
		logger.Info("Resource not found in external API", "externalID", externalID)
		return nil, nil, nil
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "GET", "error", resp.StatusCode, duration)
		err := fmt.Errorf("GET failed: %s - %s", resp.Status, string(body))
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, err
	}

	r.recordAPICallMetrics(ctx, "GET", "success", resp.StatusCode, duration)

	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err != nil {
		return nil, body, fmt.Errorf("failed to parse GET response: %w", err)
	}

	return respData, body, nil
}

// recordAPICallMetrics records metrics for API calls
func (r *PetReconciler) recordAPICallMetrics(ctx context.Context, method, status string, statusCode int, duration float64) {
	petAPICallTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("method", method),
			attribute.String("status", status),
			attribute.Int("status_code", statusCode),
		))
	petAPICallDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("method", method),
			attribute.String("status", status),
		))
}

// compareSpecWithResponse compares the CR spec with the API response to detect drift.
// Returns true if there is drift (spec differs from current state).
func (r *PetReconciler) compareSpecWithResponse(instance *v1alpha1.Pet, apiResponse map[string]interface{}) bool {
	// Marshal spec to JSON for comparison
	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return true // Assume drift on error
	}

	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return true // Assume drift on error
	}

	// Remove controller-specific fields from spec that aren't part of the API resource
	delete(specMap, "targetPodOrdinal")
	delete(specMap, "targetHelmRelease")
	delete(specMap, "targetStatefulSet")
	delete(specMap, "targetDeployment")
	delete(specMap, "targetNamespace")
	delete(specMap, "externalIDRef")
	delete(specMap, "readOnly")

	// Compare each field in spec with API response
	for key, specValue := range specMap {
		apiValue, exists := apiResponse[key]
		if !exists {
			// Field exists in spec but not in API response - could be drift or API doesn't return this field
			continue
		}
		if !reflect.DeepEqual(specValue, apiValue) {
			return true // Drift detected
		}
	}

	return false // No drift
}

// observeResource performs a GET-only observation for read-only CRs.
func (r *PetReconciler) observeResource(ctx context.Context, instance *v1alpha1.Pet) error {
	logger := log.FromContext(ctx)

	externalID := r.getExternalID(instance)
	if externalID == "" {
		return fmt.Errorf("no external ID available for observation")
	}

	now := metav1.Now()

	// Check if using all-healthy strategy (fan out GET to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - collect responses from all
			responses := make(map[string]v1alpha1.PetEndpointResponse)
			successCount := 0
			var firstSuccessBody []byte

			for _, baseURL := range baseURLs {
				endpointResp := v1alpha1.PetEndpointResponse{
					LastUpdated: &now,
				}

				respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
				if err != nil {
					endpointResp.Success = false
					endpointResp.Error = err.Error()
					logger.Info("Failed to observe from endpoint", "endpoint", baseURL, "error", err)
				} else if respData == nil {
					endpointResp.Success = false
					endpointResp.StatusCode = 404
					endpointResp.Error = fmt.Sprintf("resource %s not found", externalID)
					logger.Info("Resource not found at endpoint", "endpoint", baseURL, "externalID", externalID)
				} else {
					endpointResp.Success = true
					endpointResp.StatusCode = 200
					endpointResp.Data = &k8sruntime.RawExtension{Raw: body}
					successCount++
					if firstSuccessBody == nil {
						firstSuccessBody = body
					}
					logger.Info("Successfully observed from endpoint", "endpoint", baseURL, "externalID", externalID)
				}

				responses[baseURL] = endpointResp
			}

			// Update status with all responses
			instance.Status.ExternalID = externalID
			instance.Status.Responses = responses
			instance.Status.LastGetTime = &now
			instance.Status.DriftDetected = false

			// Also set the single Response field with first success for backwards compatibility
			if firstSuccessBody != nil {
				instance.Status.Response = &v1alpha1.PetEndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: firstSuccessBody},
					LastUpdated: &now,
				}
			}

			if successCount == 0 {
				r.updateStatus(ctx, instance, "NotFound", fmt.Sprintf("Resource %s not found in any endpoint (%d endpoints queried)", externalID, len(baseURLs)))
				return nil
			}

			message := fmt.Sprintf("Successfully observed from %d/%d endpoints", successCount, len(baseURLs))
			logger.Info(message, "externalID", externalID)
			r.updateStatus(ctx, instance, "Observed", message)
			return nil
		}
	}

	// Single endpoint case - resolve URL and observe
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return err
	}

	respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
	if err != nil {
		return err
	}

	if respData == nil {
		r.updateStatus(ctx, instance, "NotFound", fmt.Sprintf("Resource %s not found in external API", externalID))
		return nil
	}

	// Update status with fetched data
	instance.Status.ExternalID = externalID
	instance.Status.Response = &v1alpha1.PetEndpointResponse{
		Success:     true,
		StatusCode:  200,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.LastGetTime = &now
	instance.Status.DriftDetected = false // No drift concept for read-only
	instance.Status.Responses = nil       // Clear multi-endpoint responses for single endpoint

	logger.Info("Successfully observed resource", "externalID", externalID)
	r.updateStatus(ctx, instance, "Observed", "Successfully fetched resource from REST API")
	return nil
}

// resolveBaseURL determines the base URL to use for API requests based on CR targeting fields.
func (r *PetReconciler) resolveBaseURL(ctx context.Context, instance *v1alpha1.Pet) (string, error) {
	if r.EndpointResolver != nil {
		namespace := instance.Spec.TargetNamespace
		if namespace == "" {
			namespace = instance.Namespace
		}

		// Per-CR Helm release targeting
		if instance.Spec.TargetHelmRelease != "" {
			return r.EndpointResolver.GetEndpointForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace, instance.Spec.TargetPodOrdinal)
		}

		// Per-CR StatefulSet targeting
		if instance.Spec.TargetStatefulSet != "" {
			return r.EndpointResolver.GetEndpointForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace, instance.Spec.TargetPodOrdinal)
		}

		// Per-CR Deployment targeting
		if instance.Spec.TargetDeployment != "" {
			return r.EndpointResolver.GetEndpointForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
		}

		// By-ordinal strategy
		if r.EndpointResolver.IsByOrdinalStrategy() {
			return r.getBaseURLByOrdinal(ctx, instance.Spec.TargetPodOrdinal)
		}
	}

	return r.getBaseURL(ctx)
}

// resolveAllHealthyEndpoints returns all healthy endpoint URLs based on CR targeting fields.
// This is used for all-healthy strategy fan-out operations.
func (r *PetReconciler) resolveAllHealthyEndpoints(ctx context.Context, instance *v1alpha1.Pet) ([]string, error) {
	if r.EndpointResolver == nil {
		// No resolver - return single static URL
		url, err := r.getBaseURL(ctx)
		if err != nil {
			return nil, err
		}
		return []string{url}, nil
	}

	namespace := instance.Spec.TargetNamespace
	if namespace == "" {
		namespace = instance.Namespace
	}

	// Per-CR Helm release targeting
	if instance.Spec.TargetHelmRelease != "" {
		return r.EndpointResolver.GetAllEndpointsForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace)
	}

	// Per-CR StatefulSet targeting
	if instance.Spec.TargetStatefulSet != "" {
		return r.EndpointResolver.GetAllEndpointsForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace)
	}

	// Per-CR Deployment targeting
	if instance.Spec.TargetDeployment != "" {
		return r.EndpointResolver.GetAllEndpointsForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
	}

	// Fall back to global all-healthy endpoints
	return r.EndpointResolver.GetAllHealthyEndpoints()
}

// syncToEndpoint syncs to a single endpoint URL with GET-first drift detection.
// On success, it updates instance.Status.ExternalID, instance.Status.Response, and instance.Status.DriftDetected.
// The caller is responsible for calling updateStatus after this returns.
func (r *PetReconciler) syncToEndpoint(ctx context.Context, instance *v1alpha1.Pet, baseURL string) error {
	ctx, span := petTracer.Start(ctx, "SyncToEndpoint",
		trace.WithAttributes(
			attribute.String("endpoint.url", baseURL),
		))
	defer span.End()

	logger := log.FromContext(ctx)

	now := metav1.Now()
	externalID := r.getExternalID(instance)
	span.SetAttributes(attribute.String("resource.externalID", externalID))

	// If we have an external ID (from spec.externalIDRef or status.externalID), try GET first
	if externalID != "" {
		respData, body, err := r.getResource(ctx, baseURL, externalID, instance)
		if err != nil {
			return fmt.Errorf("failed to get resource: %w", err)
		}

		instance.Status.LastGetTime = &now

		if respData != nil {
			// Resource exists - check for drift
			hasDrift := r.compareSpecWithResponse(instance, respData)
			instance.Status.DriftDetected = hasDrift
			span.SetAttributes(attribute.Bool("drift.detected", hasDrift))

			if hasDrift {
				// Record drift detection metric
				petDriftDetected.Add(ctx, 1,
					metric.WithAttributes(
						attribute.String("resource.name", instance.Name),
						attribute.String("resource.namespace", instance.Namespace),
					))
			}

			if !hasDrift {
				// No drift - skip update
				logger.Info("No drift detected, skipping update", "externalID", externalID)
				instance.Status.ExternalID = externalID
				instance.Status.Response = &v1alpha1.PetEndpointResponse{
					Success:     true,
					StatusCode:  200,
					Data:        &k8sruntime.RawExtension{Raw: body},
					LastUpdated: &now,
				}
				return nil
			}

			// Drift detected - proceed with PUT
			logger.Info("Drift detected, updating resource", "externalID", externalID)
			return r.updateResource(ctx, instance, baseURL, externalID)
		}

		// Resource doesn't exist (404) - if we're using externalIDRef, this is an error
		if instance.Spec.ExternalIDRef != "" {
			return fmt.Errorf("resource with externalIDRef %s not found", instance.Spec.ExternalIDRef)
		}

		// Resource was created by us but no longer exists - recreate it
		logger.Info("Resource no longer exists, recreating", "externalID", externalID)
		instance.Status.ExternalID = "" // Clear so we do a POST
	}

	// No external ID or resource doesn't exist - create new resource
	return r.createResource(ctx, instance, baseURL)
}

// createResource performs a POST to create a new resource.
func (r *PetReconciler) createResource(ctx context.Context, instance *v1alpha1.Pet, baseURL string) error {
	ctx, span := petTracer.Start(ctx, "POST",
		trace.WithAttributes(
			attribute.String("http.method", "POST"),
			attribute.String("http.url", baseURL),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURLForCreate(baseURL, instance)
	span.SetAttributes(attribute.String("http.url", url))

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(specData))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create POST request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Creating resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "POST", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to execute POST request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "POST", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to read POST response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "POST", "error", resp.StatusCode, duration)
		err := fmt.Errorf("POST failed: %s - %s", resp.Status, string(body))
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return err
	}

	r.recordAPICallMetrics(ctx, "POST", "success", resp.StatusCode, duration)

	// Parse response to extract ID
	var respData map[string]interface{}
	if err := json.Unmarshal(body, &respData); err == nil {
		if id, ok := respData["id"]; ok {
			switch v := id.(type) {
			case string:
				instance.Status.ExternalID = v
			case float64:
				instance.Status.ExternalID = fmt.Sprintf("%.0f", v)
			}
		}
	}

	span.SetAttributes(attribute.String("resource.externalID", instance.Status.ExternalID))

	now := metav1.Now()
	instance.Status.Response = &v1alpha1.PetEndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now

	logger.Info("Successfully created resource", "externalID", instance.Status.ExternalID)
	return nil
}

// updateResource performs a PUT to update an existing resource.
func (r *PetReconciler) updateResource(ctx context.Context, instance *v1alpha1.Pet, baseURL string, externalID string) error {
	ctx, span := petTracer.Start(ctx, "PUT",
		trace.WithAttributes(
			attribute.String("http.method", "PUT"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", externalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURL(baseURL, instance, externalID)
	span.SetAttributes(attribute.String("http.url", url))

	// Marshal spec, excluding controller-specific fields
	specData, err := r.marshalSpecForAPI(instance)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to marshal spec: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bytes.NewReader(specData))
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create PUT request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	logger.Info("Updating resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "PUT", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to execute PUT request: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		r.recordAPICallMetrics(ctx, "PUT", "error", resp.StatusCode, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to read PUT response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		r.recordAPICallMetrics(ctx, "PUT", "error", resp.StatusCode, duration)
		err := fmt.Errorf("PUT failed: %s - %s", resp.Status, string(body))
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return err
	}

	r.recordAPICallMetrics(ctx, "PUT", "success", resp.StatusCode, duration)

	now := metav1.Now()
	instance.Status.ExternalID = externalID
	instance.Status.Response = &v1alpha1.PetEndpointResponse{
		Success:     true,
		StatusCode:  resp.StatusCode,
		Data:        &k8sruntime.RawExtension{Raw: body},
		LastUpdated: &now,
	}
	instance.Status.DriftDetected = false
	instance.Status.LastGetTime = &now

	logger.Info("Successfully updated resource", "externalID", externalID)
	return nil
}

// marshalSpecForAPI marshals the spec for sending to the API, excluding controller-specific fields.
func (r *PetReconciler) marshalSpecForAPI(instance *v1alpha1.Pet) ([]byte, error) {
	specData, err := json.Marshal(instance.Spec)
	if err != nil {
		return nil, err
	}

	var specMap map[string]interface{}
	if err := json.Unmarshal(specData, &specMap); err != nil {
		return nil, err
	}

	// Remove controller-specific fields
	delete(specMap, "targetPodOrdinal")
	delete(specMap, "targetHelmRelease")
	delete(specMap, "targetStatefulSet")
	delete(specMap, "targetDeployment")
	delete(specMap, "targetNamespace")
	delete(specMap, "externalIDRef")
	delete(specMap, "readOnly")
	// Remove path parameter fields (they're used in URL, not body)
	delete(specMap, "petId")
	// Remove query parameter fields (they're used in URL, not body)
	delete(specMap, "name")
	delete(specMap, "status")

	return json.Marshal(specMap)
}

func (r *PetReconciler) syncResource(ctx context.Context, instance *v1alpha1.Pet) error {
	logger := log.FromContext(ctx)

	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - fan out to all
			var syncErrors []error
			successCount := 0

			for _, baseURL := range baseURLs {
				if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
					syncErrors = append(syncErrors, fmt.Errorf("%s: %w", baseURL, err))
				} else {
					successCount++
				}
			}

			// If all requests failed, return error
			if successCount == 0 {
				return fmt.Errorf("all sync requests failed: %v", syncErrors)
			}

			// Log partial failures
			if len(syncErrors) > 0 {
				logger.Info("Some sync requests failed", "successCount", successCount, "errors", syncErrors)
			}

			r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
			return nil
		}
	}

	// Single endpoint case - resolve URL and sync
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	logger.Info("Syncing to endpoint", "baseURL", baseURL)
	if err := r.syncToEndpoint(ctx, instance, baseURL); err != nil {
		return err
	}

	r.updateStatus(ctx, instance, "Synced", "Successfully synced with REST API")
	return nil
}

// deleteFromEndpoint deletes from a single endpoint URL
func (r *PetReconciler) deleteFromEndpoint(ctx context.Context, instance *v1alpha1.Pet, baseURL string) error {
	ctx, span := petTracer.Start(ctx, "DELETE",
		trace.WithAttributes(
			attribute.String("http.method", "DELETE"),
			attribute.String("http.url", baseURL),
			attribute.String("resource.externalID", instance.Status.ExternalID),
		))
	defer span.End()

	logger := log.FromContext(ctx)
	start := time.Now()

	url := r.buildResourceURL(baseURL, instance, instance.Status.ExternalID)
	span.SetAttributes(attribute.String("http.url", url))

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to create delete request: %w", err)
	}

	logger.Info("Deleting external resource", "url", url)
	resp, err := r.HTTPClient.Do(req)
	duration := time.Since(start).Seconds()

	if err != nil {
		r.recordAPICallMetrics(ctx, "DELETE", "error", 0, duration)
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return fmt.Errorf("failed to delete resource: %w", err)
	}
	defer resp.Body.Close()

	span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

	// 404 is OK - resource already deleted
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusNotFound {
		body, _ := io.ReadAll(resp.Body)
		r.recordAPICallMetrics(ctx, "DELETE", "error", resp.StatusCode, duration)
		err := fmt.Errorf("failed to delete: %s - %s", resp.Status, string(body))
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		return err
	}

	r.recordAPICallMetrics(ctx, "DELETE", "success", resp.StatusCode, duration)
	logger.Info("Successfully deleted external resource")
	return nil
}

func (r *PetReconciler) finalizeResource(ctx context.Context, instance *v1alpha1.Pet) error {
	logger := log.FromContext(ctx)

	if instance.Status.ExternalID == "" {
		logger.Info("No external ID, skipping delete")
		return nil
	}

	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.resolveAllHealthyEndpoints(ctx, instance)
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - fan out delete to all
			var deleteErrors []error
			successCount := 0

			for _, baseURL := range baseURLs {
				if err := r.deleteFromEndpoint(ctx, instance, baseURL); err != nil {
					deleteErrors = append(deleteErrors, fmt.Errorf("%s: %w", baseURL, err))
				} else {
					successCount++
				}
			}

			// If all requests failed, return error
			if successCount == 0 {
				return fmt.Errorf("all delete requests failed: %v", deleteErrors)
			}

			// Log partial failures but consider success if at least one succeeded
			if len(deleteErrors) > 0 {
				logger.Info("Some delete requests failed", "successCount", successCount, "errors", deleteErrors)
			}

			return nil
		}
	}

	// Single endpoint case - resolve URL and delete
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	return r.deleteFromEndpoint(ctx, instance, baseURL)
}

func (r *PetReconciler) updateStatus(ctx context.Context, instance *v1alpha1.Pet, state, message string) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	instance.Status.State = state
	instance.Status.Message = message
	instance.Status.LastSyncTime = &now
	instance.Status.ObservedGeneration = instance.Generation

	// Update condition
	condition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	// Set Ready=True for successful states
	if state == "Synced" || state == "Observed" {
		condition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, condition)

	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *PetReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.Pet{}).
		Complete(r)
}
