/*
Copyright 2026 Generated by openapi-operator-gen v0.0.9-6-gc493b20-dirty.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"
	"time"

	"github.com/bluecontainer/openapi-operator-gen/pkg/aggregate"
	celutil "github.com/bluecontainer/openapi-operator-gen/pkg/cel"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"

	controllerutil2 "github.com/bluecontainer/openapi-operator-gen/pkg/controller"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

var (
	petstoreaggregateTracer = otel.Tracer("github.com/bluecontainer/petstore-operator/controller/petstoreaggregate")
	petstoreaggregateMeter  = otel.Meter("github.com/bluecontainer/petstore-operator/controller/petstoreaggregate")

	// Metrics
	petstoreaggregateReconcileTotal    metric.Int64Counter
	petstoreaggregateReconcileDuration metric.Float64Histogram
	petstoreaggregateResourcesTotal    metric.Int64UpDownCounter
)

func init() {
	var err error

	petstoreaggregateReconcileTotal, err = petstoreaggregateMeter.Int64Counter(
		"reconcile_total",
		metric.WithDescription("Total number of reconciliations"),
		metric.WithUnit("{reconcile}"),
	)
	if err != nil {
		otel.Handle(err)
	}

	petstoreaggregateReconcileDuration, err = petstoreaggregateMeter.Float64Histogram(
		"reconcile_duration_seconds",
		metric.WithDescription("Duration of reconciliation in seconds"),
		metric.WithUnit("s"),
	)
	if err != nil {
		otel.Handle(err)
	}

	petstoreaggregateResourcesTotal, err = petstoreaggregateMeter.Int64UpDownCounter(
		"aggregated_resources_total",
		metric.WithDescription("Total number of resources being aggregated"),
		metric.WithUnit("{resource}"),
	)
	if err != nil {
		otel.Handle(err)
	}
}

const (
	petstoreaggregateRequeueAfter = time.Second * 30
)

// PetstoreAggregateReconciler reconciles a PetstoreAggregate object
type PetstoreAggregateReconciler struct {
	client.Client
	Scheme *k8sruntime.Scheme
}

// +kubebuilder:rbac:groups=petstore.example.com,resources=petstoreaggregates,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=petstoreaggregates/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=petstore.example.com,resources=petstoreaggregates/finalizers,verbs=update
// +kubebuilder:rbac:groups=petstore.example.com,resources=orders,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=pets,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=users,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=petfindbystatusqueries,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=petfindbytagsqueries,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=storeinventoryqueries,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=userloginqueries,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=userlogoutqueries,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=petuploadimageactions,verbs=get;list;watch
// +kubebuilder:rbac:groups=petstore.example.com,resources=usercreatewithlistactions,verbs=get;list;watch

// Reconcile is part of the main kubernetes reconciliation loop
func (r *PetstoreAggregateReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// Start tracing span
	ctx, span := petstoreaggregateTracer.Start(ctx, "Reconcile",
		trace.WithAttributes(
			attribute.String("resource.name", req.Name),
			attribute.String("resource.namespace", req.Namespace),
			attribute.String("resource.kind", "PetstoreAggregate"),
		))
	defer span.End()

	start := time.Now()
	result, err := r.reconcileInternal(ctx, req)
	duration := time.Since(start).Seconds()

	// Record metrics
	status := "success"
	if err != nil {
		status = "error"
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}

	petstoreaggregateReconcileTotal.Add(ctx, 1,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))
	petstoreaggregateReconcileDuration.Record(ctx, duration,
		metric.WithAttributes(
			attribute.String("status", status),
			attribute.String("namespace", req.Namespace),
		))

	return result, err
}

// reconcileInternal contains the actual reconciliation logic
func (r *PetstoreAggregateReconciler) reconcileInternal(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the PetstoreAggregate instance
	instance := &v1alpha1.PetstoreAggregate{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("PetstoreAggregate resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get PetstoreAggregate")
		return ctrl.Result{}, err
	}

	// Aggregate status from all selected resources
	if err := r.aggregateStatus(ctx, instance); err != nil {
		r.updateStatus(ctx, instance, "Failed", err.Error())
		return ctrl.Result{RequeueAfter: petstoreaggregateRequeueAfter}, err
	}

	return ctrl.Result{RequeueAfter: petstoreaggregateRequeueAfter}, nil
}

// aggregateStatus collects and aggregates status from all selected resources
func (r *PetstoreAggregateReconciler) aggregateStatus(ctx context.Context, instance *v1alpha1.PetstoreAggregate) error {
	logger := log.FromContext(ctx)

	// Validate that at least one selection method is specified
	if len(instance.Spec.Resources) == 0 && len(instance.Spec.ResourceSelectors) == 0 {
		return fmt.Errorf("at least one of resources or resourceSelectors must be specified")
	}

	var allResources []v1alpha1.AggregatedResourceStatus
	var allCELData []map[string]interface{} // Full resource data for CEL expressions
	// Kind-specific CEL data maps (e.g., "orders", "pets", "users", queries, actions)
	celDataByKind := map[string][]map[string]interface{}{
		"orders":                    {},
		"pets":                      {},
		"users":                     {},
		"petfindbystatusqueries":    {},
		"petfindbytagsqueries":      {},
		"storeinventoryqueries":     {},
		"userloginqueries":          {},
		"userlogoutqueries":         {},
		"petuploadimageactions":     {},
		"usercreatewithlistactions": {},
	}
	// Use shared summary counter for consistent state classification
	var summaryCounter celutil.SummaryCounter

	// Helper to process a resource and update counters
	// Uses shared classification logic for state names (Synced/Observed/Queried/Completed â†’ synced)
	processResource := func(res v1alpha1.AggregatedResourceStatus, celData map[string]interface{}) {
		allResources = append(allResources, res)
		if celData != nil {
			allCELData = append(allCELData, celData)
			// Add to kind-specific list (lowercase plural)
			kindKey := aggregate.KindToVariableName(res.Kind)
			celDataByKind[kindKey] = append(celDataByKind[kindKey], celData)
		}
		summaryCounter.Add(res.State)
	}

	// Process explicit resource references first (Option 1: Reference-Based)
	for _, ref := range instance.Spec.Resources {
		namespace := aggregate.DefaultNamespace(ref.Namespace, instance.Namespace)
		res, celData, err := r.getResourceByReference(ctx, namespace, ref)
		if err != nil {
			if errors.IsNotFound(err) {
				// Resource not found - add a placeholder with error state
				allResources = append(allResources, v1alpha1.AggregatedResourceStatus{
					Kind:      ref.Kind,
					Name:      ref.Name,
					Namespace: namespace,
					State:     "NotFound",
					Message:   "Referenced resource not found",
				})
				summaryCounter.Add("Failed") // NotFound counts as Failed
				continue
			}
			logger.Error(err, "Failed to get resource", "kind", ref.Kind, "name", ref.Name)
			continue
		}
		processResource(res, celData)
	}

	// Process resource selectors (Option 4: Selector-Based)
	for _, selector := range instance.Spec.ResourceSelectors {
		resources, celData, err := r.listResourcesBySelector(ctx, instance.Namespace, selector)
		if err != nil {
			logger.Error(err, "Failed to list resources", "kind", selector.Kind)
			continue
		}

		for i, res := range resources {
			var itemCelData map[string]interface{}
			if i < len(celData) {
				itemCelData = celData[i]
			}
			processResource(res, itemCelData)
		}
	}

	// Update resource metrics
	petstoreaggregateResourcesTotal.Add(ctx, summaryCounter.Total,
		metric.WithAttributes(
			attribute.String("aggregate.name", instance.Name),
			attribute.String("aggregate.namespace", instance.Namespace),
		))

	// Update status summary
	now := metav1.Now()
	instance.Status.Summary = v1alpha1.AggregateSummary{
		Total:   int(summaryCounter.Total),
		Synced:  int(summaryCounter.Synced),
		Failed:  int(summaryCounter.Failed),
		Pending: int(summaryCounter.Pending),
	}
	instance.Status.Resources = allResources
	instance.Status.LastAggregationTime = &now

	// Evaluate CEL expressions for derived values
	if len(instance.Spec.DerivedValues) > 0 {
		instance.Status.ComputedValues = r.evaluateDerivedValues(ctx, instance, allCELData, celDataByKind)
	} else {
		instance.Status.ComputedValues = nil
	}

	// Determine overall state based on aggregation strategy
	state, message := r.evaluateAggregationStrategy(instance)

	// Set conditions based on aggregation result
	r.setConditions(ctx, instance, state, message, int(summaryCounter.Total), int(summaryCounter.Synced), int(summaryCounter.Failed))

	logger.Info("Aggregated status",
		"total", summaryCounter.Total,
		"synced", summaryCounter.Synced,
		"failed", summaryCounter.Failed,
		"state", state)

	r.updateStatus(ctx, instance, state, message)
	return nil
}

// listResourcesBySelector lists resources matching the selector
// Returns both the aggregated status for display and full resource data for CEL expressions
func (r *PetstoreAggregateReconciler) listResourcesBySelector(ctx context.Context, namespace string, selector v1alpha1.ResourceSelector) ([]v1alpha1.AggregatedResourceStatus, []map[string]interface{}, error) {
	var results []v1alpha1.AggregatedResourceStatus
	var celData []map[string]interface{}

	// Build label selector
	var labelSelector labels.Selector
	if len(selector.MatchLabels) > 0 {
		labelSelector = labels.SelectorFromSet(selector.MatchLabels)
	} else {
		labelSelector = labels.Everything()
	}

	// Compile name pattern regex if specified
	var nameRegex *regexp.Regexp
	if selector.NamePattern != "" {
		var err error
		nameRegex, err = regexp.Compile(selector.NamePattern)
		if err != nil {
			return nil, nil, err
		}
	}

	listOpts := &client.ListOptions{
		Namespace:     namespace,
		LabelSelector: labelSelector,
	}

	// List resources based on kind
	// Handles CRUD resources, Query CRDs, and Action CRDs with different status fields
	switch selector.Kind {
	case "Order":
		list := &v1alpha1.OrderList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			// Apply name pattern filter
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "Order",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				ExternalID:   controllerutil2.GetExternalIDIfPresent(&item),
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastSyncTime,
			})
			celData = append(celData, r.resourceToCELData("Order", &item))
		}
	case "Pet":
		list := &v1alpha1.PetList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			// Apply name pattern filter
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "Pet",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				ExternalID:   controllerutil2.GetExternalIDIfPresent(&item),
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastSyncTime,
			})
			celData = append(celData, r.resourceToCELData("Pet", &item))
		}
	case "User":
		list := &v1alpha1.UserList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			// Apply name pattern filter
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "User",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				ExternalID:   controllerutil2.GetExternalIDIfPresent(&item),
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastSyncTime,
			})
			celData = append(celData, r.resourceToCELData("User", &item))
		}
	case "PetFindbystatusQuery":
		list := &v1alpha1.PetFindbystatusQueryList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "PetFindbystatusQuery",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastQueryTime, // Map LastQueryTime to LastSyncTime
			})
			celData = append(celData, r.resourceToCELData("PetFindbystatusQuery", &item))
		}
	case "PetFindbytagsQuery":
		list := &v1alpha1.PetFindbytagsQueryList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "PetFindbytagsQuery",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastQueryTime, // Map LastQueryTime to LastSyncTime
			})
			celData = append(celData, r.resourceToCELData("PetFindbytagsQuery", &item))
		}
	case "StoreInventoryQuery":
		list := &v1alpha1.StoreInventoryQueryList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "StoreInventoryQuery",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastQueryTime, // Map LastQueryTime to LastSyncTime
			})
			celData = append(celData, r.resourceToCELData("StoreInventoryQuery", &item))
		}
	case "UserLoginQuery":
		list := &v1alpha1.UserLoginQueryList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "UserLoginQuery",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastQueryTime, // Map LastQueryTime to LastSyncTime
			})
			celData = append(celData, r.resourceToCELData("UserLoginQuery", &item))
		}
	case "UserLogoutQuery":
		list := &v1alpha1.UserLogoutQueryList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "UserLogoutQuery",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastQueryTime, // Map LastQueryTime to LastSyncTime
			})
			celData = append(celData, r.resourceToCELData("UserLogoutQuery", &item))
		}
	case "PetUploadimageAction":
		list := &v1alpha1.PetUploadimageActionList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "PetUploadimageAction",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastExecutionTime, // Map LastExecutionTime to LastSyncTime
			})
			celData = append(celData, r.resourceToCELData("PetUploadimageAction", &item))
		}
	case "UserCreatewithlistAction":
		list := &v1alpha1.UserCreatewithlistActionList{}
		if err := r.List(ctx, list, listOpts); err != nil {
			return nil, nil, err
		}
		for _, item := range list.Items {
			if nameRegex != nil && !nameRegex.MatchString(item.Name) {
				continue
			}
			results = append(results, v1alpha1.AggregatedResourceStatus{
				Kind:         "UserCreatewithlistAction",
				Name:         item.Name,
				Namespace:    item.Namespace,
				State:        item.Status.State,
				Message:      item.Status.Message,
				LastSyncTime: item.Status.LastExecutionTime, // Map LastExecutionTime to LastSyncTime
			})
			celData = append(celData, r.resourceToCELData("UserCreatewithlistAction", &item))
		}
	}

	return results, celData, nil
}

// getResourceByReference fetches a specific resource by explicit reference
// Returns the aggregated status for display and full resource data for CEL expressions
func (r *PetstoreAggregateReconciler) getResourceByReference(ctx context.Context, namespace string, ref v1alpha1.ResourceReference) (v1alpha1.AggregatedResourceStatus, map[string]interface{}, error) {
	var result v1alpha1.AggregatedResourceStatus
	var celData map[string]interface{}

	key := client.ObjectKey{
		Name:      ref.Name,
		Namespace: namespace,
	}

	// Fetch resource based on kind
	// Handles CRUD resources, Query CRDs, and Action CRDs with different status fields
	switch ref.Kind {
	case "Order":
		item := &v1alpha1.Order{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "Order",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			ExternalID:   controllerutil2.GetExternalIDIfPresent(item),
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastSyncTime,
		}
		celData = r.resourceToCELData("Order", item)
	case "Pet":
		item := &v1alpha1.Pet{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "Pet",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			ExternalID:   controllerutil2.GetExternalIDIfPresent(item),
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastSyncTime,
		}
		celData = r.resourceToCELData("Pet", item)
	case "User":
		item := &v1alpha1.User{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "User",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			ExternalID:   controllerutil2.GetExternalIDIfPresent(item),
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastSyncTime,
		}
		celData = r.resourceToCELData("User", item)
	case "PetFindbystatusQuery":
		item := &v1alpha1.PetFindbystatusQuery{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "PetFindbystatusQuery",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastQueryTime,
		}
		celData = r.resourceToCELData("PetFindbystatusQuery", item)
	case "PetFindbytagsQuery":
		item := &v1alpha1.PetFindbytagsQuery{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "PetFindbytagsQuery",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastQueryTime,
		}
		celData = r.resourceToCELData("PetFindbytagsQuery", item)
	case "StoreInventoryQuery":
		item := &v1alpha1.StoreInventoryQuery{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "StoreInventoryQuery",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastQueryTime,
		}
		celData = r.resourceToCELData("StoreInventoryQuery", item)
	case "UserLoginQuery":
		item := &v1alpha1.UserLoginQuery{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "UserLoginQuery",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastQueryTime,
		}
		celData = r.resourceToCELData("UserLoginQuery", item)
	case "UserLogoutQuery":
		item := &v1alpha1.UserLogoutQuery{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "UserLogoutQuery",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastQueryTime,
		}
		celData = r.resourceToCELData("UserLogoutQuery", item)
	case "PetUploadimageAction":
		item := &v1alpha1.PetUploadimageAction{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "PetUploadimageAction",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastExecutionTime,
		}
		celData = r.resourceToCELData("PetUploadimageAction", item)
	case "UserCreatewithlistAction":
		item := &v1alpha1.UserCreatewithlistAction{}
		if err := r.Get(ctx, key, item); err != nil {
			return result, nil, err
		}
		result = v1alpha1.AggregatedResourceStatus{
			Kind:         "UserCreatewithlistAction",
			Name:         item.Name,
			Namespace:    item.Namespace,
			State:        item.Status.State,
			Message:      item.Status.Message,
			LastSyncTime: item.Status.LastExecutionTime,
		}
		celData = r.resourceToCELData("UserCreatewithlistAction", item)
	default:
		return result, nil, fmt.Errorf("unsupported resource kind: %s", ref.Kind)
	}

	return result, celData, nil
}

// evaluateAggregationStrategy determines the overall state based on the configured strategy
func (r *PetstoreAggregateReconciler) evaluateAggregationStrategy(instance *v1alpha1.PetstoreAggregate) (string, string) {
	summary := instance.Status.Summary
	strategy := instance.Spec.AggregationStrategy

	if strategy == "" {
		strategy = "AllHealthy" // default
	}

	switch strategy {
	case "AllHealthy":
		if summary.Total == 0 {
			return "Pending", "No resources found matching selectors"
		}
		if summary.Failed > 0 {
			return "Degraded", formatMessage("%d of %d resources failed", summary.Failed, summary.Total)
		}
		if summary.Synced == summary.Total {
			return "Healthy", formatMessage("All %d resources are synced", summary.Total)
		}
		return "Pending", formatMessage("%d of %d resources synced", summary.Synced, summary.Total)

	case "AnyHealthy":
		if summary.Total == 0 {
			return "Pending", "No resources found matching selectors"
		}
		if summary.Synced > 0 {
			return "Healthy", formatMessage("%d of %d resources are synced", summary.Synced, summary.Total)
		}
		return "Degraded", formatMessage("No healthy resources (%d total)", summary.Total)

	case "Quorum":
		if summary.Total == 0 {
			return "Pending", "No resources found matching selectors"
		}
		quorum := (summary.Total / 2) + 1
		if summary.Synced >= quorum {
			return "Healthy", formatMessage("Quorum reached: %d of %d resources synced (need %d)", summary.Synced, summary.Total, quorum)
		}
		return "Degraded", formatMessage("Quorum not reached: %d of %d resources synced (need %d)", summary.Synced, summary.Total, quorum)

	default:
		return "Unknown", formatMessage("Unknown aggregation strategy: %s", strategy)
	}
}

// formatMessage is a helper to format messages
func formatMessage(format string, args ...interface{}) string {
	return fmt.Sprintf(format, args...)
}

// evaluateDerivedValues evaluates CEL expressions against the aggregated resources
// celResources contains full resource data with spec, status, and metadata for each CR
// celDataByKind contains kind-specific lists (e.g., "orders", "pets", "users")
func (r *PetstoreAggregateReconciler) evaluateDerivedValues(ctx context.Context, instance *v1alpha1.PetstoreAggregate, celResources []map[string]interface{}, celDataByKind map[string][]map[string]interface{}) []v1alpha1.ComputedValue {
	logger := log.FromContext(ctx)
	var results []v1alpha1.ComputedValue

	// Create CEL environment using the shared utility
	kindNames := []string{
		"orders",
		"pets",
		"users",
		"petfindbystatusqueries",
		"petfindbytagsqueries",
		"storeinventoryqueries",
		"userloginqueries",
		"userlogoutqueries",
		"petuploadimageactions",
		"usercreatewithlistactions",
	}
	// Collect resource-specific keys using {kind}-{name} convention
	resourceKeys := celutil.CollectResourceKeys(celResources)
	env, err := celutil.NewEnvironmentWithResources(kindNames, resourceKeys)
	if err != nil {
		logger.Error(err, "Failed to create CEL environment")
		for _, dv := range instance.Spec.DerivedValues {
			results = append(results, v1alpha1.ComputedValue{
				Name:  dv.Name,
				Error: fmt.Sprintf("failed to create CEL environment: %v", err),
			})
		}
		return results
	}

	// Build evaluation variables using the shared utility (includes resource-specific variables)
	celSummary := celutil.BuildSummary(
		int64(instance.Status.Summary.Total),
		int64(instance.Status.Summary.Synced),
		int64(instance.Status.Summary.Failed),
		int64(instance.Status.Summary.Pending),
	)
	evalVars := celutil.BuildVariablesWithResources(celResources, celSummary, celDataByKind)

	// Evaluate each derived value expression
	for _, dv := range instance.Spec.DerivedValues {
		result := v1alpha1.ComputedValue{Name: dv.Name}

		// Use the shared evaluation function
		evalResult := celutil.Evaluate(env, dv.Expression, evalVars)
		if evalResult.Error != nil {
			result.Error = evalResult.Error.Error()
			results = append(results, result)
			continue
		}

		// Convert result to string using the shared utility
		result.Value = celutil.ValueToString(evalResult.RawValue)
		results = append(results, result)

		logger.V(1).Info("Evaluated CEL expression",
			"name", dv.Name,
			"expression", dv.Expression,
			"result", result.Value)
	}

	return results
}

// resourceToCELData converts a typed resource to a CEL-compatible map
// The map contains: kind, metadata (name, namespace, labels, annotations), spec, and status
func (r *PetstoreAggregateReconciler) resourceToCELData(kind string, obj interface{}) map[string]interface{} {
	result := map[string]interface{}{
		"kind": kind,
	}

	// Use JSON marshaling to convert structs to maps (handles all field types)
	// Handles CRUD resources, Query CRDs, and Action CRDs
	switch kind {
	case "Order":
		if item, ok := obj.(*v1alpha1.Order); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "Pet":
		if item, ok := obj.(*v1alpha1.Pet); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "User":
		if item, ok := obj.(*v1alpha1.User); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "PetFindbystatusQuery":
		if item, ok := obj.(*v1alpha1.PetFindbystatusQuery); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "PetFindbytagsQuery":
		if item, ok := obj.(*v1alpha1.PetFindbytagsQuery); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "StoreInventoryQuery":
		if item, ok := obj.(*v1alpha1.StoreInventoryQuery); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "UserLoginQuery":
		if item, ok := obj.(*v1alpha1.UserLoginQuery); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "UserLogoutQuery":
		if item, ok := obj.(*v1alpha1.UserLogoutQuery); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "PetUploadimageAction":
		if item, ok := obj.(*v1alpha1.PetUploadimageAction); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	case "UserCreatewithlistAction":
		if item, ok := obj.(*v1alpha1.UserCreatewithlistAction); ok {
			result["metadata"] = map[string]interface{}{
				"name":        item.Name,
				"namespace":   item.Namespace,
				"labels":      item.Labels,
				"annotations": item.Annotations,
			}
			if specBytes, err := json.Marshal(item.Spec); err == nil {
				var specMap map[string]interface{}
				if json.Unmarshal(specBytes, &specMap) == nil {
					result["spec"] = specMap
				}
			}
			if statusBytes, err := json.Marshal(item.Status); err == nil {
				var statusMap map[string]interface{}
				if json.Unmarshal(statusBytes, &statusMap) == nil {
					result["status"] = statusMap
				}
			}
		}
	}

	// Ensure spec and status exist even if empty
	if result["spec"] == nil {
		result["spec"] = map[string]interface{}{}
	}
	if result["status"] == nil {
		result["status"] = map[string]interface{}{}
	}
	if result["metadata"] == nil {
		result["metadata"] = map[string]interface{}{}
	}

	return result
}

// setConditions sets the status conditions based on aggregation results
func (r *PetstoreAggregateReconciler) setConditions(ctx context.Context, instance *v1alpha1.PetstoreAggregate, state, message string, total, synced, failed int) {
	now := metav1.Now()

	// Ready condition - True when state is Healthy
	readyCondition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Healthy" {
		readyCondition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, readyCondition)

	// AllHealthy condition - True when all resources are synced
	allHealthyCondition := metav1.Condition{
		Type:               "AllHealthy",
		Status:             metav1.ConditionFalse,
		Reason:             "NotAllSynced",
		Message:            formatMessage("%d of %d resources synced", synced, total),
		LastTransitionTime: now,
	}
	if total > 0 && synced == total {
		allHealthyCondition.Status = metav1.ConditionTrue
		allHealthyCondition.Reason = "AllSynced"
		allHealthyCondition.Message = formatMessage("All %d resources synced", total)
	}
	meta.SetStatusCondition(&instance.Status.Conditions, allHealthyCondition)

	// HasFailures condition - True when any resource has failed
	hasFailuresCondition := metav1.Condition{
		Type:               "HasFailures",
		Status:             metav1.ConditionFalse,
		Reason:             "NoFailures",
		Message:            "No resources have failed",
		LastTransitionTime: now,
	}
	if failed > 0 {
		hasFailuresCondition.Status = metav1.ConditionTrue
		hasFailuresCondition.Reason = "ResourcesFailed"
		hasFailuresCondition.Message = formatMessage("%d resources have failed", failed)
	}
	meta.SetStatusCondition(&instance.Status.Conditions, hasFailuresCondition)
}

func (r *PetstoreAggregateReconciler) updateStatus(ctx context.Context, instance *v1alpha1.PetstoreAggregate, state, message string) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	instance.Status.State = state
	instance.Status.Message = message
	instance.Status.LastAggregationTime = &now
	instance.Status.ObservedGeneration = instance.Generation

	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *PetstoreAggregateReconciler) SetupWithManager(mgr ctrl.Manager) error {
	builder := ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.PetstoreAggregate{})

	// Watch all resource types that can be aggregated (CRUD, Query, Action)
	// When any of these resources change, find aggregates that might be affected
	builder = builder.Watches(
		&v1alpha1.Order{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForOrder),
	)
	builder = builder.Watches(
		&v1alpha1.Pet{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForPet),
	)
	builder = builder.Watches(
		&v1alpha1.User{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForUser),
	)
	builder = builder.Watches(
		&v1alpha1.PetFindbystatusQuery{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForPetFindbystatusQuery),
	)
	builder = builder.Watches(
		&v1alpha1.PetFindbytagsQuery{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForPetFindbytagsQuery),
	)
	builder = builder.Watches(
		&v1alpha1.StoreInventoryQuery{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForStoreInventoryQuery),
	)
	builder = builder.Watches(
		&v1alpha1.UserLoginQuery{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForUserLoginQuery),
	)
	builder = builder.Watches(
		&v1alpha1.UserLogoutQuery{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForUserLogoutQuery),
	)
	builder = builder.Watches(
		&v1alpha1.PetUploadimageAction{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForPetUploadimageAction),
	)
	builder = builder.Watches(
		&v1alpha1.UserCreatewithlistAction{},
		handler.EnqueueRequestsFromMapFunc(r.findAggregatesForUserCreatewithlistAction),
	)

	return builder.Complete(r)
}

// findAggregatesForOrder finds all PetstoreAggregate resources that might be affected by a Order change
func (r *PetstoreAggregateReconciler) findAggregatesForOrder(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "Order" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches Order resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "Order" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForPet finds all PetstoreAggregate resources that might be affected by a Pet change
func (r *PetstoreAggregateReconciler) findAggregatesForPet(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "Pet" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches Pet resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "Pet" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForUser finds all PetstoreAggregate resources that might be affected by a User change
func (r *PetstoreAggregateReconciler) findAggregatesForUser(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "User" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches User resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "User" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForPetFindbystatusQuery finds all PetstoreAggregate resources that might be affected by a PetFindbystatusQuery change
func (r *PetstoreAggregateReconciler) findAggregatesForPetFindbystatusQuery(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "PetFindbystatusQuery" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches PetFindbystatusQuery resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "PetFindbystatusQuery" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForPetFindbytagsQuery finds all PetstoreAggregate resources that might be affected by a PetFindbytagsQuery change
func (r *PetstoreAggregateReconciler) findAggregatesForPetFindbytagsQuery(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "PetFindbytagsQuery" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches PetFindbytagsQuery resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "PetFindbytagsQuery" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForStoreInventoryQuery finds all PetstoreAggregate resources that might be affected by a StoreInventoryQuery change
func (r *PetstoreAggregateReconciler) findAggregatesForStoreInventoryQuery(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "StoreInventoryQuery" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches StoreInventoryQuery resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "StoreInventoryQuery" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForUserLoginQuery finds all PetstoreAggregate resources that might be affected by a UserLoginQuery change
func (r *PetstoreAggregateReconciler) findAggregatesForUserLoginQuery(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "UserLoginQuery" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches UserLoginQuery resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "UserLoginQuery" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForUserLogoutQuery finds all PetstoreAggregate resources that might be affected by a UserLogoutQuery change
func (r *PetstoreAggregateReconciler) findAggregatesForUserLogoutQuery(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "UserLogoutQuery" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches UserLogoutQuery resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "UserLogoutQuery" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForPetUploadimageAction finds all PetstoreAggregate resources that might be affected by a PetUploadimageAction change
func (r *PetstoreAggregateReconciler) findAggregatesForPetUploadimageAction(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "PetUploadimageAction" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches PetUploadimageAction resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "PetUploadimageAction" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}

// findAggregatesForUserCreatewithlistAction finds all PetstoreAggregate resources that might be affected by a UserCreatewithlistAction change
func (r *PetstoreAggregateReconciler) findAggregatesForUserCreatewithlistAction(ctx context.Context, obj client.Object) []reconcile.Request {
	logger := log.FromContext(ctx)

	// List all aggregates in the same namespace
	aggregateList := &v1alpha1.PetstoreAggregateList{}
	if err := r.List(ctx, aggregateList, client.InNamespace(obj.GetNamespace())); err != nil {
		logger.Error(err, "Failed to list aggregates")
		return nil
	}

	var requests []reconcile.Request
	seenAggregates := make(map[string]bool) // Track which aggregates we've already added

	for _, aggregate := range aggregateList.Items {
		aggregateKey := aggregate.Namespace + "/" + aggregate.Name

		// Check if this aggregate explicitly references this resource (Option 1)
		for _, ref := range aggregate.Spec.Resources {
			if ref.Kind == "UserCreatewithlistAction" && ref.Name == obj.GetName() {
				// Check namespace match (empty ref.Namespace means same namespace as aggregate)
				refNamespace := ref.Namespace
				if refNamespace == "" {
					refNamespace = aggregate.Namespace
				}
				if refNamespace == obj.GetNamespace() {
					if !seenAggregates[aggregateKey] {
						requests = append(requests, reconcile.Request{
							NamespacedName: client.ObjectKey{
								Name:      aggregate.Name,
								Namespace: aggregate.Namespace,
							},
						})
						seenAggregates[aggregateKey] = true
					}
					break
				}
			}
		}

		// Skip selector check if already added
		if seenAggregates[aggregateKey] {
			continue
		}

		// Check if this aggregate watches UserCreatewithlistAction resources via selectors (Option 4)
		for _, selector := range aggregate.Spec.ResourceSelectors {
			if selector.Kind == "UserCreatewithlistAction" {
				// Check if labels match (if selector has matchLabels)
				if len(selector.MatchLabels) > 0 {
					labelSelector := labels.SelectorFromSet(selector.MatchLabels)
					if !labelSelector.Matches(labels.Set(obj.GetLabels())) {
						continue
					}
				}
				// Check if name pattern matches (if specified)
				if selector.NamePattern != "" {
					nameRegex, err := regexp.Compile(selector.NamePattern)
					if err != nil || !nameRegex.MatchString(obj.GetName()) {
						continue
					}
				}
				// This aggregate watches this resource
				if !seenAggregates[aggregateKey] {
					requests = append(requests, reconcile.Request{
						NamespacedName: client.ObjectKey{
							Name:      aggregate.Name,
							Namespace: aggregate.Namespace,
						},
					})
					seenAggregates[aggregateKey] = true
				}
				break
			}
		}
	}

	return requests
}
