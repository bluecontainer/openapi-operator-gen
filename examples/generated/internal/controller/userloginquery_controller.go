/*
Copyright 2026 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sruntime "k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/bluecontainer/openapi-operator-gen/pkg/endpoint"
	v1alpha1 "github.com/bluecontainer/petstore-operator/api/v1alpha1"
)

const (
	userloginqueryFinalizer    = "petstore.example.com/finalizer"
	userloginqueryRequeueAfter = time.Second * 30
)

// UserLoginQueryReconciler reconciles a UserLoginQuery query object
type UserLoginQueryReconciler struct {
	client.Client
	Scheme           *k8sruntime.Scheme
	HTTPClient       *http.Client
	EndpointResolver *endpoint.Resolver
	// BaseURL is used when EndpointResolver is nil (static URL mode)
	BaseURL string
}

// +kubebuilder:rbac:groups=petstore.example.com,resources=userloginquerys,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=petstore.example.com,resources=userloginquerys/status,verbs=get;update;patch

// Reconcile executes the query and updates the status with results
func (r *UserLoginQueryReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// Fetch the UserLoginQuery instance
	instance := &v1alpha1.UserLoginQuery{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			logger.Info("UserLoginQuery resource not found. Ignoring since object must be deleted")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get UserLoginQuery")
		return ctrl.Result{}, err
	}

	// Execute the query
	if err := r.executeQuery(ctx, instance); err != nil {
		r.updateStatus(ctx, instance, "Failed", err.Error(), 0)
		return ctrl.Result{RequeueAfter: userloginqueryRequeueAfter}, err
	}

	return ctrl.Result{RequeueAfter: userloginqueryRequeueAfter}, nil
}

func (r *UserLoginQueryReconciler) getBaseURL(ctx context.Context) (string, error) {
	if r.EndpointResolver != nil {
		return r.EndpointResolver.GetEndpoint()
	}
	if r.BaseURL == "" {
		return "", fmt.Errorf("no base URL configured")
	}
	return r.BaseURL, nil
}

func (r *UserLoginQueryReconciler) getBaseURLByOrdinal(ctx context.Context, ordinal *int32) (string, error) {
	if r.EndpointResolver != nil && r.EndpointResolver.IsByOrdinalStrategy() {
		if ordinal == nil {
			return "", fmt.Errorf("targetPodOrdinal is required when using by-ordinal strategy")
		}
		return r.EndpointResolver.GetEndpointByOrdinal(int(*ordinal))
	}
	return r.getBaseURL(ctx)
}

// resolveBaseURL determines the base URL to use for API requests based on CR targeting fields
func (r *UserLoginQueryReconciler) resolveBaseURL(ctx context.Context, instance *v1alpha1.UserLoginQuery) (string, error) {
	if r.EndpointResolver != nil {
		namespace := instance.Spec.TargetNamespace
		if namespace == "" {
			namespace = instance.Namespace
		}

		if instance.Spec.TargetHelmRelease != "" {
			return r.EndpointResolver.GetEndpointForHelmRelease(ctx, instance.Spec.TargetHelmRelease, namespace, instance.Spec.TargetPodOrdinal)
		}

		if instance.Spec.TargetStatefulSet != "" {
			return r.EndpointResolver.GetEndpointForStatefulSet(ctx, instance.Spec.TargetStatefulSet, namespace, instance.Spec.TargetPodOrdinal)
		}

		if instance.Spec.TargetDeployment != "" {
			return r.EndpointResolver.GetEndpointForDeployment(ctx, instance.Spec.TargetDeployment, namespace)
		}

		if r.EndpointResolver.IsByOrdinalStrategy() {
			return r.getBaseURLByOrdinal(ctx, instance.Spec.TargetPodOrdinal)
		}
	}

	return r.getBaseURL(ctx)
}

// buildQueryURL builds the query URL from the spec parameters
func (r *UserLoginQueryReconciler) buildQueryURL(baseURL string, instance *v1alpha1.UserLoginQuery) string {
	queryURL := baseURL + "/user/login"

	params := url.Values{}
	specVal := reflect.ValueOf(instance.Spec)
	specType := specVal.Type()

	for i := 0; i < specVal.NumField(); i++ {
		field := specType.Field(i)
		value := specVal.Field(i)

		// Skip controller-specific fields
		fieldName := field.Name
		if fieldName == "TargetPodOrdinal" || fieldName == "TargetHelmRelease" ||
			fieldName == "TargetStatefulSet" || fieldName == "TargetDeployment" ||
			fieldName == "TargetNamespace" {
			continue
		}

		// Get JSON tag name
		jsonTag := field.Tag.Get("json")
		if jsonTag == "" || jsonTag == "-" {
			continue
		}
		// Remove omitempty suffix
		if idx := len(jsonTag) - 1; idx > 0 {
			for j := 0; j < len(jsonTag); j++ {
				if jsonTag[j] == ',' {
					jsonTag = jsonTag[:j]
					break
				}
			}
		}

		// Handle different types
		if value.Kind() == reflect.Slice {
			for j := 0; j < value.Len(); j++ {
				params.Add(jsonTag, fmt.Sprintf("%v", value.Index(j).Interface()))
			}
		} else if value.Kind() == reflect.Ptr {
			if !value.IsNil() {
				params.Set(jsonTag, fmt.Sprintf("%v", value.Elem().Interface()))
			}
		} else if !value.IsZero() {
			params.Set(jsonTag, fmt.Sprintf("%v", value.Interface()))
		}
	}

	if len(params) > 0 {
		queryURL += "?" + params.Encode()
	}

	return queryURL
}

// executeQueryToEndpoint executes the query against a single endpoint
func (r *UserLoginQueryReconciler) executeQueryToEndpoint(ctx context.Context, instance *v1alpha1.UserLoginQuery, baseURL string) ([]byte, int, error) {
	logger := log.FromContext(ctx)

	queryURL := r.buildQueryURL(baseURL, instance)

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL, nil)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")

	logger.Info("Executing query", "url", queryURL)
	resp, err := r.HTTPClient.Do(req)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return nil, resp.StatusCode, fmt.Errorf("query failed: %s - %s", resp.Status, string(body))
	}

	return body, resp.StatusCode, nil
}

// countResults attempts to count results in the response
func (r *UserLoginQueryReconciler) countResults(body []byte) int {
	// Try to parse as array
	var arr []interface{}
	if err := json.Unmarshal(body, &arr); err == nil {
		return len(arr)
	}

	// Try to parse as object with items/data/results field
	var obj map[string]interface{}
	if err := json.Unmarshal(body, &obj); err == nil {
		for _, key := range []string{"items", "data", "results", "content"} {
			if items, ok := obj[key].([]interface{}); ok {
				return len(items)
			}
		}
		// If it's an object, count as 1 result
		return 1
	}

	return 0
}

func (r *UserLoginQueryReconciler) executeQuery(ctx context.Context, instance *v1alpha1.UserLoginQuery) error {
	logger := log.FromContext(ctx)
	now := metav1.Now()

	// Check if using all-healthy strategy (fan out to multiple endpoints)
	if r.EndpointResolver != nil && r.EndpointResolver.IsAllHealthyStrategy() {
		baseURLs, err := r.EndpointResolver.GetAllHealthyEndpoints()
		if err != nil {
			return fmt.Errorf("failed to get all healthy endpoints: %w", err)
		}

		if len(baseURLs) > 1 {
			// Multiple endpoints - collect responses from all
			responses := make(map[string]v1alpha1.UserLoginQueryEndpointResponse)
			var firstSuccessResp *v1alpha1.UserLoginQueryEndpointResponse
			var firstResultCount int
			successCount := 0

			for _, baseURL := range baseURLs {
				endpointResp := v1alpha1.UserLoginQueryEndpointResponse{
					LastUpdated: &now,
				}

				body, statusCode, err := r.executeQueryToEndpoint(ctx, instance, baseURL)
				if err != nil {
					endpointResp.Success = false
					endpointResp.StatusCode = statusCode
					endpointResp.Error = err.Error()
					logger.Info("Query failed for endpoint", "endpoint", baseURL, "error", err)
				} else {
					endpointResp.Success = true
					endpointResp.StatusCode = statusCode
					endpointResp.Data = &k8sruntime.RawExtension{Raw: body}
					successCount++
					resultCount := r.countResults(body)
					if firstSuccessResp == nil {
						respCopy := endpointResp
						firstSuccessResp = &respCopy
						firstResultCount = resultCount
					}
					logger.Info("Query succeeded for endpoint", "endpoint", baseURL, "resultCount", resultCount)
				}

				responses[baseURL] = endpointResp
			}

			// Update status with all responses
			instance.Status.Responses = responses
			instance.Status.LastQueryTime = &now

			// Set Results to first successful response
			if firstSuccessResp != nil {
				instance.Status.Results = firstSuccessResp
				instance.Status.ResultCount = firstResultCount
			}

			if successCount == 0 {
				r.updateStatus(ctx, instance, "Failed", fmt.Sprintf("Query failed on all %d endpoints", len(baseURLs)), 0)
				return fmt.Errorf("query failed on all endpoints")
			}

			message := fmt.Sprintf("Query executed on %d/%d endpoints", successCount, len(baseURLs))
			r.updateStatus(ctx, instance, "Queried", message, instance.Status.ResultCount)
			return nil
		}
	}

	// Single endpoint case
	baseURL, err := r.resolveBaseURL(ctx, instance)
	if err != nil {
		return fmt.Errorf("failed to resolve base URL: %w", err)
	}

	body, statusCode, err := r.executeQueryToEndpoint(ctx, instance, baseURL)

	// Build EndpointResponse for Results
	endpointResp := v1alpha1.UserLoginQueryEndpointResponse{
		LastUpdated: &now,
		StatusCode:  statusCode,
	}

	if err != nil {
		endpointResp.Success = false
		endpointResp.Error = err.Error()
		instance.Status.Results = &endpointResp
		instance.Status.LastQueryTime = &now
		instance.Status.Responses = nil
		r.updateStatus(ctx, instance, "Failed", err.Error(), 0)
		return err
	}

	endpointResp.Success = true
	endpointResp.Data = &k8sruntime.RawExtension{Raw: body}
	resultCount := r.countResults(body)

	// Update status with results
	instance.Status.Results = &endpointResp
	instance.Status.LastQueryTime = &now
	instance.Status.Responses = nil // Clear multi-endpoint responses
	r.updateStatus(ctx, instance, "Queried", "Query executed successfully", resultCount)
	return nil
}

func (r *UserLoginQueryReconciler) updateStatus(ctx context.Context, instance *v1alpha1.UserLoginQuery, state, message string, resultCount int) {
	logger := log.FromContext(ctx)

	now := metav1.Now()
	instance.Status.State = state
	instance.Status.Message = message
	instance.Status.ResultCount = resultCount
	instance.Status.ObservedGeneration = instance.Generation

	if instance.Status.LastQueryTime == nil {
		instance.Status.LastQueryTime = &now
	}

	// Update condition
	condition := metav1.Condition{
		Type:               "Ready",
		Status:             metav1.ConditionFalse,
		Reason:             state,
		Message:            message,
		LastTransitionTime: now,
	}
	if state == "Queried" {
		condition.Status = metav1.ConditionTrue
	}
	meta.SetStatusCondition(&instance.Status.Conditions, condition)

	if err := r.Status().Update(ctx, instance); err != nil {
		logger.Error(err, "Failed to update status")
	}
}

// SetupWithManager sets up the controller with the Manager
func (r *UserLoginQueryReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1alpha1.UserLoginQuery{}).
		Complete(r)
}
