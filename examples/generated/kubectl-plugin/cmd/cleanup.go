// Generated by openapi-operator-gen v0.0.10-6-gad62e9c-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	cleanupExpired   bool
	cleanupDryRun    bool
	cleanupForce     bool
	cleanupLabel     string
	cleanupAllNS     bool
	cleanupOneShot   bool
	cleanupDiagnostic bool
)

var cleanupCmd = &cobra.Command{
	Use:   "cleanup",
	Short: "Remove diagnostic and temporary petstore resources",
	Long: `Remove diagnostic, one-shot, and temporary resources created by the kubectl plugin.

This command cleans up resources that were created for:
- One-shot queries and actions
- Diagnostic sessions
- Resources with expired TTL patches

Resources are identified by annotations set when they were created.

Examples:
  # Remove all one-shot resources (queries/actions)
  kubectl petstore cleanup --one-shot

  # Remove only expired TTL resources
  kubectl petstore cleanup --expired

  # Remove resources by label
  kubectl petstore cleanup -l diagnostic-session=session-123

  # Dry run - show what would be deleted
  kubectl petstore cleanup --dry-run

  # Remove all diagnostic resources without confirmation
  kubectl petstore cleanup --force

  # Cleanup across all namespaces
  kubectl petstore cleanup --all-namespaces`,
	RunE: runCleanup,
}

func init() {
	cleanupCmd.Flags().BoolVar(&cleanupExpired, "expired", false, "Remove only resources with expired TTL")
	cleanupCmd.Flags().BoolVar(&cleanupDryRun, "dry-run", false, "Preview what would be deleted without deleting")
	cleanupCmd.Flags().BoolVar(&cleanupForce, "force", false, "Delete without confirmation prompt")
	cleanupCmd.Flags().StringVarP(&cleanupLabel, "selector", "l", "", "Label selector to filter resources")
	cleanupCmd.Flags().BoolVarP(&cleanupAllNS, "all-namespaces", "A", false, "Cleanup across all namespaces")
	cleanupCmd.Flags().BoolVar(&cleanupOneShot, "one-shot", false, "Remove one-shot queries and actions")
	cleanupCmd.Flags().BoolVar(&cleanupDiagnostic, "diagnostic", false, "Remove diagnostic resources")
}

// CleanupAction represents what action to take on a target
type CleanupAction string

const (
	CleanupActionDelete  CleanupAction = "delete"
	CleanupActionRestore CleanupAction = "restore"
)

// CleanupTarget represents a resource to be cleaned up
type CleanupTarget struct {
	Kind          string
	Name          string
	Namespace     string
	Reason        string
	Action        CleanupAction
	OriginalState string // JSON string of original state for restore action
}

func runCleanup(cmd *cobra.Command, args []string) error {
	ctx := context.Background()

	// If no specific filter is set, default to all cleanable resources
	if !cleanupExpired && !cleanupOneShot && !cleanupDiagnostic && cleanupLabel == "" {
		cleanupOneShot = true
		cleanupExpired = true
	}

	// Find resources to clean up
	targets, err := findCleanupTargets(ctx)
	if err != nil {
		return fmt.Errorf("failed to find cleanup targets: %w", err)
	}

	if len(targets) == 0 {
		fmt.Println("No resources to clean up")
		return nil
	}

	// Count actions
	deleteCount := 0
	restoreCount := 0
	for _, t := range targets {
		if t.Action == CleanupActionRestore {
			restoreCount++
		} else {
			deleteCount++
		}
	}

	// Display what will be done
	fmt.Println("Resources to be cleaned up:")
	fmt.Println()

	for _, t := range targets {
		nsPrefix := ""
		if cleanupAllNS {
			nsPrefix = t.Namespace + "/"
		}
		actionLabel := "DELETE"
		actionColor := output.Yellow
		if t.Action == CleanupActionRestore {
			actionLabel = "RESTORE"
			actionColor = output.Cyan
		}
		fmt.Printf("  %s  %s  %s%-20s  %s\n",
			actionColor(fmt.Sprintf("%-8s", actionLabel)),
			output.Yellow(fmt.Sprintf("%-25s", t.Kind)),
			nsPrefix,
			t.Name,
			fmt.Sprintf("(%s)", t.Reason))
	}

	fmt.Println()

	if cleanupDryRun {
		// Build structured output of cleanup targets
		items := make([]map[string]interface{}, 0, len(targets))
		for _, t := range targets {
			item := map[string]interface{}{
				"kind":   t.Kind,
				"name":   t.Name,
				"action": string(t.Action),
				"reason": t.Reason,
			}
			if cleanupAllNS {
				item["namespace"] = t.Namespace
			}
			items = append(items, item)
		}
		result := map[string]interface{}{
			"dryRun":       true,
			"deleteCount":  deleteCount,
			"restoreCount": restoreCount,
			"targets":      items,
		}
		switch outputFormat {
		case "json":
			return output.PrintJSON(result)
		default:
			return output.PrintYAML(result)
		}
	}

	// Confirm unless --force
	if !cleanupForce {
		prompt := fmt.Sprintf("Delete %d resources? [y/N]: ", deleteCount)
		if restoreCount > 0 && deleteCount > 0 {
			prompt = fmt.Sprintf("Restore %d and delete %d resources? [y/N]: ", restoreCount, deleteCount)
		} else if restoreCount > 0 {
			prompt = fmt.Sprintf("Restore %d resources? [y/N]: ", restoreCount)
		}
		fmt.Print(prompt)
		reader := bufio.NewReader(os.Stdin)
		response, _ := reader.ReadString('\n')
		response = strings.TrimSpace(strings.ToLower(response))
		if response != "y" && response != "yes" {
			fmt.Println("Cancelled")
			return nil
		}
	}

	// Process cleanup targets (delete or restore)
	return processCleanupTargets(ctx, targets)
}

func findCleanupTargets(ctx context.Context) ([]CleanupTarget, error) {
	var targets []CleanupTarget

	// Define all resource types to check
	resourceTypes := []struct {
		kind   string
		plural string
	}{
		{"Order", "orders"},
		{"Pet", "pets"},
		{"User", "users"},
		{"PetFindbystatusQuery", "petfindbystatusqueries"},
		{"PetFindbytagsQuery", "petfindbytagsqueries"},
		{"StoreInventoryQuery", "storeinventoryqueries"},
		{"UserLoginQuery", "userloginqueries"},
		{"UserLogoutQuery", "userlogoutqueries"},
		{"PetUploadimageAction", "petuploadimageactions"},
		{"UserCreatewithlistAction", "usercreatewithlistactions"},
	}

	for _, rt := range resourceTypes {
		var list *unstructured.UnstructuredList
		var err error

		if cleanupAllNS {
			list, err = k8sClient.ListAllNamespaces(ctx, rt.plural, cleanupLabel)
		} else {
			list, err = k8sClient.List(ctx, rt.plural)
		}

		if err != nil {
			// Skip kinds that don't exist or we can't access
			continue
		}

		for _, item := range list.Items {
			// Apply label selector filter if specified
			if cleanupLabel != "" && !matchesLabelSelector(item.GetLabels(), cleanupLabel) {
				continue
			}

			target := checkResourceForCleanup(&item, rt.kind)
			if target != nil {
				targets = append(targets, *target)
			}
		}
	}

	return targets, nil
}

func checkResourceForCleanup(obj *unstructured.Unstructured, kind string) *CleanupTarget {
	annotations := obj.GetAnnotations()
	if annotations == nil {
		return nil
	}

	// Check for one-shot resources
	if cleanupOneShot {
		if annotations["petstore.example.com/one-shot"] == "true" {
			return &CleanupTarget{
				Kind:      kind,
				Name:      obj.GetName(),
				Namespace: obj.GetNamespace(),
				Reason:    "one-shot",
				Action:    CleanupActionDelete,
			}
		}
	}

	// Check for expired TTL patches - these should be restored, not deleted
	if cleanupExpired {
		expiresStr := annotations["petstore.example.com/patch-expires"]
		if expiresStr != "" {
			expires, err := time.Parse(time.RFC3339, expiresStr)
			if err == nil && time.Now().After(expires) {
				// Get original state for restoration
				originalState := annotations["petstore.example.com/patch-original-state"]
				return &CleanupTarget{
					Kind:          kind,
					Name:          obj.GetName(),
					Namespace:     obj.GetNamespace(),
					Reason:        "expired TTL",
					Action:        CleanupActionRestore,
					OriginalState: originalState,
				}
			}
		}
	}

	// Check for diagnostic resources
	if cleanupDiagnostic {
		if annotations["petstore.example.com/purpose"] == "diagnostic" ||
			annotations["petstore.example.com/created-by"] == "kubectl-plugin" {
			return &CleanupTarget{
				Kind:      kind,
				Name:      obj.GetName(),
				Namespace: obj.GetNamespace(),
				Reason:    "diagnostic",
				Action:    CleanupActionDelete,
			}
		}
	}

	return nil
}

func matchesLabelSelector(labels map[string]string, selector string) bool {
	// Simple label selector parsing (key=value)
	parts := strings.SplitN(selector, "=", 2)
	if len(parts) != 2 {
		return false
	}
	key, value := parts[0], parts[1]
	return labels[key] == value
}

func processCleanupTargets(ctx context.Context, targets []CleanupTarget) error {
	deleteSuccess := 0
	restoreSuccess := 0
	failCount := 0

	for _, t := range targets {
		// Set namespace for the client
		originalNS := k8sClient.GetNamespace()
		if cleanupAllNS {
			k8sClient.SetNamespace(t.Namespace)
		}

		plural := resolveKindPlural(strings.ToLower(t.Kind))
		if plural == "" {
			// Try query/action plurals
			plural = resolveQueryPlural(strings.ToLower(t.Kind))
			if plural == "" {
				plural = resolveActionPlural(strings.ToLower(t.Kind))
			}
		}

		if plural == "" {
			fmt.Printf("  %s Failed to resolve plural for %s\n", output.Red("✗"), t.Kind)
			failCount++
			k8sClient.SetNamespace(originalNS)
			continue
		}

		nsPrefix := ""
		if cleanupAllNS {
			nsPrefix = t.Namespace + "/"
		}

		var err error
		if t.Action == CleanupActionRestore {
			err = restoreExpiredPatch(ctx, plural, t.Name, t.OriginalState)
			if err != nil {
				fmt.Printf("  %s Failed to restore %s/%s%s: %v\n", output.Red("✗"), t.Kind, nsPrefix, t.Name, err)
				failCount++
			} else {
				fmt.Printf("  %s Restored %s/%s%s\n", output.Green("✓"), t.Kind, nsPrefix, t.Name)
				restoreSuccess++
			}
		} else {
			err = k8sClient.Delete(ctx, plural, t.Name)
			if err != nil {
				fmt.Printf("  %s Failed to delete %s/%s%s: %v\n", output.Red("✗"), t.Kind, nsPrefix, t.Name, err)
				failCount++
			} else {
				fmt.Printf("  %s Deleted %s/%s%s\n", output.Green("✓"), t.Kind, nsPrefix, t.Name)
				deleteSuccess++
			}
		}

		k8sClient.SetNamespace(originalNS)
	}

	fmt.Println()
	total := deleteSuccess + restoreSuccess
	if failCount > 0 {
		if restoreSuccess > 0 && deleteSuccess > 0 {
			fmt.Printf("Restored %d, deleted %d (%d failed)\n", restoreSuccess, deleteSuccess, failCount)
		} else if restoreSuccess > 0 {
			fmt.Printf("Restored %d/%d resources (%d failed)\n", restoreSuccess, restoreSuccess+failCount, failCount)
		} else {
			fmt.Printf("Deleted %d/%d resources (%d failed)\n", deleteSuccess, deleteSuccess+failCount, failCount)
		}
	} else {
		if restoreSuccess > 0 && deleteSuccess > 0 {
			fmt.Printf("Restored %d, deleted %d resources\n", restoreSuccess, deleteSuccess)
		} else if restoreSuccess > 0 {
			fmt.Printf("Restored %d resources\n", restoreSuccess)
		} else {
			fmt.Printf("Deleted %d resources\n", total)
		}
	}

	return nil
}

// restoreExpiredPatch restores the original state of a resource with an expired TTL patch
func restoreExpiredPatch(ctx context.Context, plural, name, originalStateJSON string) error {
	// Get the current resource
	obj, err := k8sClient.Get(ctx, plural, name)
	if err != nil {
		return fmt.Errorf("failed to get resource: %w", err)
	}

	// Get current spec
	spec, found, err := unstructured.NestedMap(obj.Object, "spec")
	if err != nil || !found {
		return fmt.Errorf("failed to get spec: %w", err)
	}

	// Parse the original state if available
	if originalStateJSON != "" {
		var originalSpec map[string]interface{}
		if err := json.Unmarshal([]byte(originalStateJSON), &originalSpec); err != nil {
			return fmt.Errorf("failed to parse original state: %w", err)
		}

		// Restore original values
		for key, value := range originalSpec {
			spec[key] = value
		}

		// Update spec in the resource
		if err := unstructured.SetNestedMap(obj.Object, spec, "spec"); err != nil {
			return fmt.Errorf("failed to set spec: %w", err)
		}
	}

	// Clear patch annotations
	annotations := obj.GetAnnotations()
	if annotations == nil {
		annotations = make(map[string]string)
	}
	delete(annotations, "petstore.example.com/patch-ttl")
	delete(annotations, "petstore.example.com/patch-expires")
	delete(annotations, "petstore.example.com/patch-original-state")
	delete(annotations, "petstore.example.com/patched-by")
	obj.SetAnnotations(annotations)

	// Update the resource
	_, err = k8sClient.Update(ctx, plural, obj)
	if err != nil {
		return fmt.Errorf("failed to update resource: %w", err)
	}

	return nil
}

// Helper to resolve query kind to plural
func resolveQueryPlural(queryType string) string {
	queryType = strings.ToLower(queryType)
	queryPlurals := map[string]string{
		"petfindbystatusquery": "petfindbystatusqueries",
		"petfindbystatusqueries": "petfindbystatusqueries",
		"petfindbytagsquery": "petfindbytagsqueries",
		"petfindbytagsqueries": "petfindbytagsqueries",
		"storeinventoryquery": "storeinventoryqueries",
		"storeinventoryqueries": "storeinventoryqueries",
		"userloginquery": "userloginqueries",
		"userloginqueries": "userloginqueries",
		"userlogoutquery": "userlogoutqueries",
		"userlogoutqueries": "userlogoutqueries",
	}
	return queryPlurals[queryType]
}
