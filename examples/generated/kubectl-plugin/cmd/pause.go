// Generated by openapi-operator-gen v0.0.10-18-g2510b7b-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	pauseAll    bool
	pauseReason string
)

var pauseCmd = &cobra.Command{
	Use:   "pause KIND [NAME]",
	Short: "Pause reconciliation for petstore resources",
	Long: `Pause reconciliation for one or more resources.

When a resource is paused:
  - The controller will NOT sync changes to the external API
  - Drift detection will continue to run and report differences
  - The resource state will show "Paused" with drift status if applicable

Available kinds:
  - order (Order)
  - pet (Pet)
  - user (User)
  - petfindbystatusquery (PetFindbystatusQuery)
  - petfindbytagsquery (PetFindbytagsQuery)
  - storeinventoryquery (StoreInventoryQuery)
  - userloginquery (UserLoginQuery)
  - userlogoutquery (UserLogoutQuery)
  - petuploadimageaction (PetUploadimageAction)
  - usercreatewithlistaction (UserCreatewithlistAction)

Examples:
  # Pause a specific resource
  kubectl petstore pause pet fluffy

  # Pause with a reason
  kubectl petstore pause pet fluffy --reason="Maintenance window"

  # Pause all resources of a kind
  kubectl petstore pause pet --all

  # Pause all resources of a kind in all namespaces
  kubectl petstore pause pet --all -A`,
	Args: cobra.RangeArgs(1, 2),
	RunE: runPause,
}

var unpauseCmd = &cobra.Command{
	Use:   "unpause KIND [NAME]",
	Short: "Resume reconciliation for petstore resources",
	Long: `Resume reconciliation for one or more paused resources.

When a resource is unpaused:
  - The controller will resume syncing changes to the external API
  - If drift was detected while paused, the controller will reconcile

Available kinds:
  - order (Order)
  - pet (Pet)
  - user (User)
  - petfindbystatusquery (PetFindbystatusQuery)
  - petfindbytagsquery (PetFindbytagsQuery)
  - storeinventoryquery (StoreInventoryQuery)
  - userloginquery (UserLoginQuery)
  - userlogoutquery (UserLogoutQuery)
  - petuploadimageaction (PetUploadimageAction)
  - usercreatewithlistaction (UserCreatewithlistAction)

Examples:
  # Unpause a specific resource
  kubectl petstore unpause pet fluffy

  # Unpause all resources of a kind
  kubectl petstore unpause pet --all

  # Unpause all resources of a kind in all namespaces
  kubectl petstore unpause pet --all -A`,
	Args: cobra.RangeArgs(1, 2),
	RunE: runUnpause,
}

func init() {
	// Pause command flags
	pauseCmd.Flags().BoolVar(&pauseAll, "all", false, "Pause all resources of the specified kind")
	pauseCmd.Flags().StringVar(&pauseReason, "reason", "", "Reason for pausing (stored as annotation)")

	// Unpause command flags
	unpauseCmd.Flags().BoolVar(&pauseAll, "all", false, "Unpause all resources of the specified kind")
}

func runPause(cmd *cobra.Command, args []string) error {
	return setPausedState(cmd, args, true)
}

func runUnpause(cmd *cobra.Command, args []string) error {
	return setPausedState(cmd, args, false)
}

func setPausedState(cmd *cobra.Command, args []string, paused bool) error {
	ctx := context.Background()
	kindArg := strings.ToLower(args[0])

	// Resolve kind to plural form
	plural := resolveKindPlural(kindArg)
	if plural == "" {
		return fmt.Errorf("unknown resource kind: %s", kindArg)
	}

	action := "Pausing"
	if !paused {
		action = "Unpausing"
	}

	// Determine if we're operating on a single resource or all resources
	if len(args) == 2 {
		// Single resource
		name := args[1]
		return setPausedForResource(ctx, plural, name, paused, action)
	}

	// Multiple resources (--all flag)
	if !pauseAll {
		return fmt.Errorf("NAME is required unless --all is specified")
	}

	return setPausedForAllResources(ctx, plural, paused, action)
}

func setPausedForResource(ctx context.Context, plural, name string, paused bool, action string) error {
	// Get the resource first
	obj, err := k8sClient.Get(ctx, plural, name)
	if err != nil {
		return fmt.Errorf("failed to get %s/%s: %w", plural, name, err)
	}

	// Check current paused state
	currentPaused, _, _ := unstructured.NestedBool(obj.Object, "spec", "paused")
	if currentPaused == paused {
		state := "already paused"
		if !paused {
			state = "not paused"
		}
		fmt.Printf("%s/%s is %s\n", plural, name, state)
		return nil
	}

	// Update the paused field using a merge patch
	patch := map[string]interface{}{
		"spec": map[string]interface{}{
			"paused": paused,
		},
	}

	// Add reason annotation if pausing and reason is provided
	if paused && pauseReason != "" {
		patch["metadata"] = map[string]interface{}{
			"annotations": map[string]interface{}{
				"petstore.example.com/paused-reason": pauseReason,
			},
		}
	}

	// Remove reason annotation if unpausing
	if !paused {
		// We need to use a JSON patch to remove the annotation
		annotations, _, _ := unstructured.NestedStringMap(obj.Object, "metadata", "annotations")
		if annotations != nil {
			delete(annotations, "petstore.example.com/paused-reason")
			if patch["metadata"] == nil {
				patch["metadata"] = map[string]interface{}{}
			}
			patch["metadata"].(map[string]interface{})["annotations"] = annotations
		}
	}

	patchBytes, err := json.Marshal(patch)
	if err != nil {
		return fmt.Errorf("failed to marshal patch: %w", err)
	}

	_, err = k8sClient.Patch(ctx, plural, name, "merge", patchBytes)
	if err != nil {
		return fmt.Errorf("failed to patch %s/%s: %w", plural, name, err)
	}

	actionPast := "Paused"
	if !paused {
		actionPast = "Unpaused"
	}

	if paused && pauseReason != "" {
		fmt.Printf("%s %s/%s (reason: %s)\n", actionPast, plural, name, pauseReason)
	} else {
		fmt.Printf("%s %s/%s\n", actionPast, plural, name)
	}

	return nil
}

func setPausedForAllResources(ctx context.Context, plural string, paused bool, action string) error {
	// Determine if we should use all namespaces
	allNamespaces := false
	if ns, _ := rootCmd.PersistentFlags().GetBool("all-namespaces"); ns {
		allNamespaces = true
	}

	var list *unstructured.UnstructuredList
	var err error

	if allNamespaces {
		list, err = k8sClient.ListAllNamespaces(ctx, plural, "")
	} else {
		list, err = k8sClient.List(ctx, plural)
	}

	if err != nil {
		return fmt.Errorf("failed to list %s: %w", plural, err)
	}

	if len(list.Items) == 0 {
		fmt.Printf("No %s found\n", plural)
		return nil
	}

	fmt.Printf("%s %d %s...\n", action, len(list.Items), plural)

	successCount := 0
	for _, item := range list.Items {
		name := item.GetName()
		namespace := item.GetNamespace()

		// Set namespace for the client
		originalNS := k8sClient.GetNamespace()
		k8sClient.SetNamespace(namespace)

		// Check current paused state
		currentPaused, _, _ := unstructured.NestedBool(item.Object, "spec", "paused")
		if currentPaused == paused {
			k8sClient.SetNamespace(originalNS)
			continue
		}

		// Update the paused field using a merge patch
		patch := map[string]interface{}{
			"spec": map[string]interface{}{
				"paused": paused,
			},
		}

		if paused && pauseReason != "" {
			patch["metadata"] = map[string]interface{}{
				"annotations": map[string]interface{}{
					"petstore.example.com/paused-reason": pauseReason,
				},
			}
		}

		patchBytes, err := json.Marshal(patch)
		if err != nil {
			fmt.Printf("  %s Failed to marshal patch for %s/%s: %v\n", output.Red("✗"), namespace, name, err)
			k8sClient.SetNamespace(originalNS)
			continue
		}

		_, err = k8sClient.Patch(ctx, plural, name, "merge", patchBytes)
		if err != nil {
			fmt.Printf("  %s Failed to patch %s/%s: %v\n", output.Red("✗"), namespace, name, err)
			k8sClient.SetNamespace(originalNS)
			continue
		}

		successCount++
		if allNamespaces {
			fmt.Printf("  %s %s/%s\n", output.Green("✓"), namespace, name)
		} else {
			fmt.Printf("  %s %s\n", output.Green("✓"), name)
		}

		k8sClient.SetNamespace(originalNS)
	}

	actionPast := "Paused"
	if !paused {
		actionPast = "Unpaused"
	}
	fmt.Printf("\n%s %d/%d %s\n", actionPast, successCount, len(list.Items), plural)

	return nil
}
