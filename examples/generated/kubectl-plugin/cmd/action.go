// Generated by openapi-operator-gen v0.0.10-2-g1dff72e-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"encoding/base64"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	actionName       string
	actionWait       bool
	actionTimeout    time.Duration
	actionFile       string
	actionDryRun     bool
)

var actionCmd = &cobra.Command{
	Use:   "action ACTION-TYPE [flags]",
	Short: "Execute action CRDs for petstore",
	Long: `Execute action CRDs to perform operations on the petstore API.

Actions are write operations that modify state in the API endpoint.
They are typically one-shot operations that complete after execution.

Available action types:
  - petuploadimageaction (PetUploadimageAction)
  - usercreatewithlistaction (UserCreatewithlistAction)

Examples:
  # Execute an action
  kubectl petstore action petuploadimageaction --petId=123 --file=./photo.jpg

  # Execute action targeting specific pod
  kubectl petstore action usercreatewithlistaction --pod=0 --users='[{"username":"john"}]'

  # Execute and wait for result
  kubectl petstore action petuploadimageaction --petId=123 --wait

  # Dry run - show CR without creating
  kubectl petstore action petuploadimageaction --petId=123 --dry-run`,
	Args: cobra.MinimumNArgs(1),
	RunE: runAction,
}

func init() {
	addTargetingFlags(actionCmd)
	actionCmd.Flags().StringVar(&actionName, "name", "", "Name for the action CR")
	actionCmd.Flags().BoolVar(&actionWait, "wait", true, "Wait for action to complete and show results")
	actionCmd.Flags().DurationVar(&actionTimeout, "timeout", 60*time.Second, "Timeout for waiting on action results")
	actionCmd.Flags().StringVar(&actionFile, "file", "", "File to upload (for upload actions)")
	actionCmd.Flags().BoolVar(&actionDryRun, "dry-run", false, "Print the CR that would be created without creating it")

	// Allow unknown flags to pass through as action parameters (parsed from os.Args)
	actionCmd.FParseErrWhitelist.UnknownFlags = true
}

func runAction(cmd *cobra.Command, args []string) error {
	if err := validateTargetingFlags(); err != nil {
		return err
	}

	ctx := context.Background()
	actionType := strings.ToLower(args[0])

	// Resolve action type to kind
	actionKind := resolveActionKind(actionType)
	if actionKind == "" {
		return fmt.Errorf("unknown action type: %s\nRun 'kubectl petstore action --help' to see available types", actionType)
	}

	// Parse action parameters from command line
	params := parseActionParams()

	// Handle file upload if specified
	// File data goes into spec.data as base64, matching the CRD's binary data field
	if actionFile != "" {
		fileData, err := readFileForUpload(actionFile)
		if err != nil {
			return fmt.Errorf("failed to read file: %w", err)
		}
		params["data"] = fileData
	}

	// Generate a name if not provided
	name := actionName
	if name == "" {
		name = fmt.Sprintf("%s-%d", actionType, time.Now().Unix())
	}

	// Build the action CR
	actionCR := buildActionCR(actionKind, name, params)

	// Dry run - print CR and exit
	plural := resolveActionPlural(actionType)
	if actionDryRun {
		switch outputFormat {
		case "json":
			return output.PrintJSON(actionCR.Object)
		default:
			return output.PrintYAML(actionCR.Object)
		}
	}

	// Create the action CR
	fmt.Printf("Executing action: %s\n", actionKind)

	_, err := k8sClient.Create(ctx, plural, actionCR)
	if err != nil {
		return fmt.Errorf("failed to create action: %w", err)
	}

	fmt.Printf("Action created: %s/%s\n", plural, name)

	// Wait for results
	if actionWait {
		return waitForActionResult(ctx, plural, name)
	}

	fmt.Println("Action submitted. Use 'kubectl petstore describe' to check status.")
	return nil
}

func resolveActionKind(actionType string) string {
	actionType = strings.ToLower(actionType)
	actionKinds := map[string]string{
		"petuploadimageaction": "PetUploadimageAction",
		"petuploadimageactions": "PetUploadimageAction",
		"usercreatewithlistaction": "UserCreatewithlistAction",
		"usercreatewithlistactions": "UserCreatewithlistAction",
	}
	return actionKinds[actionType]
}

func resolveActionPlural(actionType string) string {
	actionType = strings.ToLower(actionType)
	actionPlurals := map[string]string{
		"petuploadimageaction": "petuploadimageactions",
		"petuploadimageactions": "petuploadimageactions",
		"usercreatewithlistaction": "usercreatewithlistactions",
		"usercreatewithlistactions": "usercreatewithlistactions",
	}
	return actionPlurals[actionType]
}

func parseActionParams() map[string]interface{} {
	params := make(map[string]interface{})

	// Parse --key=value and --key value style args from os.Args
	// This is needed because Cobra consumes unknown flags even with FParseErrWhitelist
	args := os.Args
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if !strings.HasPrefix(arg, "--") {
			continue
		}

		stripped := strings.TrimPrefix(arg, "--")

		// Handle --key=value syntax
		if strings.Contains(stripped, "=") {
			parts := strings.SplitN(stripped, "=", 2)
			if !isActionCommonFlag(parts[0]) {
				params[parts[0]] = coerceParamValue(parts[1])
			}
			continue
		}

		// Handle --key value syntax (space-separated)
		key := stripped
		if isActionCommonFlag(key) {
			continue
		}
		// Look ahead for the value (next arg that doesn't start with --)
		if i+1 < len(args) && !strings.HasPrefix(args[i+1], "--") {
			params[key] = coerceParamValue(args[i+1])
			i++ // skip the value arg
		}
	}

	return params
}

func isActionCommonFlag(name string) bool {
	if isTargetingFlag(name) {
		return true
	}
	commonFlags := map[string]bool{
		"name": true, "wait": true,
		"timeout": true, "output": true, "file": true,
		"dry-run": true,
		"namespace": true, "context": true, "kubeconfig": true,
	}
	return commonFlags[name]
}

// coerceParamValue attempts to convert string values to appropriate Go types
// so that the Kubernetes API server receives correctly typed values.
// For example, "10" becomes int64(10), "true" becomes bool(true).
func coerceParamValue(s string) interface{} {
	// Try integer
	if i, err := strconv.ParseInt(s, 10, 64); err == nil {
		return i
	}
	// Try float
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	// Try boolean
	if b, err := strconv.ParseBool(s); err == nil {
		return b
	}
	// Return as string
	return s
}

func readFileForUpload(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	// Return base64-encoded content
	return base64.StdEncoding.EncodeToString(data), nil
}

func buildActionCR(kind, name string, params map[string]interface{}) *unstructured.Unstructured {
	spec := make(map[string]interface{})

	// Add action parameters to spec
	for k, v := range params {
		spec[k] = v
	}

	// Add targeting if specified
	if target := buildTargetSpec(); target != nil {
		spec["target"] = target
	}

	// Mark as one-shot action
	annotations := map[string]interface{}{
		"petstore.example.com/one-shot":   "true",
		"petstore.example.com/created-by": "kubectl-plugin",
	}

	obj := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "petstore.example.com/v1alpha1",
			"kind":       kind,
			"metadata": map[string]interface{}{
				"name":        name,
				"namespace":   k8sClient.GetNamespace(),
				"annotations": annotations,
			},
			"spec": spec,
		},
	}

	return obj
}

func waitForActionResult(ctx context.Context, plural, name string) error {
	fmt.Printf("Waiting for action result (timeout: %s)...\n", actionTimeout)

	deadline := time.Now().Add(actionTimeout)
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	startTime := time.Now()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
			if time.Now().After(deadline) {
				return fmt.Errorf("timeout waiting for action result")
			}

			obj, err := k8sClient.Get(ctx, plural, name)
			if err != nil {
				continue
			}

			// Check if action has completed
			state, _, _ := unstructured.NestedString(obj.Object, "status", "state")
			if state == "Completed" || state == "Synced" {
				elapsed := time.Since(startTime)
				return printActionResult(obj, elapsed)
			}
			if state == "Failed" || state == "Error" {
				msg, _, _ := unstructured.NestedString(obj.Object, "status", "message")
				return fmt.Errorf("action failed: %s", msg)
			}
		}
	}
}

func printActionResult(obj *unstructured.Unstructured, elapsed time.Duration) error {
	fmt.Println()
	fmt.Println(output.Green("Action completed successfully"))

	// Get state
	state, _, _ := unstructured.NestedString(obj.Object, "status", "state")
	fmt.Printf("  State: %s\n", state)

	// Get response data
	response, found, _ := unstructured.NestedMap(obj.Object, "status", "response")
	if found {
		// Check status code
		if statusCode, ok := response["statusCode"].(int64); ok {
			fmt.Printf("  Status Code: %d\n", statusCode)
		}

		// Print response data
		data, hasData := response["data"]
		if hasData {
			fmt.Println("  Response:")
			switch outputFormat {
			case "json":
				return output.PrintJSON(data)
			case "yaml":
				return output.PrintYAML(data)
			default:
				printActionData(data, "    ")
			}
		}
	}

	if elapsed > 0 {
		fmt.Printf("\nExecution time: %s\n", elapsed.Round(time.Millisecond))
	}

	return nil
}

func printActionData(data interface{}, indent string) {
	switch v := data.(type) {
	case map[string]interface{}:
		for k, val := range v {
			fmt.Printf("%s%s: %v\n", indent, k, formatActionValue(val))
		}
	case []interface{}:
		for i, item := range v {
			fmt.Printf("%s[%d]: %v\n", indent, i, formatActionValue(item))
		}
	default:
		fmt.Printf("%s%v\n", indent, v)
	}
}

func formatActionValue(v interface{}) string {
	switch val := v.(type) {
	case string:
		if len(val) > 50 {
			return val[:47] + "..."
		}
		return val
	case map[string]interface{}:
		return "{...}"
	case []interface{}:
		return fmt.Sprintf("[%d items]", len(val))
	default:
		return fmt.Sprintf("%v", val)
	}
}

// listActionsCmd lists available action types
var listActionsCmd = &cobra.Command{
	Use:   "actions",
	Short: "List available action types",
	Long:  `List all available action types that can be executed.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		fmt.Println("Available action types:")
		fmt.Println()
		fmt.Printf("  %-30s %s\n", "petuploadimageaction", "PetUploadimageAction")
		fmt.Printf("  %-30s %s\n", "usercreatewithlistaction", "UserCreatewithlistAction")
		fmt.Println()
		fmt.Println("Use 'kubectl petstore action <type> --help' for more information")
		return nil
	},
}

func init() {
	// Add list subcommand
	actionCmd.AddCommand(listActionsCmd)
}
