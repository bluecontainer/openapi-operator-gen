// Generated by openapi-operator-gen v0.0.10-8-g5ef4f69-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	patchSpec    string
	patchTTL     string
	patchRestore bool
	patchDryRun  bool
)

const (
	// Annotations for TTL-based patches
	ttlAnnotation           = "petstore.example.com/patch-ttl"
	ttlExpiresAnnotation    = "petstore.example.com/patch-expires"
	originalStateAnnotation = "petstore.example.com/patch-original-state"
	patchedByAnnotation     = "petstore.example.com/patched-by"
)

var patchCmd = &cobra.Command{
	Use:   "patch KIND NAME",
	Short: "Make temporary changes to petstore resources with auto-rollback",
	Long: `Make temporary changes to resources with automatic rollback after TTL expires.

This command allows you to make temporary modifications to a resource's spec
while automatically preserving the original state for later restoration.

The original state is saved in an annotation and can be restored manually
using --restore or automatically when the TTL expires (requires operator support).

Available kinds:
  - order (Order)
  - pet (Pet)
  - user (User)

Spec changes can be provided as individual flags or as a JSON --spec value.
Nested objects use JSON syntax: --category='{"id":1,"name":"Dogs"}'
Arrays use comma-separated values: --tags=cute,fluffy

Examples:
  # Make temporary change with 1 hour TTL using individual flags
  kubectl petstore patch pet fluffy --status=pending --ttl=1h

  # Make temporary change with JSON spec
  kubectl petstore patch pet fluffy --spec='{"status":"pending"}' --ttl=1h

  # Preview change without applying
  kubectl petstore patch pet fluffy --status=pending --dry-run

  # Restore original state immediately
  kubectl petstore patch pet fluffy --restore

  # Change multiple fields
  kubectl petstore patch pet fluffy --status=pending --tags=cute,fluffy

  # Make change without TTL (manual restore required)
  kubectl petstore patch pet fluffy --name="Fluffy Updated"`,
	Args: cobra.ExactArgs(2),
	RunE: runPatch,
}

func init() {
	addTargetingFlags(patchCmd)
	patchCmd.Flags().StringVar(&patchSpec, "spec", "", "JSON spec to apply (e.g., '{\"status\":\"pending\"}')")
	patchCmd.Flags().StringVar(&patchTTL, "ttl", "", "Time-to-live for the patch (e.g., 1h, 30m)")
	patchCmd.Flags().BoolVar(&patchRestore, "restore", false, "Restore the original state")
	patchCmd.Flags().BoolVar(&patchDryRun, "dry-run", false, "Preview the change without applying")

	// Allow unknown flags to pass through as patch parameters (parsed from os.Args)
	patchCmd.FParseErrWhitelist.UnknownFlags = true
}

func runPatch(cmd *cobra.Command, args []string) error {
	if err := validateTargetingFlags(); err != nil {
		return err
	}

	ctx := context.Background()
	kindArg := strings.ToLower(args[0])
	name := args[1]

	// Resolve kind to plural form
	plural := resolveKindPlural(kindArg)
	if plural == "" {
		return fmt.Errorf("unknown resource kind: %s", kindArg)
	}

	// Get the current resource
	obj, err := k8sClient.Get(ctx, plural, name)
	if err != nil {
		return fmt.Errorf("failed to get %s/%s: %w", kindArg, name, err)
	}

	if patchRestore {
		return restoreOriginalState(ctx, plural, name, obj)
	}

	// Build spec patch from --spec JSON and/or individual flags
	specPatch, err := buildPatchSpec()
	if err != nil {
		return err
	}

	if len(specPatch) == 0 {
		return fmt.Errorf("no spec changes provided\nUse --key=value flags or --spec='{...}' (use --restore to restore original state)")
	}

	return applyPatch(ctx, plural, name, obj, specPatch)
}

// buildPatchSpec merges --spec JSON with individual --key=value flags.
// Individual flags take precedence over --spec values for the same key.
func buildPatchSpec() (map[string]interface{}, error) {
	specPatch := make(map[string]interface{})

	// Start with --spec JSON if provided
	if patchSpec != "" {
		if err := json.Unmarshal([]byte(patchSpec), &specPatch); err != nil {
			return nil, fmt.Errorf("invalid spec JSON: %w", err)
		}
	}

	// Merge individual flags (override --spec values)
	flagParams := parsePatchParams()
	for k, v := range flagParams {
		specPatch[k] = v
	}

	return specPatch, nil
}

func applyPatch(ctx context.Context, plural, name string, obj *unstructured.Unstructured, specPatch map[string]interface{}) error {
	// Add targeting if specified
	if target := buildTargetSpec(); target != nil {
		specPatch["target"] = target
	}

	// Get current spec
	currentSpec, _, _ := unstructured.NestedMap(obj.Object, "spec")
	if currentSpec == nil {
		currentSpec = make(map[string]interface{})
	}

	// Preview mode
	if patchDryRun {
		return previewPatch(obj, specPatch)
	}

	// Save original state if not already saved
	annotations := obj.GetAnnotations()
	if annotations == nil {
		annotations = make(map[string]string)
	}

	if _, exists := annotations[originalStateAnnotation]; !exists {
		// Save the fields we're about to modify
		originalFields := make(map[string]interface{})
		for key := range specPatch {
			if val, exists := currentSpec[key]; exists {
				originalFields[key] = val
			} else {
				originalFields[key] = nil // Mark as didn't exist
			}
		}

		originalJSON, err := json.Marshal(originalFields)
		if err != nil {
			return fmt.Errorf("failed to save original state: %w", err)
		}
		annotations[originalStateAnnotation] = string(originalJSON)
	}

	// Set patched-by annotation
	annotations[patchedByAnnotation] = "kubectl-plugin"

	// Set TTL if specified
	var expiresAt time.Time
	if patchTTL != "" {
		duration, err := time.ParseDuration(patchTTL)
		if err != nil {
			return fmt.Errorf("invalid TTL duration: %w", err)
		}
		expiresAt = time.Now().Add(duration)
		annotations[ttlAnnotation] = patchTTL
		annotations[ttlExpiresAnnotation] = expiresAt.Format(time.RFC3339)
	}

	// Build the patch
	patch := map[string]interface{}{
		"metadata": map[string]interface{}{
			"annotations": annotations,
		},
		"spec": specPatch,
	}

	patchBytes, err := json.Marshal(patch)
	if err != nil {
		return fmt.Errorf("failed to marshal patch: %w", err)
	}

	fmt.Printf("Patching %s/%s...\n\n", plural, name)

	// Apply the patch
	_, err = k8sClient.Patch(ctx, plural, name, "merge", patchBytes)
	if err != nil {
		errMsg := err.Error()
		// Detect type mismatch errors from CRD validation and provide helpful hints
		if strings.Contains(errMsg, "must be of type object") ||
			strings.Contains(errMsg, "must be of type array") ||
			strings.Contains(errMsg, "Invalid value") {
			// Identify which fields may need JSON syntax
			var hints []string
			for key, val := range specPatch {
				switch val.(type) {
				case []interface{}:
					hints = append(hints, fmt.Sprintf("  --%s may need JSON array of objects: --%s='[{\"id\":1,\"name\":\"value\"}]'", key, key))
				case string:
					hints = append(hints, fmt.Sprintf("  --%s may need JSON object syntax: --%s='{\"key\":\"value\"}'", key, key))
				}
			}
			if len(hints) > 0 {
				return fmt.Errorf("patch validation failed: %w\n\nHint: Some fields may require JSON syntax for complex types:\n%s", err, strings.Join(hints, "\n"))
			}
		}
		return fmt.Errorf("failed to apply patch: %w", err)
	}

	fmt.Println(output.Green("Patch applied successfully"))

	// Show what changed
	fmt.Println("\nChanges applied:")
	for key, newVal := range specPatch {
		oldVal := currentSpec[key]
		fmt.Printf("  %s: %v → %v\n", key, formatPatchValue(oldVal), formatPatchValue(newVal))
	}

	if !expiresAt.IsZero() {
		fmt.Printf("\nTTL expires: %s\n", expiresAt.Format(time.RFC3339))
	}

	fmt.Printf("\nTo restore immediately: kubectl petstore patch %s %s --restore\n", strings.ToLower(obj.GetKind()), name)

	return nil
}

func parsePatchParams() map[string]interface{} {
	params := make(map[string]interface{})

	// Parse --key=value and --key value style args from os.Args
	args := os.Args
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if !strings.HasPrefix(arg, "--") {
			continue
		}

		stripped := strings.TrimPrefix(arg, "--")

		// Handle --key=value syntax
		if strings.Contains(stripped, "=") {
			parts := strings.SplitN(stripped, "=", 2)
			if !isPatchCommonFlag(parts[0]) {
				params[parts[0]] = coercePatchParamValue(parts[1])
			}
			continue
		}

		// Handle --key value syntax (space-separated)
		key := stripped
		if isPatchCommonFlag(key) {
			continue
		}
		// Look ahead for the value (next arg that doesn't start with --)
		if i+1 < len(args) && !strings.HasPrefix(args[i+1], "--") {
			params[key] = coercePatchParamValue(args[i+1])
			i++ // skip the value arg
		}
	}

	return params
}

// coercePatchParamValue attempts to convert string values to appropriate Go types.
// It tries JSON objects/arrays first, then integer, float, boolean, and falls back to string.
func coercePatchParamValue(s string) interface{} {
	// Try JSON object or array
	if (strings.HasPrefix(s, "{") && strings.HasSuffix(s, "}")) ||
		(strings.HasPrefix(s, "[") && strings.HasSuffix(s, "]")) {
		var jsonVal interface{}
		if err := json.Unmarshal([]byte(s), &jsonVal); err == nil {
			return jsonVal
		}
	}
	// Try comma-separated array (only if contains comma and not JSON)
	if strings.Contains(s, ",") && !strings.HasPrefix(s, "{") && !strings.HasPrefix(s, "[") {
		parts := strings.Split(s, ",")
		result := make([]interface{}, len(parts))
		for i, p := range parts {
			result[i] = strings.TrimSpace(p)
		}
		return result
	}
	// Try integer
	if i, err := strconv.ParseInt(s, 10, 64); err == nil {
		return i
	}
	// Try float
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	// Try boolean
	if b, err := strconv.ParseBool(s); err == nil {
		return b
	}
	// Return as string
	return s
}

func isPatchCommonFlag(name string) bool {
	if isTargetingFlag(name) {
		return true
	}
	commonFlags := map[string]bool{
		"spec": true, "ttl": true, "restore": true, "dry-run": true,
		"output": true,
		"namespace": true, "context": true, "kubeconfig": true,
	}
	return commonFlags[name]
}

func restoreOriginalState(ctx context.Context, plural, name string, obj *unstructured.Unstructured) error {
	annotations := obj.GetAnnotations()
	if annotations == nil {
		return fmt.Errorf("no patch to restore (resource was not patched)")
	}

	originalJSON, exists := annotations[originalStateAnnotation]
	if !exists {
		return fmt.Errorf("no original state found (resource was not patched)")
	}

	// Parse original state
	var originalFields map[string]interface{}
	if err := json.Unmarshal([]byte(originalJSON), &originalFields); err != nil {
		return fmt.Errorf("failed to parse original state: %w", err)
	}

	// Get current spec for comparison
	currentSpec, _, _ := unstructured.NestedMap(obj.Object, "spec")
	if currentSpec == nil {
		currentSpec = make(map[string]interface{})
	}

	// Build spec patch to restore original values
	specPatch := make(map[string]interface{})
	for key, originalVal := range originalFields {
		if originalVal == nil {
			// Field didn't exist originally - we can't easily remove it with merge patch
			// so we'll skip it (or could set to nil if the schema allows)
			continue
		}
		specPatch[key] = originalVal
	}

	// Remove patch-related annotations
	delete(annotations, originalStateAnnotation)
	delete(annotations, ttlAnnotation)
	delete(annotations, ttlExpiresAnnotation)
	delete(annotations, patchedByAnnotation)

	// Build the restore patch
	patch := map[string]interface{}{
		"metadata": map[string]interface{}{
			"annotations": annotations,
		},
		"spec": specPatch,
	}

	patchBytes, err := json.Marshal(patch)
	if err != nil {
		return fmt.Errorf("failed to marshal restore patch: %w", err)
	}

	fmt.Printf("Restoring %s/%s to original state...\n\n", plural, name)

	// Apply the restore patch
	_, err = k8sClient.Patch(ctx, plural, name, "merge", patchBytes)
	if err != nil {
		return fmt.Errorf("failed to restore: %w", err)
	}

	fmt.Println(output.Green("Original state restored successfully"))

	// Show what was restored
	fmt.Println("\nRestored values:")
	for key, originalVal := range originalFields {
		currentVal := currentSpec[key]
		if originalVal == nil {
			fmt.Printf("  %s: %v → (removed)\n", key, formatPatchValue(currentVal))
		} else {
			fmt.Printf("  %s: %v → %v\n", key, formatPatchValue(currentVal), formatPatchValue(originalVal))
		}
	}

	return nil
}

func previewPatch(obj *unstructured.Unstructured, specPatch map[string]interface{}) error {
	// Output the merge patch payload that would be sent to the API server.
	// This matches exactly what applyPatch submits.
	patch := map[string]interface{}{
		"spec": specPatch,
	}

	switch outputFormat {
	case "json":
		return output.PrintJSON(patch)
	default:
		return output.PrintYAML(patch)
	}
}

func formatPatchValue(v interface{}) string {
	if v == nil {
		return "<nil>"
	}
	switch val := v.(type) {
	case string:
		if len(val) > 30 {
			return fmt.Sprintf("\"%s...\"", val[:27])
		}
		return fmt.Sprintf("\"%s\"", val)
	case map[string]interface{}:
		return "{...}"
	case []interface{}:
		return fmt.Sprintf("[%d items]", len(val))
	default:
		return fmt.Sprintf("%v", val)
	}
}

// listPatchedCmd lists resources with active patches
var listPatchedCmd = &cobra.Command{
	Use:   "list",
	Short: "List resources with active patches",
	Long:  `List all resources that have been patched and can be restored.`,
	RunE:  runListPatched,
}

func init() {
	patchCmd.AddCommand(listPatchedCmd)
}

func runListPatched(cmd *cobra.Command, args []string) error {
	ctx := context.Background()

	fmt.Println("PATCHED RESOURCES (namespace: " + k8sClient.GetNamespace() + ")\n")

	headers := []string{"KIND", "NAME", "PATCHED FIELDS", "TTL", "EXPIRES"}
	var rows [][]string

	// Check all resource kinds
	allKinds := []struct {
		kind   string
		plural string
	}{
		{"Order", "orders"},
		{"Pet", "pets"},
		{"User", "users"},
	}

	for _, k := range allKinds {
		list, err := k8sClient.List(ctx, k.plural)
		if err != nil {
			continue
		}

		for _, item := range list.Items {
			annotations := item.GetAnnotations()
			if annotations == nil {
				continue
			}

			originalJSON, hasOriginal := annotations[originalStateAnnotation]
			if !hasOriginal {
				continue
			}

			// Parse original to get field names
			var originalFields map[string]interface{}
			json.Unmarshal([]byte(originalJSON), &originalFields)

			fields := make([]string, 0, len(originalFields))
			for field := range originalFields {
				fields = append(fields, field)
			}

			ttl := annotations[ttlAnnotation]
			if ttl == "" {
				ttl = "-"
			}

			expires := annotations[ttlExpiresAnnotation]
			if expires == "" {
				expires = "-"
			} else {
				// Check if expired
				expiresTime, err := time.Parse(time.RFC3339, expires)
				if err == nil && time.Now().After(expiresTime) {
					expires = output.Red("EXPIRED")
				}
			}

			rows = append(rows, []string{
				k.kind,
				item.GetName(),
				strings.Join(fields, ", "),
				ttl,
				expires,
			})
		}
	}

	if len(rows) == 0 {
		fmt.Println("No patched resources found")
		return nil
	}

	output.PrintTable(headers, rows)
	fmt.Printf("\nTotal: %d patched resources\n", len(rows))

	return nil
}
