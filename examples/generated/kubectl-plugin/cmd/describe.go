// Generated by openapi-operator-gen v0.0.10-10-ge5a6a04-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"strings"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"sigs.k8s.io/yaml"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var describeCmd = &cobra.Command{
	Use:   "describe KIND NAME",
	Short: "Show detailed information about a petstore resource",
	Long: `Display detailed information about a specific resource including:
  - Resource metadata (name, namespace, labels)
  - Spec fields
  - Status including sync state, external ID, and response data
  - Conditions
  - Recent events

Available kinds:
  - order (Order)
  - pet (Pet)
  - user (User)
  - petfindbystatusquery (PetFindbystatusQuery)
  - petfindbytagsquery (PetFindbytagsQuery)
  - storeinventoryquery (StoreInventoryQuery)
  - userloginquery (UserLoginQuery)
  - userlogoutquery (UserLogoutQuery)
  - petuploadimageaction (PetUploadimageAction)
  - usercreatewithlistaction (UserCreatewithlistAction)
  - petstoreaggregate (PetstoreAggregate)
  - petstorebundle (PetstoreBundle)

Examples:
  # Describe a pet
  kubectl petstore describe pet fluffy

  # Describe with JSON output
  kubectl petstore describe pet fluffy -o json

  # Describe an order
  kubectl petstore describe order order-123`,
	Args: cobra.ExactArgs(2),
	RunE: runDescribe,
}

func runDescribe(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	kindArg := strings.ToLower(args[0])
	name := args[1]

	// Resolve kind to plural form
	plural := resolveKindPlural(kindArg)
	if plural == "" {
		return fmt.Errorf("unknown resource kind: %s", kindArg)
	}

	// Get the resource
	obj, err := k8sClient.Get(ctx, plural, name)
	if err != nil {
		return fmt.Errorf("failed to get %s/%s: %w", kindArg, name, err)
	}

	return printResourceDetail(obj)
}

func printResourceDetail(obj *unstructured.Unstructured) error {
	switch outputFormat {
	case "json":
		return output.PrintJSON(obj.Object)
	case "yaml":
		return output.PrintYAML(obj.Object)
	default:
		return printResourceDetailFormatted(obj)
	}
}

func printResourceDetailFormatted(obj *unstructured.Unstructured) error {
	// Print header
	fmt.Printf("Name:         %s\n", obj.GetName())
	fmt.Printf("Namespace:    %s\n", obj.GetNamespace())
	fmt.Printf("Kind:         %s\n", obj.GetKind())

	// Print labels
	labels := obj.GetLabels()
	if len(labels) > 0 {
		fmt.Println("Labels:")
		for k, v := range labels {
			fmt.Printf("              %s=%s\n", k, v)
		}
	}

	// Print annotations (selected)
	annotations := obj.GetAnnotations()
	if len(annotations) > 0 {
		fmt.Println("Annotations:")
		for k, v := range annotations {
			// Skip internal annotations
			if strings.HasPrefix(k, "kubectl.kubernetes.io/") {
				continue
			}
			// Truncate long values
			if len(v) > 50 {
				v = v[:47] + "..."
			}
			fmt.Printf("              %s=%s\n", k, v)
		}
	}

	// Extract status
	status, statusFound, _ := unstructured.NestedMap(obj.Object, "status")

	// Print state summary
	if statusFound {
		fmt.Println()
		state, _ := status["state"].(string)
		if state == "" {
			state = "Pending"
		}
		fmt.Printf("State:        %s\n", colorizeState(state))

		// External ID
		if externalID, ok := status["externalID"]; ok {
			fmt.Printf("External ID:  %v\n", externalID)
		}

		// Drift detection
		if drift, ok := status["driftDetected"].(bool); ok {
			driftStr := "No"
			if drift {
				driftStr = output.Yellow("Yes")
			}
			fmt.Printf("Drift:        %s\n", driftStr)
		}
	}

	// Print spec
	spec, specFound, _ := unstructured.NestedMap(obj.Object, "spec")
	if specFound && len(spec) > 0 {
		fmt.Println()
		fmt.Println("Spec:")
		printNestedMap(spec, "  ")
	}

	// Print detailed status
	if statusFound {
		fmt.Println()
		fmt.Println("Status:")

		// Last sync time
		if lastSync, ok := status["lastSyncTime"].(string); ok && lastSync != "" {
			fmt.Printf("  Last Sync Time:     %s\n", lastSync)
		}

		// Last get time
		if lastGet, ok := status["lastGetTime"].(string); ok && lastGet != "" {
			fmt.Printf("  Last Get Time:      %s\n", lastGet)
		}

		// Sync count
		if syncCount, ok := status["syncCount"].(int64); ok {
			fmt.Printf("  Sync Count:         %d\n", syncCount)
		}

		// Multi-endpoint responses (when using fan-out mode)
		if responses, ok := status["responses"].(map[string]interface{}); ok && len(responses) > 0 {
			fmt.Println()
			fmt.Printf("  Endpoint Responses: (%d endpoints)\n", len(responses))

			for endpoint, respRaw := range responses {
				resp, ok := respRaw.(map[string]interface{})
				if !ok {
					continue
				}

				// Get shortened endpoint name for display
				shortName := shortenEndpointName(endpoint)

				success, _ := resp["success"].(bool)
				statusCode, _ := resp["statusCode"].(int64)
				errMsg, _ := resp["error"].(string)

				fmt.Println()
				fmt.Printf("    [%s] %s\n", shortName, endpoint)

				if success {
					fmt.Printf("      Status: %s (HTTP %d)\n", output.Green("Success"), statusCode)
					if data, ok := resp["data"]; ok {
						fmt.Println("      Data:")
						printNestedValue(data, "        ")
					}
				} else {
					fmt.Printf("      Status: %s\n", output.Red("Failed"))
					if errMsg != "" {
						fmt.Printf("      Error: %s\n", errMsg)
					}
				}
			}
		} else if response, ok := status["response"].(map[string]interface{}); ok {
			// Single endpoint response
			fmt.Println()
			fmt.Println("  Response:")

			// Status code
			if statusCode, ok := response["statusCode"].(int64); ok {
				fmt.Printf("    Status Code: %d\n", statusCode)
			}

			// Response data
			if data, ok := response["data"]; ok {
				fmt.Println("    Data:")
				printNestedValue(data, "      ")
			}
		}

		// Observed response (for resources)
		if observed, ok := status["observedResponse"].(map[string]interface{}); ok {
			fmt.Println()
			fmt.Println("  Observed Response:")
			printNestedMap(observed, "    ")
		}
	}

	// Print conditions
	conditions, condFound, _ := unstructured.NestedSlice(obj.Object, "status", "conditions")
	if condFound && len(conditions) > 0 {
		fmt.Println()
		fmt.Println("Conditions:")
		fmt.Println("  TYPE                 STATUS  REASON          MESSAGE                    LAST TRANSITION")
		for _, c := range conditions {
			cond, ok := c.(map[string]interface{})
			if !ok {
				continue
			}
			condType, _ := cond["type"].(string)
			condStatus, _ := cond["status"].(string)
			reason, _ := cond["reason"].(string)
			message, _ := cond["message"].(string)
			lastTransition, _ := cond["lastTransitionTime"].(string)

			// Truncate long messages
			if len(message) > 26 {
				message = message[:23] + "..."
			}

			// Colorize status
			statusStr := condStatus
			if condStatus == "True" {
				statusStr = output.Green(condStatus)
			} else if condStatus == "False" {
				statusStr = output.Red(condStatus)
			}

			fmt.Printf("  %-20s %-7s %-15s %-26s %s\n",
				condType, statusStr, reason, message, lastTransition)
		}
	}

	// Print resource status (for aggregates/bundles)
	resourceStatuses, rsFound, _ := unstructured.NestedSlice(obj.Object, "status", "resourceStatuses")
	if rsFound && len(resourceStatuses) > 0 {
		fmt.Println()
		fmt.Println("Resource Statuses:")
		fmt.Println("  KIND                 NAME                  STATE       EXTERNAL-ID")
		for _, rs := range resourceStatuses {
			rsMap, ok := rs.(map[string]interface{})
			if !ok {
				continue
			}
			kind, _ := rsMap["kind"].(string)
			name, _ := rsMap["name"].(string)
			state, _ := rsMap["state"].(string)
			externalID, _ := rsMap["externalID"]

			externalIDStr := fmt.Sprintf("%v", externalID)
			if externalIDStr == "<nil>" {
				externalIDStr = "-"
			}

			fmt.Printf("  %-20s %-21s %-11s %s\n",
				kind, name, colorizeState(state), externalIDStr)
		}
	}

	return nil
}

func printNestedMap(m map[string]interface{}, indent string) {
	for k, v := range m {
		printKeyValue(k, v, indent)
	}
}

func printKeyValue(key string, value interface{}, indent string) {
	switch v := value.(type) {
	case map[string]interface{}:
		fmt.Printf("%s%s:\n", indent, key)
		printNestedMap(v, indent+"  ")
	case []interface{}:
		if len(v) == 0 {
			fmt.Printf("%s%s: []\n", indent, key)
		} else if isSimpleArray(v) {
			fmt.Printf("%s%s: %v\n", indent, key, v)
		} else {
			fmt.Printf("%s%s:\n", indent, key)
			for _, item := range v {
				printNestedValue(item, indent+"  - ")
			}
		}
	default:
		fmt.Printf("%s%s: %v\n", indent, key, v)
	}
}

func printNestedValue(value interface{}, indent string) {
	switch v := value.(type) {
	case map[string]interface{}:
		// For maps in arrays, print as YAML-like
		yamlBytes, err := yaml.Marshal(v)
		if err != nil {
			fmt.Printf("%s%v\n", indent, v)
			return
		}
		lines := strings.Split(strings.TrimSpace(string(yamlBytes)), "\n")
		for i, line := range lines {
			if i == 0 {
				fmt.Printf("%s%s\n", indent, line)
			} else {
				// Align subsequent lines
				fmt.Printf("%s%s\n", strings.Repeat(" ", len(indent)), line)
			}
		}
	case []interface{}:
		for _, item := range v {
			printNestedValue(item, indent)
		}
	default:
		fmt.Printf("%s%v\n", indent, v)
	}
}

func isSimpleArray(arr []interface{}) bool {
	for _, item := range arr {
		switch item.(type) {
		case map[string]interface{}, []interface{}:
			return false
		}
	}
	return true
}

// shortenEndpointName creates a short display name for an endpoint URL
func shortenEndpointName(endpoint string) string {
	// Try to extract pod name from URL like http://petstore-0.petstore:8080
	// or http://10.0.0.1:8080
	endpoint = strings.TrimPrefix(endpoint, "http://")
	endpoint = strings.TrimPrefix(endpoint, "https://")

	// Remove path
	if idx := strings.Index(endpoint, "/"); idx != -1 {
		endpoint = endpoint[:idx]
	}

	// Remove port
	if idx := strings.LastIndex(endpoint, ":"); idx != -1 {
		endpoint = endpoint[:idx]
	}

	// If it looks like a pod DNS name (contains dots), take first part
	if parts := strings.Split(endpoint, "."); len(parts) > 1 {
		return parts[0]
	}

	// Truncate long names
	if len(endpoint) > 15 {
		return endpoint[:12] + "..."
	}

	return endpoint
}
