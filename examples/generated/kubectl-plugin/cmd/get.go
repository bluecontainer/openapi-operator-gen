// Generated by openapi-operator-gen v0.0.10-27-g49a94a0-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	getState     string
	getDrift     bool
	getLabelSel  string
	getAllNS     bool
)

var getCmd = &cobra.Command{
	Use:   "get KIND",
	Short: "List petstore resources",
	Long: `List resources of a specific kind with their sync state.

Available kinds:
  - orders (Order)
  - pets (Pet)
  - users (User)
  - petfindbystatusqueries (PetFindbystatusQuery)
  - petfindbytagsqueries (PetFindbytagsQuery)
  - storeinventoryqueries (StoreInventoryQuery)
  - userloginqueries (UserLoginQuery)
  - userlogoutqueries (UserLogoutQuery)
  - petuploadimageactions (PetUploadimageAction)
  - usercreatewithlistactions (UserCreatewithlistAction)
  - petstoreaggregates (PetstoreAggregate)
  - petstorebundles (PetstoreBundle)

Examples:
  # List all pets
  kubectl petstore get pets

  # List with wide output
  kubectl petstore get pets -o wide

  # Filter by state
  kubectl petstore get pets --state=Failed

  # Show only resources with drift
  kubectl petstore get pets --drift

  # Filter by labels
  kubectl petstore get pets -l environment=production`,
	Args: cobra.ExactArgs(1),
	RunE: runGet,
}

func init() {
	getCmd.Flags().StringVar(&getState, "state", "", "Filter by state (Synced, Failed, Pending)")
	getCmd.Flags().BoolVar(&getDrift, "drift", false, "Show only resources with drift detected")
	getCmd.Flags().StringVarP(&getLabelSel, "selector", "l", "", "Label selector (e.g., environment=production)")
	getCmd.Flags().BoolVarP(&getAllNS, "all-namespaces", "A", false, "List resources across all namespaces")
}

// ResourceInfo holds information about a resource for display
type ResourceInfo struct {
	Name       string
	Namespace  string
	Kind       string
	State      string
	ExternalID string
	Drift      bool
	LastSync   string
	TargetPod  string
	Age        string
	Labels     map[string]string
}

func runGet(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	kindArg := strings.ToLower(args[0])

	// Resolve kind to plural form
	plural := resolveKindPlural(kindArg)
	if plural == "" {
		return fmt.Errorf("unknown resource kind: %s", kindArg)
	}

	// List resources
	var list *unstructured.UnstructuredList
	var err error

	if getAllNS {
		list, err = k8sClient.ListAllNamespaces(ctx, plural, getLabelSel)
	} else {
		list, err = k8sClient.ListWithSelector(ctx, plural, getLabelSel)
	}
	if err != nil {
		return fmt.Errorf("failed to list %s: %w", plural, err)
	}

	// Convert to ResourceInfo
	resources := make([]ResourceInfo, 0, len(list.Items))
	for _, item := range list.Items {
		info := extractResourceInfo(&item)

		// Apply filters
		if getState != "" && !strings.EqualFold(info.State, getState) {
			continue
		}
		if getDrift && !info.Drift {
			continue
		}

		resources = append(resources, info)
	}

	return printResources(resources)
}

func resolveKindPlural(kind string) string {
	// Map singular to plural and normalize
	kindMap := map[string]string{
		"order":  "orders",
		"orders":     "orders",
		"pet":  "pets",
		"pets":     "pets",
		"user":  "users",
		"users":     "users",
		"petfindbystatusquery":  "petfindbystatusqueries",
		"petfindbystatusqueries":     "petfindbystatusqueries",
		"petfindbytagsquery":  "petfindbytagsqueries",
		"petfindbytagsqueries":     "petfindbytagsqueries",
		"storeinventoryquery":  "storeinventoryqueries",
		"storeinventoryqueries":     "storeinventoryqueries",
		"userloginquery":  "userloginqueries",
		"userloginqueries":     "userloginqueries",
		"userlogoutquery":  "userlogoutqueries",
		"userlogoutqueries":     "userlogoutqueries",
		"petuploadimageaction":  "petuploadimageactions",
		"petuploadimageactions":     "petuploadimageactions",
		"usercreatewithlistaction":  "usercreatewithlistactions",
		"usercreatewithlistactions":     "usercreatewithlistactions",
		"petstoreaggregate":   "petstoreaggregates",
		"petstoreaggregates":  "petstoreaggregates",
		"petstorebundle":   "petstorebundles",
		"petstorebundles":  "petstorebundles",
	}

	return kindMap[strings.ToLower(kind)]
}

func extractResourceInfo(obj *unstructured.Unstructured) ResourceInfo {
	info := ResourceInfo{
		Name:      obj.GetName(),
		Namespace: obj.GetNamespace(),
		Kind:      obj.GetKind(),
		Labels:    obj.GetLabels(),
	}

	// Extract state
	info.State, _, _ = unstructured.NestedString(obj.Object, "status", "state")
	if info.State == "" {
		info.State = "Pending"
	}

	// Extract external ID
	info.ExternalID, _, _ = unstructured.NestedString(obj.Object, "status", "externalID")
	if info.ExternalID == "" {
		// Try as number
		if id, found, _ := unstructured.NestedInt64(obj.Object, "status", "externalID"); found {
			info.ExternalID = fmt.Sprintf("%d", id)
		} else {
			info.ExternalID = "-"
		}
	}

	// Extract drift status
	info.Drift, _, _ = unstructured.NestedBool(obj.Object, "status", "driftDetected")

	// Extract last sync time
	if lastSync, found, _ := unstructured.NestedString(obj.Object, "status", "lastSyncTime"); found {
		info.LastSync = lastSync
	} else {
		info.LastSync = "-"
	}

	// Extract target pod (from spec)
	if ordinal, found, _ := unstructured.NestedInt64(obj.Object, "spec", "targetPodOrdinal"); found {
		info.TargetPod = fmt.Sprintf("pod-%d", ordinal)
	} else if helmRelease, found, _ := unstructured.NestedString(obj.Object, "spec", "targetHelmRelease"); found {
		info.TargetPod = helmRelease
	} else {
		info.TargetPod = "-"
	}

	// Calculate age
	creationTime := obj.GetCreationTimestamp()
	if !creationTime.IsZero() {
		info.Age = formatAge(time.Since(creationTime.Time))
	} else {
		info.Age = "-"
	}

	return info
}

func formatAge(d time.Duration) string {
	if d < time.Minute {
		return fmt.Sprintf("%ds", int(d.Seconds()))
	}
	if d < time.Hour {
		return fmt.Sprintf("%dm", int(d.Minutes()))
	}
	if d < 24*time.Hour {
		return fmt.Sprintf("%dh", int(d.Hours()))
	}
	return fmt.Sprintf("%dd", int(d.Hours()/24))
}

func printResources(resources []ResourceInfo) error {
	if len(resources) == 0 {
		fmt.Println("No resources found")
		return nil
	}

	switch outputFormat {
	case "json":
		return output.PrintJSON(resources)
	case "yaml":
		return output.PrintYAML(resources)
	case "wide":
		return printResourcesWide(resources)
	default:
		return printResourcesTable(resources)
	}
}

func printResourcesTable(resources []ResourceInfo) error {
	headers := []string{"NAME", "STATE", "EXTERNAL-ID", "DRIFT", "AGE"}
	if getAllNS {
		headers = append([]string{"NAMESPACE"}, headers...)
	}

	rows := make([][]string, 0, len(resources))
	for _, r := range resources {
		drift := "No"
		if r.Drift {
			drift = output.Yellow("Yes")
		}

		state := colorizeState(r.State)

		row := []string{r.Name, state, r.ExternalID, drift, r.Age}
		if getAllNS {
			row = append([]string{r.Namespace}, row...)
		}
		rows = append(rows, row)
	}

	output.PrintTable(headers, rows)
	return nil
}

func printResourcesWide(resources []ResourceInfo) error {
	headers := []string{"NAME", "STATE", "EXTERNAL-ID", "DRIFT", "LAST-SYNC", "TARGET-POD", "AGE"}
	if getAllNS {
		headers = append([]string{"NAMESPACE"}, headers...)
	}

	rows := make([][]string, 0, len(resources))
	for _, r := range resources {
		drift := "No"
		if r.Drift {
			drift = output.Yellow("Yes")
		}

		state := colorizeState(r.State)

		row := []string{r.Name, state, r.ExternalID, drift, r.LastSync, r.TargetPod, r.Age}
		if getAllNS {
			row = append([]string{r.Namespace}, row...)
		}
		rows = append(rows, row)
	}

	output.PrintTable(headers, rows)
	return nil
}

func colorizeState(state string) string {
	switch state {
	case "Synced":
		return output.Green(state)
	case "Failed", "Error":
		return output.Red(state)
	case "Pending", "Progressing":
		return output.Yellow(state)
	default:
		return state
	}
}
