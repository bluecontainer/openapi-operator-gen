// Generated by openapi-operator-gen v0.0.10-6-gad62e9c-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/spf13/cobra"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"sigs.k8s.io/yaml"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	createCRName   string
	createNoWait   bool
	createTimeout  time.Duration
	createFromFile string
	createDryRun   bool
)

var createCmd = &cobra.Command{
	Use:   "create RESOURCE-TYPE [flags]",
	Short: "Create CRUD resource CRs for petstore",
	Long: `Create resource CRs by specifying spec fields as CLI flags.

Resources are CRUD-managed objects that are synced with the petstore API.
The controller will POST to create the resource and continuously reconcile it.

Available resource types:
  - order (Order)
  - pet (Pet)
  - user (User)

Spec fields are passed as flags (--key=value or --key value).
Nested objects use JSON syntax: --category='{"id":1,"name":"Dogs"}'
Arrays use comma-separated values: --tags=cute,fluffy

Examples:
  # Create a resource with spec fields as flags
  kubectl petstore create pet --name=fluffy --status=available

  # Create with a custom CR name
  kubectl petstore create pet --cr-name=my-pet --name=fluffy

  # Create without waiting for sync
  kubectl petstore create pet --name=fluffy --no-wait

  # Create from a YAML/JSON spec file
  kubectl petstore create pet --from-file=pet-spec.yaml

  # Dry run - show CR without creating
  kubectl petstore create pet --name=fluffy --dry-run

  # Output result as JSON
  kubectl petstore create pet --name=fluffy --output=json`,
	Args: cobra.MinimumNArgs(1),
	RunE: runCreate,
}

func init() {
	addTargetingFlags(createCmd)
	createCmd.Flags().StringVar(&createCRName, "cr-name", "", "Name for the CR (auto-generated if not specified)")
	createCmd.Flags().BoolVar(&createNoWait, "no-wait", false, "Don't wait for the resource to sync")
	createCmd.Flags().DurationVar(&createTimeout, "timeout", 60*time.Second, "Timeout for waiting on sync")
	createCmd.Flags().StringVar(&createFromFile, "from-file", "", "Load spec from a YAML or JSON file")
	createCmd.Flags().BoolVar(&createDryRun, "dry-run", false, "Print the CR that would be created without creating it")

	// Allow unknown flags to pass through as spec parameters (parsed from os.Args)
	createCmd.FParseErrWhitelist.UnknownFlags = true
}

func runCreate(cmd *cobra.Command, args []string) error {
	if err := validateTargetingFlags(); err != nil {
		return err
	}

	ctx := context.Background()
	resourceType := strings.ToLower(args[0])

	// Resolve resource type to kind
	resourceKind := resolveResourceKind(resourceType)
	if resourceKind == "" {
		return fmt.Errorf("unknown resource type: %s\nRun 'kubectl petstore create --help' to see available types", resourceType)
	}

	plural := resolveResourcePlural(resourceType)

	// Build spec from flags or file
	var spec map[string]interface{}
	if createFromFile != "" {
		var err error
		spec, err = loadSpecFromFile(createFromFile)
		if err != nil {
			return fmt.Errorf("failed to load spec from file: %w", err)
		}
	} else {
		spec = parseCreateParams()
	}

	if len(spec) == 0 {
		return fmt.Errorf("no spec fields provided\nUse --key=value flags or --from-file to provide resource spec")
	}

	// Generate CR name
	name := createCRName
	if name == "" {
		name = fmt.Sprintf("%s-%d", resourceType, time.Now().Unix())
	}

	// Build the CR
	cr := buildResourceCR(resourceKind, name, spec)

	// Dry run - print CR and exit
	if createDryRun {
		switch outputFormat {
		case "json":
			return output.PrintJSON(cr.Object)
		default:
			return output.PrintYAML(cr.Object)
		}
	}

	// Create the CR
	fmt.Printf("Creating %s: %s\n", resourceKind, name)

	_, err := k8sClient.Create(ctx, plural, cr)
	if apierrors.IsAlreadyExists(err) {
		// Resource already exists - update its spec instead
		fmt.Printf("Resource %s/%s already exists, updating spec...\n", plural, name)

		existing, getErr := k8sClient.Get(ctx, plural, name)
		if getErr != nil {
			return fmt.Errorf("failed to get existing resource for update: %w", getErr)
		}

		// Preserve metadata required for update
		cr.SetResourceVersion(existing.GetResourceVersion())
		cr.SetUID(existing.GetUID())

		// Preserve existing annotations, labels, finalizers
		existingAnnotations := existing.GetAnnotations()
		if existingAnnotations == nil {
			existingAnnotations = make(map[string]string)
		}
		existingAnnotations["petstore.example.com/created-by"] = "kubectl-plugin"
		cr.SetAnnotations(existingAnnotations)
		if labels := existing.GetLabels(); labels != nil {
			cr.SetLabels(labels)
		}
		if finalizers := existing.GetFinalizers(); len(finalizers) > 0 {
			cr.SetFinalizers(finalizers)
		}

		_, updateErr := k8sClient.Update(ctx, plural, cr)
		if updateErr != nil {
			return fmt.Errorf("failed to update existing resource: %w", updateErr)
		}
		fmt.Printf("Resource updated: %s/%s\n", plural, name)
	} else if err != nil {
		errMsg := err.Error()
		// Detect type mismatch errors from CRD validation and provide helpful hints
		if strings.Contains(errMsg, "must be of type object") ||
			strings.Contains(errMsg, "must be of type array") ||
			strings.Contains(errMsg, "Invalid value") {
			var hints []string
			for key, val := range spec {
				switch val.(type) {
				case []interface{}:
					hints = append(hints, fmt.Sprintf("  --%s may need JSON array of objects: --%s='[{\"id\":1,\"name\":\"value\"}]'", key, key))
				case string:
					hints = append(hints, fmt.Sprintf("  --%s may need JSON object syntax: --%s='{\"key\":\"value\"}'", key, key))
				}
			}
			if len(hints) > 0 {
				return fmt.Errorf("resource validation failed: %w\n\nHint: Some fields may require JSON syntax for complex types:\n%s", err, strings.Join(hints, "\n"))
			}
		}
		return fmt.Errorf("failed to create resource: %w", err)
	} else {
		fmt.Printf("Resource created: %s/%s\n", plural, name)
	}

	// Wait for sync unless --no-wait
	if !createNoWait {
		return waitForCreateResult(ctx, plural, name)
	}

	fmt.Println("Resource submitted. Use 'kubectl petstore describe' to check status.")
	return nil
}

func resolveResourceKind(resourceType string) string {
	resourceType = strings.ToLower(resourceType)
	resourceKinds := map[string]string{
		"order": "Order",
		"orders": "Order",
		"pet": "Pet",
		"pets": "Pet",
		"user": "User",
		"users": "User",
	}
	return resourceKinds[resourceType]
}

func resolveResourcePlural(resourceType string) string {
	resourceType = strings.ToLower(resourceType)
	resourcePlurals := map[string]string{
		"order": "orders",
		"orders": "orders",
		"pet": "pets",
		"pets": "pets",
		"user": "users",
		"users": "users",
	}
	return resourcePlurals[resourceType]
}

func parseCreateParams() map[string]interface{} {
	params := make(map[string]interface{})

	// Parse --key=value and --key value style args from os.Args
	args := os.Args
	for i := 0; i < len(args); i++ {
		arg := args[i]
		if !strings.HasPrefix(arg, "--") {
			continue
		}

		stripped := strings.TrimPrefix(arg, "--")

		// Handle --key=value syntax
		if strings.Contains(stripped, "=") {
			parts := strings.SplitN(stripped, "=", 2)
			if !isCreateCommonFlag(parts[0]) {
				params[parts[0]] = coerceCreateParamValue(parts[1])
			}
			continue
		}

		// Handle --key value syntax (space-separated)
		key := stripped
		if isCreateCommonFlag(key) {
			continue
		}
		// Look ahead for the value (next arg that doesn't start with --)
		if i+1 < len(args) && !strings.HasPrefix(args[i+1], "--") {
			params[key] = coerceCreateParamValue(args[i+1])
			i++ // skip the value arg
		}
	}

	return params
}

// coerceCreateParamValue attempts to convert string values to appropriate Go types.
// It tries JSON objects/arrays first, then integer, float, boolean, and falls back to string.
func coerceCreateParamValue(s string) interface{} {
	// Try JSON object or array
	if (strings.HasPrefix(s, "{") && strings.HasSuffix(s, "}")) ||
		(strings.HasPrefix(s, "[") && strings.HasSuffix(s, "]")) {
		var jsonVal interface{}
		if err := json.Unmarshal([]byte(s), &jsonVal); err == nil {
			return jsonVal
		}
	}
	// Try comma-separated array (only if contains comma and not JSON)
	if strings.Contains(s, ",") && !strings.HasPrefix(s, "{") && !strings.HasPrefix(s, "[") {
		parts := strings.Split(s, ",")
		result := make([]interface{}, len(parts))
		for i, p := range parts {
			result[i] = strings.TrimSpace(p)
		}
		return result
	}
	// Try integer
	if i, err := strconv.ParseInt(s, 10, 64); err == nil {
		return i
	}
	// Try float
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	// Try boolean
	if b, err := strconv.ParseBool(s); err == nil {
		return b
	}
	// Return as string
	return s
}

func isCreateCommonFlag(name string) bool {
	if isTargetingFlag(name) {
		return true
	}
	commonFlags := map[string]bool{
		"cr-name": true, "no-wait": true, "wait": true,
		"timeout": true, "output": true, "from-file": true,
		"dry-run": true,
		"namespace": true, "context": true, "kubeconfig": true,
	}
	return commonFlags[name]
}

func buildResourceCR(kind, name string, spec map[string]interface{}) *unstructured.Unstructured {
	// Add targeting if specified
	if target := buildTargetSpec(); target != nil {
		spec["target"] = target
	}

	annotations := map[string]interface{}{
		"petstore.example.com/created-by": "kubectl-plugin",
	}

	obj := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "petstore.example.com/v1alpha1",
			"kind":       kind,
			"metadata": map[string]interface{}{
				"name":        name,
				"namespace":   k8sClient.GetNamespace(),
				"annotations": annotations,
			},
			"spec": spec,
		},
	}

	return obj
}

func loadSpecFromFile(path string) (map[string]interface{}, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	// Try YAML first (which also handles JSON)
	var spec map[string]interface{}
	if err := yaml.Unmarshal(data, &spec); err != nil {
		return nil, fmt.Errorf("failed to parse file as YAML/JSON: %w", err)
	}

	return spec, nil
}

func waitForCreateResult(ctx context.Context, plural, name string) error {
	fmt.Printf("Waiting for sync (timeout: %s)...\n", createTimeout)

	deadline := time.Now().Add(createTimeout)
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	startTime := time.Now()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
			if time.Now().After(deadline) {
				return fmt.Errorf("timeout waiting for resource to sync")
			}

			obj, err := k8sClient.Get(ctx, plural, name)
			if err != nil {
				continue
			}

			// Check if resource has synced
			state, _, _ := unstructured.NestedString(obj.Object, "status", "state")
			if state == "Synced" {
				elapsed := time.Since(startTime)
				return printCreateResult(obj, elapsed)
			}
			if state == "Failed" || state == "Error" {
				msg, _, _ := unstructured.NestedString(obj.Object, "status", "message")
				return fmt.Errorf("resource sync failed: %s", msg)
			}
		}
	}
}

func printCreateResult(obj *unstructured.Unstructured, elapsed time.Duration) error {
	fmt.Println()
	fmt.Println(output.Green("Resource synced successfully"))

	// Get state
	state, _, _ := unstructured.NestedString(obj.Object, "status", "state")
	fmt.Printf("  State: %s\n", state)

	// Get externalID
	externalID, hasID, _ := unstructured.NestedString(obj.Object, "status", "externalID")
	if hasID && externalID != "" {
		fmt.Printf("  External ID: %s\n", externalID)
	}

	// Get response data
	response, found, _ := unstructured.NestedMap(obj.Object, "status", "response")
	if found {
		// Check status code
		if statusCode, ok := response["statusCode"].(int64); ok {
			fmt.Printf("  Status Code: %d\n", statusCode)
		}

		// Print response data
		data, hasData := response["data"]
		if hasData {
			fmt.Println("  Response:")
			switch outputFormat {
			case "json":
				return output.PrintJSON(data)
			case "yaml":
				return output.PrintYAML(data)
			default:
				printCreateData(data, "    ")
			}
		}
	}

	if elapsed > 0 {
		fmt.Printf("\nSync time: %s\n", elapsed.Round(time.Millisecond))
	}

	return nil
}

func printCreateData(data interface{}, indent string) {
	switch v := data.(type) {
	case map[string]interface{}:
		for k, val := range v {
			fmt.Printf("%s%s: %v\n", indent, k, formatCreateValue(val))
		}
	case []interface{}:
		for i, item := range v {
			fmt.Printf("%s[%d]: %v\n", indent, i, formatCreateValue(item))
		}
	default:
		fmt.Printf("%s%v\n", indent, v)
	}
}

func formatCreateValue(v interface{}) string {
	switch val := v.(type) {
	case string:
		if len(val) > 50 {
			return val[:47] + "..."
		}
		return val
	case map[string]interface{}:
		return "{...}"
	case []interface{}:
		return fmt.Sprintf("[%d items]", len(val))
	default:
		return fmt.Sprintf("%v", val)
	}
}

// listResourceTypesCmd lists available resource types for create
var listResourceTypesCmd = &cobra.Command{
	Use:   "types",
	Short: "List available resource types for create",
	Long:  `List all available resource types that can be created.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		fmt.Println("Available resource types:")
		fmt.Println()
		fmt.Printf("  %-30s %s\n", "order", "Order")
		fmt.Printf("  %-30s %s\n", "pet", "Pet")
		fmt.Printf("  %-30s %s\n", "user", "User")
		fmt.Println()
		fmt.Println("Use 'kubectl petstore create <type> --help' for more information")
		return nil
	},
}

func init() {
	// Add list subcommand
	createCmd.AddCommand(listResourceTypesCmd)
}
