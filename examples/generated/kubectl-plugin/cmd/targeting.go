// Generated by openapi-operator-gen v0.0.10-2-g1dff72e-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"fmt"
	"strings"

	"github.com/spf13/cobra"
)

// Shared targeting flag variables used by create, action, query, and patch commands.
// These correspond to the TargetSpec fields in the CRD types.
var (
	targetPodOrdinal  int
	targetBaseURL     string
	targetBaseURLs    string
	targetStatefulSet string
	targetDeployment  string
	targetPod         string
	targetHelmRelease string
	targetNamespace   string
	targetLabels      string
)

// addTargetingFlags registers all endpoint targeting flags on a cobra command.
func addTargetingFlags(cmd *cobra.Command) {
	cmd.Flags().IntVar(&targetPodOrdinal, "target-pod-ordinal", -1, "Target specific StatefulSet pod ordinal (0-indexed)")
	cmd.Flags().StringVar(&targetBaseURL, "target-base-url", "", "Static base URL override for the API endpoint")
	cmd.Flags().StringVar(&targetBaseURLs, "target-base-urls", "", "Comma-separated base URLs for fan-out to multiple endpoints")
	cmd.Flags().StringVar(&targetStatefulSet, "target-statefulset", "", "Target a named StatefulSet for endpoint discovery")
	cmd.Flags().StringVar(&targetDeployment, "target-deployment", "", "Target a named Deployment for endpoint discovery")
	cmd.Flags().StringVar(&targetPod, "target-pod", "", "Target a specific pod by name")
	cmd.Flags().StringVar(&targetHelmRelease, "target-helm-release", "", "Discover target workload via Helm release name")
	cmd.Flags().StringVar(&targetNamespace, "target-namespace", "", "Namespace for target workload lookup")
	cmd.Flags().StringVar(&targetLabels, "target-labels", "", "Additional labels for workload discovery (key=value,key=value)")
}

// isTargetingFlag returns true if the flag name is a targeting flag.
// Used by parameter parsers to exclude targeting flags from spec parameters.
func isTargetingFlag(name string) bool {
	targetingFlags := map[string]bool{
		"target-pod-ordinal":  true,
		"target-base-url":     true,
		"target-base-urls":    true,
		"target-statefulset":  true,
		"target-deployment":   true,
		"target-pod":          true,
		"target-helm-release": true,
		"target-namespace":    true,
		"target-labels":       true,
	}
	return targetingFlags[name]
}

// validateTargetingFlags checks for mutually exclusive and dependent targeting flags.
func validateTargetingFlags() error {
	if targetBaseURL != "" && targetBaseURLs != "" {
		return fmt.Errorf("--target-base-url and --target-base-urls are mutually exclusive")
	}
	// --target-pod-ordinal only makes sense with a StatefulSet target
	if targetPodOrdinal >= 0 && targetStatefulSet == "" && targetHelmRelease == "" {
		return fmt.Errorf("--target-pod-ordinal requires --target-statefulset or --target-helm-release (pod ordinal targets a StatefulSet)")
	}
	// --target-labels only makes sense with --target-helm-release
	if targetLabels != "" && targetHelmRelease == "" {
		return fmt.Errorf("--target-labels requires --target-helm-release (labels narrow discovery within a Helm release)")
	}
	return nil
}

// parseTargetLabels parses the --target-labels flag value into a map.
// Format: "key1=value1,key2=value2"
func parseTargetLabels() (map[string]string, error) {
	if targetLabels == "" {
		return nil, nil
	}
	labels := make(map[string]string)
	pairs := strings.Split(targetLabels, ",")
	for _, pair := range pairs {
		pair = strings.TrimSpace(pair)
		if pair == "" {
			continue
		}
		parts := strings.SplitN(pair, "=", 2)
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid label format %q: expected key=value", pair)
		}
		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])
		if key == "" {
			return nil, fmt.Errorf("invalid label: empty key in %q", pair)
		}
		labels[key] = value
	}
	return labels, nil
}

// buildTargetSpec constructs a spec.target map from the targeting flag values.
// Returns nil if no targeting flags were set.
func buildTargetSpec() map[string]interface{} {
	target := make(map[string]interface{})

	if targetPodOrdinal >= 0 {
		target["podOrdinal"] = targetPodOrdinal
	}
	if targetBaseURL != "" {
		target["baseURL"] = targetBaseURL
	}
	if targetBaseURLs != "" {
		urls := strings.Split(targetBaseURLs, ",")
		trimmed := make([]interface{}, len(urls))
		for i, u := range urls {
			trimmed[i] = strings.TrimSpace(u)
		}
		target["baseURLs"] = trimmed
	}
	if targetStatefulSet != "" {
		target["statefulSet"] = targetStatefulSet
	}
	if targetDeployment != "" {
		target["deployment"] = targetDeployment
	}
	if targetPod != "" {
		target["pod"] = targetPod
	}
	if targetHelmRelease != "" {
		target["helmRelease"] = targetHelmRelease
	}
	if targetNamespace != "" {
		target["namespace"] = targetNamespace
	}
	if targetLabels != "" {
		labels, err := parseTargetLabels()
		if err == nil && len(labels) > 0 {
			target["labels"] = labels
		}
	}

	if len(target) == 0 {
		return nil
	}
	return target
}

// resetTargetingFlags resets all targeting flag variables to their defaults.
// Used in tests to ensure clean state between test cases.
func resetTargetingFlags() {
	targetPodOrdinal = -1
	targetBaseURL = ""
	targetBaseURLs = ""
	targetStatefulSet = ""
	targetDeployment = ""
	targetPod = ""
	targetHelmRelease = ""
	targetNamespace = ""
	targetLabels = ""
}
