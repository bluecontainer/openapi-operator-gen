// Generated by openapi-operator-gen v0.0.10-27-g49a94a0-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"k8s.io/cli-runtime/pkg/genericclioptions"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/client"
	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	version   = "dev"
	commit    = "none"
	buildDate = "unknown"

	// Global flags
	kubeConfigFlags *genericclioptions.ConfigFlags
	outputFormat    string

	// Shared client (initialized lazily)
	k8sClient *client.Client
)

// SetVersion sets the version info from main
func SetVersion(v, c, d string) {
	version = v
	commit = c
	buildDate = d
}

var rootCmd = &cobra.Command{
	Use:   "kubectl-petstore",
	Short: "kubectl plugin for managing petstore resources",
	Long: `kubectl petstore is a kubectl plugin for managing petstore operator resources.

It provides commands for:
  - Creating resources from CLI flags
  - Viewing aggregate health status
  - Listing and describing resources
  - Running diagnostics and comparing across pods
  - Drift detection and reporting
  - Pausing and resuming reconciliation
  - Executing queries and actions
  - Temporary patches with auto-rollback

Examples:
  # View overall status
  kubectl petstore status

  # List all resources of a specific kind
  kubectl petstore get pets

  # Get detailed information about a resource
  kubectl petstore describe pet fluffy

  # Run diagnostics on a resource
  kubectl petstore diagnose pet fluffy

  # Compare resource across pods
  kubectl petstore compare pet fluffy --pods=0,1,2

  # Show drift report
  kubectl petstore drift

  # Pause reconciliation for a resource
  kubectl petstore pause pet fluffy --reason="Maintenance"

  # Resume reconciliation
  kubectl petstore unpause pet fluffy

  # Create a resource from CLI flags
  kubectl petstore create pet --name=fluffy --status=available

  # Execute a query
  kubectl petstore query storeinventoryquery

  # Execute an action
  kubectl petstore action petuploadimageaction --petId=123

  # Make temporary change with TTL
  kubectl petstore patch pet fluffy --spec='{"status":"pending"}' --ttl=1h

  # Cleanup one-shot resources
  kubectl petstore cleanup --one-shot`,
	Version: version,
	PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
		// Skip client initialization for commands that don't need it
		switch cmd.Name() {
		case "help", "version", "types", "list":
			return nil
		}
		// For --dry-run, only resolve namespace (no cluster connection needed)
		if f := cmd.Flags().Lookup("dry-run"); f != nil && f.Value.String() == "true" {
			return initDryRunClient()
		}
		return initClient()
	},
}

func init() {
	// Initialize kubeconfig flags (includes --namespace/-n)
	kubeConfigFlags = genericclioptions.NewConfigFlags(true)
	kubeConfigFlags.AddFlags(rootCmd.PersistentFlags())

	// Add output format flag (don't use -o shorthand, conflicts with kubeconfig output)
	rootCmd.PersistentFlags().StringVar(&outputFormat, "output", "", "Output format: table, json, yaml, wide")
	rootCmd.PersistentFlags().BoolVar(&output.CompactMode, "compact", false, "Compact JSON output (single-line, for log filter parsing)")

	// Set version template
	rootCmd.SetVersionTemplate(fmt.Sprintf("kubectl-petstore version %s\n  commit: %s\n  built:  %s\n", version, commit, buildDate))

	// Add subcommands - Phase 1: Core Commands
	rootCmd.AddCommand(statusCmd)
	rootCmd.AddCommand(getCmd)
	rootCmd.AddCommand(describeCmd)

	// Phase 2: Diagnostic Commands
	rootCmd.AddCommand(compareCmd)
	rootCmd.AddCommand(diagnoseCmd)
	rootCmd.AddCommand(driftCmd)

	// Phase 3: Interactive/Management Commands
	rootCmd.AddCommand(createCmd)
	rootCmd.AddCommand(queryCmd)
	rootCmd.AddCommand(actionCmd)
	rootCmd.AddCommand(patchCmd)
	rootCmd.AddCommand(pauseCmd)
	rootCmd.AddCommand(unpauseCmd)
	rootCmd.AddCommand(cleanupCmd)

	// Rundeck Integration
	rootCmd.AddCommand(nodesCmd)
}

// initClient initializes the Kubernetes client
func initClient() error {
	var err error
	k8sClient, err = client.NewClient(kubeConfigFlags, "petstore.example.com", "v1alpha1")
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes client: %w", err)
	}

	// Set namespace from flag or default from kubeconfig
	ns, _, err := kubeConfigFlags.ToRawKubeConfigLoader().Namespace()
	if err != nil || ns == "" {
		ns = "default"
	}
	k8sClient.SetNamespace(ns)

	return nil
}

// initDryRunClient creates a minimal client for dry-run mode (no cluster connection).
// Only namespace resolution is needed for rendering the CR preview.
func initDryRunClient() error {
	k8sClient = &client.Client{}

	// Resolve namespace from --namespace flag or kubeconfig context
	ns, _, err := kubeConfigFlags.ToRawKubeConfigLoader().Namespace()
	if err != nil || ns == "" {
		ns = "default"
	}
	k8sClient.SetNamespace(ns)

	return nil
}

// Execute runs the root command
func Execute() error {
	return rootCmd.Execute()
}

// exitWithError prints an error message and exits
func exitWithError(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "Error: "+format+"\n", args...)
	os.Exit(1)
}
