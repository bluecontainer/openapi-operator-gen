// Generated by openapi-operator-gen v0.0.10-13-g20d778f-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"reflect"
	"sort"
	"strings"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	compareField string
)

var compareCmd = &cobra.Command{
	Use:   "compare KIND NAME",
	Short: "Compare a resource's state across multiple endpoints/pods",
	Long: `Compare the state of a resource across multiple endpoints when using
the all-healthy strategy with a StatefulSet or multiple base URLs.

This command reads a single CR and compares the responses stored in
status.responses, which contains the state from each endpoint.

This is useful for detecting inconsistencies in StatefulSet deployments
where each pod may have a different view of the resource.

Available kinds:
  - order (Order)
  - pet (Pet)
  - user (User)
  - petfindbystatusquery (PetFindbystatusQuery)
  - petfindbytagsquery (PetFindbytagsQuery)
  - storeinventoryquery (StoreInventoryQuery)
  - userloginquery (UserLoginQuery)
  - userlogoutquery (UserLogoutQuery)

Examples:
  # Compare resource responses across all endpoints
  kubectl petstore compare pet fluffy

  # Compare specific field across endpoints
  kubectl petstore compare pet fluffy --field=data.name

  # Output as JSON for scripting
  kubectl petstore compare pet fluffy --output json`,
	Args: cobra.ExactArgs(2),
	RunE: runCompare,
}

func init() {
	compareCmd.Flags().StringVar(&compareField, "field", "", "Specific field path to compare within response data (e.g., data.name, data.status)")
}

// EndpointComparison holds comparison results for a single endpoint
type EndpointComparison struct {
	Endpoint string
	Success  bool
	Error    string
	Fields   map[string]interface{}
}

// ComparisonResult holds the overall comparison result
type ComparisonResult struct {
	Kind        string
	Name        string
	Namespace   string
	Endpoints   []EndpointComparison
	Consistent  bool
	Differences []FieldDifference
}

// FieldDifference represents a difference in a field across endpoints
type FieldDifference struct {
	Field  string
	Values map[string]interface{} // endpoint -> value
}

func runCompare(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	kindArg := strings.ToLower(args[0])
	name := args[1]

	// Resolve kind to plural form
	plural := resolveKindPlural(kindArg)
	if plural == "" {
		return fmt.Errorf("unknown resource kind: %s", kindArg)
	}

	// Get the resource
	obj, err := k8sClient.Get(ctx, plural, name)
	if err != nil {
		return fmt.Errorf("failed to get %s/%s: %w", kindArg, name, err)
	}

	// Extract responses from status.responses
	responses, hasResponses, _ := unstructured.NestedMap(obj.Object, "status", "responses")
	if !hasResponses || len(responses) == 0 {
		// Check if there's a single response (non-fanout mode)
		singleResponse, hasSingle, _ := unstructured.NestedMap(obj.Object, "status", "response")
		if hasSingle && singleResponse != nil {
			fmt.Printf("Resource %s/%s is in single-endpoint mode (no multi-endpoint responses to compare)\n", kindArg, name)
			fmt.Println("\nTo use compare, the resource must be configured with:")
			fmt.Println("  - all-healthy strategy targeting a StatefulSet, or")
			fmt.Println("  - multiple base URLs in spec.target.baseURLs")
			return nil
		}
		return fmt.Errorf("no endpoint responses found in %s/%s status", kindArg, name)
	}

	// Build comparison data from responses
	result := ComparisonResult{
		Kind:      obj.GetKind(),
		Name:      name,
		Namespace: obj.GetNamespace(),
		Endpoints: make([]EndpointComparison, 0, len(responses)),
	}

	// Sort endpoint URLs for consistent output
	endpoints := make([]string, 0, len(responses))
	for endpoint := range responses {
		endpoints = append(endpoints, endpoint)
	}
	sort.Strings(endpoints)

	for _, endpoint := range endpoints {
		respRaw := responses[endpoint]
		resp, ok := respRaw.(map[string]interface{})
		if !ok {
			continue
		}

		comparison := EndpointComparison{
			Endpoint: endpoint,
			Fields:   make(map[string]interface{}),
		}

		// Check success status
		success, _, _ := unstructured.NestedBool(resp, "success")
		comparison.Success = success

		if !success {
			errMsg, _, _ := unstructured.NestedString(resp, "error")
			comparison.Error = errMsg
			result.Endpoints = append(result.Endpoints, comparison)
			continue
		}

		// Extract fields for comparison
		if compareField != "" {
			// Compare specific field within data
			data, hasData, _ := unstructured.NestedMap(resp, "data")
			if hasData {
				value, found, _ := getNestedField(data, compareField)
				if found {
					comparison.Fields[compareField] = value
				} else {
					comparison.Fields[compareField] = "<not found>"
				}
			} else {
				comparison.Fields[compareField] = "<no data>"
			}
		} else {
			// Compare all data fields
			comparison.Fields = extractResponseFields(resp)
		}

		result.Endpoints = append(result.Endpoints, comparison)
	}

	// Analyze differences
	result.Differences = analyzeEndpointDifferences(result.Endpoints)
	result.Consistent = len(result.Differences) == 0

	return printComparisonResult(&result)
}

func extractResponseFields(resp map[string]interface{}) map[string]interface{} {
	fields := make(map[string]interface{})

	// Extract key response metadata
	if success, ok, _ := unstructured.NestedBool(resp, "success"); ok {
		fields["success"] = success
	}
	if statusCode, ok, _ := unstructured.NestedInt64(resp, "statusCode"); ok {
		fields["statusCode"] = statusCode
	}

	// Extract data fields
	data, hasData, _ := unstructured.NestedMap(resp, "data")
	if hasData {
		for k, v := range data {
			fields["data."+k] = v
		}
	}

	// Also try to extract from raw extension if data is stored differently
	dataRaw, hasDataRaw, _ := unstructured.NestedFieldNoCopy(resp, "data")
	if hasDataRaw && !hasData {
		// data might be a raw extension or primitive
		if dataMap, ok := dataRaw.(map[string]interface{}); ok {
			for k, v := range dataMap {
				fields["data."+k] = v
			}
		} else {
			fields["data"] = dataRaw
		}
	}

	return fields
}

func getNestedField(obj map[string]interface{}, path string) (interface{}, bool, error) {
	parts := strings.Split(path, ".")
	return unstructured.NestedFieldNoCopy(obj, parts...)
}

func analyzeEndpointDifferences(endpoints []EndpointComparison) []FieldDifference {
	if len(endpoints) < 2 {
		return nil
	}

	// Collect all fields across all endpoints
	allFields := make(map[string]bool)
	for _, ep := range endpoints {
		if !ep.Success {
			continue
		}
		for field := range ep.Fields {
			allFields[field] = true
		}
	}

	// Check each field for differences
	var differences []FieldDifference
	for field := range allFields {
		values := make(map[string]interface{})
		var firstValue interface{}
		firstSet := false
		hasDifference := false

		for _, ep := range endpoints {
			if !ep.Success {
				values[ep.Endpoint] = "<failed>"
				hasDifference = true
				continue
			}

			value, exists := ep.Fields[field]
			if !exists {
				values[ep.Endpoint] = "<missing>"
				hasDifference = true
				continue
			}

			values[ep.Endpoint] = value

			if !firstSet {
				firstValue = value
				firstSet = true
			} else if !reflect.DeepEqual(firstValue, value) {
				hasDifference = true
			}
		}

		if hasDifference {
			differences = append(differences, FieldDifference{
				Field:  field,
				Values: values,
			})
		}
	}

	// Sort differences by field name
	sort.Slice(differences, func(i, j int) bool {
		return differences[i].Field < differences[j].Field
	})

	return differences
}

func printComparisonResult(result *ComparisonResult) error {
	switch outputFormat {
	case "json":
		return output.PrintJSON(result)
	case "yaml":
		return output.PrintYAML(result)
	default:
		return printComparisonTable(result)
	}
}

func printComparisonTable(result *ComparisonResult) error {
	fmt.Printf("Comparing %s/%s across %d endpoints...\n\n", strings.ToLower(result.Kind), result.Name, len(result.Endpoints))

	if len(result.Endpoints) == 0 {
		fmt.Println("No endpoint responses found")
		return nil
	}

	// Build headers - use shortened endpoint names
	headers := []string{"FIELD"}
	endpointNames := make([]string, 0, len(result.Endpoints))
	for _, ep := range result.Endpoints {
		shortName := shortenEndpoint(ep.Endpoint)
		headers = append(headers, shortName)
		endpointNames = append(endpointNames, ep.Endpoint)
	}

	// Collect all fields
	allFields := make(map[string]bool)
	for _, ep := range result.Endpoints {
		for field := range ep.Fields {
			allFields[field] = true
		}
	}

	// Sort fields
	fields := make([]string, 0, len(allFields))
	for field := range allFields {
		fields = append(fields, field)
	}
	sort.Strings(fields)

	// Build rows
	rows := make([][]string, 0, len(fields))
	for _, field := range fields {
		row := []string{field}
		for _, ep := range result.Endpoints {
			if !ep.Success {
				row = append(row, output.Red("<failed>"))
				continue
			}
			value, exists := ep.Fields[field]
			if !exists {
				row = append(row, "-")
			} else {
				row = append(row, formatCompareValue(value))
			}
		}
		rows = append(rows, row)
	}

	output.PrintTable(headers, rows)

	// Print endpoint legend if names were shortened
	if needsLegend(result.Endpoints) {
		fmt.Println("\nEndpoint legend:")
		for i, ep := range result.Endpoints {
			fmt.Printf("  %s: %s\n", shortenEndpoint(ep.Endpoint), ep.Endpoint)
			if !ep.Success && ep.Error != "" {
				fmt.Printf("    Error: %s\n", ep.Error)
			}
			_ = i // suppress unused warning
		}
	}

	// Print result summary
	fmt.Println()
	if result.Consistent {
		fmt.Printf("Result: %s All endpoints consistent\n", output.Green("✓"))
	} else {
		fmt.Printf("Result: %s Inconsistency detected\n", output.Red("✗"))
		fmt.Println()
		fmt.Println("Differences found in fields:")
		for _, diff := range result.Differences {
			fmt.Printf("  - %s\n", diff.Field)
		}
	}

	return nil
}

// shortenEndpoint creates a short display name for an endpoint URL
func shortenEndpoint(endpoint string) string {
	// Try to extract pod name from URL like http://petstore-0.petstore:8080
	// or http://10.0.0.1:8080
	endpoint = strings.TrimPrefix(endpoint, "http://")
	endpoint = strings.TrimPrefix(endpoint, "https://")

	// Remove port
	if idx := strings.LastIndex(endpoint, ":"); idx != -1 {
		endpoint = endpoint[:idx]
	}

	// If it looks like a pod DNS name (contains dots), take first part
	if parts := strings.Split(endpoint, "."); len(parts) > 1 {
		return parts[0]
	}

	// Truncate long names
	if len(endpoint) > 15 {
		return endpoint[:12] + "..."
	}

	return endpoint
}

// needsLegend checks if we should print a legend for shortened endpoint names
func needsLegend(endpoints []EndpointComparison) bool {
	for _, ep := range endpoints {
		if shortenEndpoint(ep.Endpoint) != ep.Endpoint {
			return true
		}
	}
	return false
}

func formatCompareValue(v interface{}) string {
	if v == nil {
		return "-"
	}
	switch val := v.(type) {
	case string:
		if len(val) > 25 {
			return val[:22] + "..."
		}
		return val
	case bool:
		if val {
			return "true"
		}
		return "false"
	case int64, int, float64:
		return fmt.Sprintf("%v", val)
	case map[string]interface{}:
		return "<object>"
	case []interface{}:
		return fmt.Sprintf("<array[%d]>", len(val))
	default:
		s := fmt.Sprintf("%v", val)
		if len(s) > 25 {
			return s[:22] + "..."
		}
		return s
	}
}
