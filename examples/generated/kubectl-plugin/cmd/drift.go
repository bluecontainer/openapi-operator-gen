// Generated by openapi-operator-gen v0.0.10-4-g470003d-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	driftKind     string
	driftShowDiff bool
	driftAllNS    bool
)

var driftCmd = &cobra.Command{
	Use:   "drift",
	Short: "Show drift detection report for petstore resources",
	Long: `Display a drift detection report showing resources where the spec
differs from the actual API state.

Drift occurs when:
  - The API returns different values than what's in the CR spec
  - An external change was made directly to the API
  - A partial update occurred

Examples:
  # Show drift report for all resources
  kubectl petstore drift

  # Filter by kind
  kubectl petstore drift --kind=Pet

  # Show detailed diff for drifted resources
  kubectl petstore drift --show-diff

  # Check across all namespaces
  kubectl petstore drift --all-namespaces`,
	RunE: runDrift,
}

func init() {
	driftCmd.Flags().StringVar(&driftKind, "kind", "", "Filter by resource kind (e.g., Pet, Order)")
	driftCmd.Flags().BoolVar(&driftShowDiff, "show-diff", false, "Show detailed diff for drifted resources")
	driftCmd.Flags().BoolVarP(&driftAllNS, "all-namespaces", "A", false, "Check resources across all namespaces")
}

// DriftInfo holds drift information for a single resource
type DriftInfo struct {
	Kind             string
	Name             string
	Namespace        string
	HasDrift         bool
	DriftCount       int64
	LastDetected     string
	DriftedFields    []DriftedField
	DriftedEndpoints []string // Endpoints where drift was detected (multi-endpoint mode)
	TotalEndpoints   int      // Total number of endpoints (0 if single-endpoint mode)
}

// DriftedField represents a field that has drifted
type DriftedField struct {
	Field       string
	SpecValue   interface{}
	ActualValue interface{}
}

// DriftReport holds the overall drift report
type DriftReport struct {
	Namespace       string
	TotalResources  int
	DriftedCount    int
	Resources       []DriftInfo
}

func runDrift(cmd *cobra.Command, args []string) error {
	ctx := context.Background()

	report := DriftReport{
		Namespace: k8sClient.GetNamespace(),
		Resources: make([]DriftInfo, 0),
	}

	if driftAllNS {
		report.Namespace = "(all namespaces)"
	}

	// Determine which kinds to check
	kindsToCheck := getKindsToCheck(driftKind)

	for _, kindInfo := range kindsToCheck {
		var list *unstructured.UnstructuredList
		var err error

		if driftAllNS {
			list, err = k8sClient.ListAllNamespaces(ctx, kindInfo.Plural, "")
		} else {
			list, err = k8sClient.List(ctx, kindInfo.Plural)
		}
		if err != nil {
			// Skip kinds that don't exist or we can't access
			continue
		}

		for _, item := range list.Items {
			report.TotalResources++

			info := extractDriftInfo(&item, kindInfo.Kind)
			if info.HasDrift {
				report.DriftedCount++
			}
			report.Resources = append(report.Resources, info)
		}
	}

	// Sort by drift status (drifted first) then by name
	sort.Slice(report.Resources, func(i, j int) bool {
		if report.Resources[i].HasDrift != report.Resources[j].HasDrift {
			return report.Resources[i].HasDrift
		}
		if report.Resources[i].Kind != report.Resources[j].Kind {
			return report.Resources[i].Kind < report.Resources[j].Kind
		}
		return report.Resources[i].Name < report.Resources[j].Name
	})

	return printDriftReport(&report)
}

type kindToCheck struct {
	Kind   string
	Plural string
}

func getKindsToCheck(filterKind string) []kindToCheck {
	allKinds := []kindToCheck{
		{"Order", "orders"},
		{"Pet", "pets"},
		{"User", "users"},
		{"PetFindbystatusQuery", "petfindbystatusqueries"},
		{"PetFindbytagsQuery", "petfindbytagsqueries"},
		{"StoreInventoryQuery", "storeinventoryqueries"},
		{"UserLoginQuery", "userloginqueries"},
		{"UserLogoutQuery", "userlogoutqueries"},
		{"PetUploadimageAction", "petuploadimageactions"},
		{"UserCreatewithlistAction", "usercreatewithlistactions"},
	}

	if filterKind == "" {
		return allKinds
	}

	// Filter by kind
	filterLower := strings.ToLower(filterKind)
	var filtered []kindToCheck
	for _, k := range allKinds {
		if strings.ToLower(k.Kind) == filterLower || strings.ToLower(k.Plural) == filterLower {
			filtered = append(filtered, k)
		}
	}
	return filtered
}

func extractDriftInfo(obj *unstructured.Unstructured, kind string) DriftInfo {
	info := DriftInfo{
		Kind:      kind,
		Name:      obj.GetName(),
		Namespace: obj.GetNamespace(),
	}

	// Check drift status
	info.HasDrift, _, _ = unstructured.NestedBool(obj.Object, "status", "driftDetected")

	// Get drift count
	info.DriftCount, _, _ = unstructured.NestedInt64(obj.Object, "status", "driftDetectedCount")

	// Get last detected time from lastSyncTime (when drift was last checked)
	info.LastDetected, _, _ = unstructured.NestedString(obj.Object, "status", "lastSyncTime")

	// Fall back to Ready condition's lastTransitionTime if lastSyncTime not available
	if info.LastDetected == "" {
		conditions, found, _ := unstructured.NestedSlice(obj.Object, "status", "conditions")
		if found {
			for _, c := range conditions {
				cond, ok := c.(map[string]interface{})
				if !ok {
					continue
				}
				condType, _, _ := unstructured.NestedString(cond, "type")
				if condType == "Ready" {
					info.LastDetected, _, _ = unstructured.NestedString(cond, "lastTransitionTime")
					break
				}
			}
		}
	}

	// Check for multi-endpoint mode and identify which endpoints have drift
	responses, responsesFound, _ := unstructured.NestedMap(obj.Object, "status", "responses")
	if responsesFound && len(responses) > 0 {
		info.TotalEndpoints = len(responses)

		// Check each endpoint for drift by comparing spec with response data
		spec, hasSpec, _ := unstructured.NestedMap(obj.Object, "spec")

		for endpoint, respRaw := range responses {
			resp, ok := respRaw.(map[string]interface{})
			if !ok {
				continue
			}

			// Check if this endpoint's response differs from spec
			success, _ := resp["success"].(bool)
			if !success {
				// Failed endpoints are considered drifted (can't verify state)
				info.DriftedEndpoints = append(info.DriftedEndpoints, endpoint)
				continue
			}

			// Get the data from this endpoint's response
			data, hasData := resp["data"].(map[string]interface{})
			if !hasData || !hasSpec {
				continue
			}

			// Compare spec fields with endpoint response data
			if hasSpecDrift(spec, data) {
				info.DriftedEndpoints = append(info.DriftedEndpoints, endpoint)
			}
		}
	}

	// Extract drifted fields if show-diff is enabled
	if driftShowDiff && info.HasDrift {
		info.DriftedFields = extractDriftedFields(obj)
	}

	return info
}

// hasSpecDrift compares spec fields with response data to detect drift
func hasSpecDrift(spec, data map[string]interface{}) bool {
	for key, specVal := range spec {
		// Skip targeting/control fields
		if isControlField(key) {
			continue
		}

		dataVal, exists := data[key]
		if !exists {
			continue
		}

		// Simple comparison
		if fmt.Sprintf("%v", specVal) != fmt.Sprintf("%v", dataVal) {
			return true
		}
	}
	return false
}

func extractDriftedFields(obj *unstructured.Unstructured) []DriftedField {
	var fields []DriftedField

	// Get spec and observed response
	spec, hasSpec, _ := unstructured.NestedMap(obj.Object, "spec")
	observed, hasObserved, _ := unstructured.NestedMap(obj.Object, "status", "observedResponse")

	if !hasSpec || !hasObserved {
		return fields
	}

	// Compare spec fields with observed values
	for key, specVal := range spec {
		// Skip targeting/control fields
		if isControlField(key) {
			continue
		}

		observedVal, exists := observed[key]
		if !exists {
			continue
		}

		// Simple comparison (deep compare would be more accurate)
		if fmt.Sprintf("%v", specVal) != fmt.Sprintf("%v", observedVal) {
			fields = append(fields, DriftedField{
				Field:       key,
				SpecValue:   specVal,
				ActualValue: observedVal,
			})
		}
	}

	return fields
}

func isControlField(field string) bool {
	controlFields := map[string]bool{
		"paused":             true,
		"target":             true,
		"targetPodOrdinal":   true,
		"targetHelmRelease":  true,
		"targetNamespace":    true,
		"baseURL":            true,
		"baseURLs":           true,
		"executionInterval":  true,
		"executionMode":      true,
	}
	return controlFields[field]
}

func printDriftReport(report *DriftReport) error {
	switch outputFormat {
	case "json":
		return output.PrintJSON(report)
	case "yaml":
		return output.PrintYAML(report)
	default:
		return printDriftTable(report)
	}
}

func printDriftTable(report *DriftReport) error {
	fmt.Printf("DRIFT REPORT (namespace: %s)\n\n", report.Namespace)

	if len(report.Resources) == 0 {
		fmt.Println("No resources found")
		return nil
	}

	// Check if any resource is in multi-endpoint mode
	hasMultiEndpoint := false
	for _, r := range report.Resources {
		if r.TotalEndpoints > 1 {
			hasMultiEndpoint = true
			break
		}
	}

	// Print summary table
	headers := []string{"RESOURCE", "DRIFT", "COUNT", "LAST DETECTED"}
	if hasMultiEndpoint {
		headers = append(headers, "DRIFTED ENDPOINTS")
	}
	if driftAllNS {
		headers = append([]string{"NAMESPACE"}, headers...)
	}

	rows := make([][]string, 0, len(report.Resources))
	for _, r := range report.Resources {
		driftStr := output.Green("No")
		if r.HasDrift {
			driftStr = output.Yellow("Yes")
		}

		lastDetected := "-"
		if r.LastDetected != "" {
			lastDetected = r.LastDetected
		}

		row := []string{
			fmt.Sprintf("%s/%s", strings.ToLower(r.Kind), r.Name),
			driftStr,
			fmt.Sprintf("%d", r.DriftCount),
			lastDetected,
		}

		if hasMultiEndpoint {
			endpointInfo := "-"
			if r.TotalEndpoints > 1 {
				if len(r.DriftedEndpoints) > 0 {
					// Show which endpoints have drift
					shortNames := make([]string, 0, len(r.DriftedEndpoints))
					for _, ep := range r.DriftedEndpoints {
						shortNames = append(shortNames, shortenEndpointName(ep))
					}
					endpointInfo = output.Yellow(fmt.Sprintf("%d/%d: %s",
						len(r.DriftedEndpoints), r.TotalEndpoints,
						strings.Join(shortNames, ", ")))
				} else if r.HasDrift {
					// Drift detected but couldn't identify specific endpoints
					endpointInfo = fmt.Sprintf("?/%d", r.TotalEndpoints)
				} else {
					endpointInfo = fmt.Sprintf("0/%d", r.TotalEndpoints)
				}
			}
			row = append(row, endpointInfo)
		}

		if driftAllNS {
			row = append([]string{r.Namespace}, row...)
		}
		rows = append(rows, row)
	}

	output.PrintTable(headers, rows)

	// Print detailed diff for drifted resources
	if driftShowDiff {
		for _, r := range report.Resources {
			if !r.HasDrift || len(r.DriftedFields) == 0 {
				continue
			}

			fmt.Println()
			fmt.Printf("DRIFT DETAILS for %s/%s:\n", strings.ToLower(r.Kind), r.Name)

			diffHeaders := []string{"FIELD", "SPEC VALUE", "ACTUAL VALUE"}
			diffRows := make([][]string, 0, len(r.DriftedFields))
			for _, f := range r.DriftedFields {
				diffRows = append(diffRows, []string{
					f.Field,
					formatDriftValue(f.SpecValue),
					formatDriftValue(f.ActualValue),
				})
			}
			output.PrintTable(diffHeaders, diffRows)
		}
	}

	// Print summary
	fmt.Println()
	if report.DriftedCount > 0 {
		fmt.Printf("Total: %s resource(s) with drift (%d total resources)\n",
			output.Yellow(fmt.Sprintf("%d", report.DriftedCount)),
			report.TotalResources)
	} else {
		fmt.Printf("Total: %s (%d total resources)\n",
			output.Green("No drift detected"),
			report.TotalResources)
	}

	return nil
}

func formatDriftValue(v interface{}) string {
	if v == nil {
		return "<nil>"
	}
	s := fmt.Sprintf("%v", v)
	if len(s) > 25 {
		return s[:22] + "..."
	}
	return s
}

// Note: shortenEndpointName is defined in describe_cmd.go and shared across the package
