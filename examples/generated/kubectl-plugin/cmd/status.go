// Generated by openapi-operator-gen v0.0.10-21-g475b898-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"time"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	statusWatch bool
)

var statusCmd = &cobra.Command{
	Use:   "status",
	Short: "Show aggregate health status of petstore resources",
	Long: `Display aggregate health status showing sync state across all resource types.

This command provides a high-level overview of:
  - Overall health status
  - Count of synced, failed, and pending resources by kind
  - Drift detection summary

Examples:
  # Show status
  kubectl petstore status

  # Watch for changes
  kubectl petstore status --watch

  # Output as JSON
  kubectl petstore status -o json`,
	RunE: runStatus,
}

func init() {
	statusCmd.Flags().BoolVarP(&statusWatch, "watch", "w", false, "Watch for changes")
}

// ResourceSummary holds summary counts for a resource kind
type ResourceSummary struct {
	Kind    string
	Total   int
	Synced  int
	Failed  int
	Pending int
	Drift   int
}

// AggregateStatus holds the overall status
type AggregateStatus struct {
	Name      string
	Health    string
	Synced    int
	Failed    int
	Pending   int
	Message   string
	Resources []ResourceSummary
}

func runStatus(cmd *cobra.Command, args []string) error {
	ctx := context.Background()

	if statusWatch {
		return watchStatus(ctx)
	}

	return showStatus(ctx)
}

func showStatus(ctx context.Context) error {
	status, err := collectStatus(ctx)
	if err != nil {
		return err
	}

	return printStatus(status)
}

func watchStatus(ctx context.Context) error {
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	// Show initial status
	if err := showStatus(ctx); err != nil {
		return err
	}

	fmt.Println("\nWatching for changes (Ctrl+C to exit)...")

	for {
		select {
		case <-ctx.Done():
			return nil
		case <-ticker.C:
			// Clear screen and show updated status
			fmt.Print("\033[H\033[2J")
			if err := showStatus(ctx); err != nil {
				fmt.Printf("Error: %v\n", err)
			}
			fmt.Println("\nWatching for changes (Ctrl+C to exit)...")
		}
	}
}

func collectStatus(ctx context.Context) (*AggregateStatus, error) {
	status := &AggregateStatus{
		Name:      "petstore-status",
		Health:    "Healthy",
		Resources: make([]ResourceSummary, 0),
	}
	// Try to get status from StatusAggregate CR if available
	aggregateList, err := k8sClient.List(ctx, "petstoreaggregates")
	if err == nil && len(aggregateList.Items) > 0 {
		// Use the first aggregate found
		agg := aggregateList.Items[0]
		status.Name = agg.GetName()

		// Extract status from aggregate
		aggStatus, found, _ := unstructured.NestedMap(agg.Object, "status")
		if found {
			if health, ok := aggStatus["health"].(string); ok {
				status.Health = health
			}
			if synced, ok := aggStatus["syncedCount"].(int64); ok {
				status.Synced = int(synced)
			}
			if failed, ok := aggStatus["failedCount"].(int64); ok {
				status.Failed = int(failed)
			}
			if pending, ok := aggStatus["pendingCount"].(int64); ok {
				status.Pending = int(pending)
			}
			if msg, ok := aggStatus["message"].(string); ok {
				status.Message = msg
			}
		}
	}

	// Collect per-kind summaries
	kinds := []struct {
		kind   string
		plural string
	}{
		{"Order", "orders"},
		{"Pet", "pets"},
		{"User", "users"},
		{"PetFindbystatusQuery", "petfindbystatusqueries"},
		{"PetFindbytagsQuery", "petfindbytagsqueries"},
		{"StoreInventoryQuery", "storeinventoryqueries"},
		{"UserLoginQuery", "userloginqueries"},
		{"UserLogoutQuery", "userlogoutqueries"},
		{"PetUploadimageAction", "petuploadimageactions"},
		{"UserCreatewithlistAction", "usercreatewithlistactions"},
	}

	for _, k := range kinds {
		summary := ResourceSummary{Kind: k.kind}

		list, err := k8sClient.List(ctx, k.plural)
		if err != nil {
			// Skip kinds that don't exist or we can't access
			continue
		}

		for _, item := range list.Items {
			summary.Total++

			// Get state from status
			state, found, _ := unstructured.NestedString(item.Object, "status", "state")
			if !found {
				summary.Pending++
				continue
			}

			switch state {
			case "Synced", "Queried", "Completed":
				summary.Synced++
			case "Failed", "Error":
				summary.Failed++
			default:
				summary.Pending++
			}

			// Check for drift
			drift, _, _ := unstructured.NestedBool(item.Object, "status", "driftDetected")
			if drift {
				summary.Drift++
			}
		}

		if summary.Total > 0 {
			status.Resources = append(status.Resources, summary)
		}
	}

	// Calculate totals from individual kinds if not from aggregate

	// Determine overall health
	if status.Failed > 0 {
		status.Health = "Degraded"
		status.Message = fmt.Sprintf("%d resources failed", status.Failed)
	} else if status.Pending > 0 {
		status.Health = "Progressing"
		status.Message = fmt.Sprintf("%d resources pending", status.Pending)
	} else if status.Synced > 0 {
		status.Health = "Healthy"
		status.Message = "All resources synced"
	} else {
		status.Health = "Unknown"
		status.Message = "No resources found"
	}

	return status, nil
}

func printStatus(status *AggregateStatus) error {
	switch outputFormat {
	case "json":
		return output.PrintJSON(status)
	case "yaml":
		return output.PrintYAML(status)
	default:
		return printStatusTable(status)
	}
}

func printStatusTable(status *AggregateStatus) error {
	// Print aggregate summary
	fmt.Println("AGGREGATE STATUS")
	fmt.Println()

	headers := []string{"NAME", "HEALTH", "SYNCED", "FAILED", "PENDING", "MESSAGE"}
	rows := [][]string{
		{
			status.Name,
			colorizeHealth(status.Health),
			fmt.Sprintf("%d", status.Synced),
			fmt.Sprintf("%d", status.Failed),
			fmt.Sprintf("%d", status.Pending),
			status.Message,
		},
	}
	output.PrintTable(headers, rows)

	if len(status.Resources) > 0 {
		fmt.Println()
		fmt.Println("RESOURCE SUMMARY")
		fmt.Println()

		headers := []string{"KIND", "TOTAL", "SYNCED", "FAILED", "PENDING", "DRIFT"}
		rows := make([][]string, 0, len(status.Resources))
		for _, r := range status.Resources {
			rows = append(rows, []string{
				r.Kind,
				fmt.Sprintf("%d", r.Total),
				fmt.Sprintf("%d", r.Synced),
				fmt.Sprintf("%d", r.Failed),
				fmt.Sprintf("%d", r.Pending),
				fmt.Sprintf("%d", r.Drift),
			})
		}
		output.PrintTable(headers, rows)
	}

	return nil
}

func colorizeHealth(health string) string {
	switch health {
	case "Healthy":
		return output.Green(health)
	case "Degraded":
		return output.Red(health)
	case "Progressing":
		return output.Yellow(health)
	default:
		return health
	}
}
