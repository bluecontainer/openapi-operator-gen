// Generated by openapi-operator-gen v0.0.9-32-gd89a35c-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package cmd

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/bluecontainer/petstore-operator/kubectl-plugin/pkg/output"
)

var (
	diagnosePod      int
	diagnoseLatency  bool
	diagnoseVerbose  bool
)

var diagnoseCmd = &cobra.Command{
	Use:   "diagnose KIND NAME",
	Short: "Run diagnostics on a petstore resource",
	Long: `Run diagnostic checks on a specific resource to identify issues.

Checks performed:
  - Resource exists in cluster
  - Resource synced with API (has externalID)
  - Drift detection status
  - Last sync time analysis
  - Condition status
  - API connectivity (optional)

Available kinds:
  - order (Order)
  - pet (Pet)
  - user (User)
  - petfindbystatusquery (PetFindbystatusQuery)
  - petfindbytagsquery (PetFindbytagsQuery)
  - storeinventoryquery (StoreInventoryQuery)
  - userloginquery (UserLoginQuery)
  - userlogoutquery (UserLogoutQuery)
  - petuploadimageaction (PetUploadimageAction)
  - usercreatewithlistaction (UserCreatewithlistAction)

Examples:
  # Run diagnostics on a resource
  kubectl petstore diagnose pet fluffy

  # Run diagnostics targeting specific pod
  kubectl petstore diagnose pet fluffy --pod=0

  # Include API latency check
  kubectl petstore diagnose pet fluffy --check-latency

  # Verbose output with all details
  kubectl petstore diagnose pet fluffy --verbose`,
	Args: cobra.ExactArgs(2),
	RunE: runDiagnose,
}

func init() {
	diagnoseCmd.Flags().IntVar(&diagnosePod, "pod", -1, "Target pod ordinal for diagnostics")
	diagnoseCmd.Flags().BoolVar(&diagnoseLatency, "check-latency", false, "Include API latency check")
	diagnoseCmd.Flags().BoolVarP(&diagnoseVerbose, "verbose", "V", false, "Show verbose diagnostic output")
}

// DiagnosticCheck represents a single diagnostic check
type DiagnosticCheck struct {
	Name    string
	Status  string // "passed", "failed", "warning", "skipped"
	Message string
	Details string
}

// DiagnosticResult holds all diagnostic results
type DiagnosticResult struct {
	Kind      string
	Name      string
	Namespace string
	Checks    []DiagnosticCheck
	Passed    int
	Failed    int
	Warnings  int
	Skipped   int
}

func runDiagnose(cmd *cobra.Command, args []string) error {
	ctx := context.Background()
	kindArg := strings.ToLower(args[0])
	name := args[1]

	// Resolve kind to plural form
	plural := resolveKindPlural(kindArg)
	if plural == "" {
		return fmt.Errorf("unknown resource kind: %s", kindArg)
	}

	fmt.Printf("Running diagnostics for %s/%s...\n\n", kindArg, name)

	result := DiagnosticResult{
		Kind:      kindArg,
		Name:      name,
		Namespace: k8sClient.GetNamespace(),
		Checks:    make([]DiagnosticCheck, 0),
	}

	// Check 1: Resource exists
	obj, err := k8sClient.Get(ctx, plural, name)
	if err != nil {
		result.Checks = append(result.Checks, DiagnosticCheck{
			Name:    "Resource exists in cluster",
			Status:  "failed",
			Message: fmt.Sprintf("Resource not found: %v", err),
		})
		result.Failed++
		return printDiagnosticResult(&result)
	}

	result.Checks = append(result.Checks, DiagnosticCheck{
		Name:    "Resource exists in cluster",
		Status:  "passed",
		Message: fmt.Sprintf("Found in namespace %s", obj.GetNamespace()),
	})
	result.Passed++

	// Check 2: Resource synced (has externalID)
	externalID, hasID, _ := unstructured.NestedFieldNoCopy(obj.Object, "status", "externalID")
	if hasID && externalID != nil && externalID != "" {
		result.Checks = append(result.Checks, DiagnosticCheck{
			Name:    "Resource synced with API",
			Status:  "passed",
			Message: fmt.Sprintf("externalID: %v", externalID),
		})
		result.Passed++
	} else {
		state, _, _ := unstructured.NestedString(obj.Object, "status", "state")
		if state == "Failed" {
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Resource synced with API",
				Status:  "failed",
				Message: "No externalID - sync failed",
			})
			result.Failed++
		} else {
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Resource synced with API",
				Status:  "warning",
				Message: "No externalID yet - may be pending sync",
			})
			result.Warnings++
		}
	}

	// Check 3: State check
	state, hasState, _ := unstructured.NestedString(obj.Object, "status", "state")
	if hasState {
		switch state {
		case "Synced":
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Sync state",
				Status:  "passed",
				Message: "State: Synced",
			})
			result.Passed++
		case "Failed", "Error":
			// Get error message if available
			errMsg, _, _ := unstructured.NestedString(obj.Object, "status", "message")
			if errMsg == "" {
				errMsg, _, _ = unstructured.NestedString(obj.Object, "status", "response", "error")
			}
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Sync state",
				Status:  "failed",
				Message: fmt.Sprintf("State: %s", state),
				Details: errMsg,
			})
			result.Failed++
		default:
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Sync state",
				Status:  "warning",
				Message: fmt.Sprintf("State: %s (not synced yet)", state),
			})
			result.Warnings++
		}
	} else {
		result.Checks = append(result.Checks, DiagnosticCheck{
			Name:    "Sync state",
			Status:  "warning",
			Message: "No state information",
		})
		result.Warnings++
	}

	// Check 4: Drift detection
	driftDetected, hasDrift, _ := unstructured.NestedBool(obj.Object, "status", "driftDetected")
	if hasDrift {
		if driftDetected {
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Drift detection",
				Status:  "warning",
				Message: "Drift detected - spec differs from API state",
			})
			result.Warnings++
		} else {
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Drift detection",
				Status:  "passed",
				Message: "No drift detected",
			})
			result.Passed++
		}
	} else {
		result.Checks = append(result.Checks, DiagnosticCheck{
			Name:    "Drift detection",
			Status:  "skipped",
			Message: "Drift detection not available",
		})
		result.Skipped++
	}

	// Check 5: Last sync time
	lastSyncStr, hasLastSync, _ := unstructured.NestedString(obj.Object, "status", "lastSyncTime")
	if hasLastSync && lastSyncStr != "" {
		lastSync, err := time.Parse(time.RFC3339, lastSyncStr)
		if err == nil {
			sinceLast := time.Since(lastSync)
			if sinceLast > 2*time.Hour {
				result.Checks = append(result.Checks, DiagnosticCheck{
					Name:    "Last sync time",
					Status:  "warning",
					Message: fmt.Sprintf("Not synced in %s (consider refreshing)", formatDuration(sinceLast)),
				})
				result.Warnings++
			} else {
				result.Checks = append(result.Checks, DiagnosticCheck{
					Name:    "Last sync time",
					Status:  "passed",
					Message: fmt.Sprintf("Last synced %s ago", formatDuration(sinceLast)),
				})
				result.Passed++
			}
		}
	}

	// Check 6: Conditions
	conditions, hasConditions, _ := unstructured.NestedSlice(obj.Object, "status", "conditions")
	if hasConditions && len(conditions) > 0 {
		failedConditions := 0
		for _, c := range conditions {
			cond, ok := c.(map[string]interface{})
			if !ok {
				continue
			}
			condStatus, _ := cond["status"].(string)
			condType, _ := cond["type"].(string)
			if condStatus == "False" && (condType == "Ready" || condType == "Synced") {
				failedConditions++
			}
		}
		if failedConditions > 0 {
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Conditions",
				Status:  "warning",
				Message: fmt.Sprintf("%d condition(s) not met", failedConditions),
			})
			result.Warnings++
		} else {
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Conditions",
				Status:  "passed",
				Message: fmt.Sprintf("%d condition(s) checked", len(conditions)),
			})
			result.Passed++
		}
	}

	// Check 7: Paused status
	paused, hasPaused, _ := unstructured.NestedBool(obj.Object, "spec", "paused")
	if hasPaused && paused {
		pauseReason, _, _ := unstructured.NestedString(obj.Object, "metadata", "annotations", "kubectl-plugin.example.com/paused-reason")
		msg := "Reconciliation is paused"
		if pauseReason != "" {
			msg = fmt.Sprintf("Reconciliation is paused: %s", pauseReason)
		}
		result.Checks = append(result.Checks, DiagnosticCheck{
			Name:    "Paused status",
			Status:  "warning",
			Message: msg,
		})
		result.Warnings++
	}

	// Check 8: Target pod health (if targeting specific pod)
	if diagnosePod >= 0 {
		targetOrdinal, hasTarget, _ := unstructured.NestedInt64(obj.Object, "spec", "targetPodOrdinal")
		if hasTarget && int(targetOrdinal) != diagnosePod {
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Target pod",
				Status:  "warning",
				Message: fmt.Sprintf("Resource targets pod-%d, but checking pod-%d", targetOrdinal, diagnosePod),
			})
			result.Warnings++
		} else {
			result.Checks = append(result.Checks, DiagnosticCheck{
				Name:    "Target pod",
				Status:  "passed",
				Message: fmt.Sprintf("Targeting pod-%d", diagnosePod),
			})
			result.Passed++
		}
	}

	// Check 9: API latency (optional)
	if diagnoseLatency {
		// This is a placeholder - actual latency check would require hitting the API
		result.Checks = append(result.Checks, DiagnosticCheck{
			Name:    "API latency check",
			Status:  "skipped",
			Message: "API latency check requires operator-side implementation",
		})
		result.Skipped++
	}

	return printDiagnosticResult(&result)
}

func formatDuration(d time.Duration) string {
	if d < time.Minute {
		return fmt.Sprintf("%ds", int(d.Seconds()))
	}
	if d < time.Hour {
		return fmt.Sprintf("%dm", int(d.Minutes()))
	}
	if d < 24*time.Hour {
		hours := int(d.Hours())
		minutes := int(d.Minutes()) % 60
		if minutes > 0 {
			return fmt.Sprintf("%dh%dm", hours, minutes)
		}
		return fmt.Sprintf("%dh", hours)
	}
	days := int(d.Hours() / 24)
	hours := int(d.Hours()) % 24
	if hours > 0 {
		return fmt.Sprintf("%dd%dh", days, hours)
	}
	return fmt.Sprintf("%dd", days)
}

func printDiagnosticResult(result *DiagnosticResult) error {
	switch outputFormat {
	case "json":
		return output.PrintJSON(result)
	case "yaml":
		return output.PrintYAML(result)
	default:
		return printDiagnosticTable(result)
	}
}

func printDiagnosticTable(result *DiagnosticResult) error {
	fmt.Println("CHECKS:")

	for _, check := range result.Checks {
		var icon string
		switch check.Status {
		case "passed":
			icon = output.Green("[✓]")
		case "failed":
			icon = output.Red("[✗]")
		case "warning":
			icon = output.Yellow("[!]")
		case "skipped":
			icon = "[○]"
		}

		fmt.Printf("%s %s: %s\n", icon, check.Name, check.Message)
		if diagnoseVerbose && check.Details != "" {
			fmt.Printf("    Details: %s\n", check.Details)
		}
	}

	fmt.Println()
	fmt.Printf("SUMMARY: %s passed, %s failed, %s warning(s)",
		output.Green(fmt.Sprintf("%d", result.Passed)),
		output.Red(fmt.Sprintf("%d", result.Failed)),
		output.Yellow(fmt.Sprintf("%d", result.Warnings)),
	)
	if result.Skipped > 0 {
		fmt.Printf(", %d skipped", result.Skipped)
	}
	fmt.Println()

	return nil
}
