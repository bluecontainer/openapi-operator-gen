// Generated by openapi-operator-gen v0.0.10-8-g5ef4f69-dirty
// kubectl plugin for petstore operator
// DO NOT EDIT - This file is generated from OpenAPI spec

package output

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/fatih/color"
	"github.com/olekukonko/tablewriter"
	"sigs.k8s.io/yaml"
)

var (
	// Color functions (can be disabled via NO_COLOR env)
	greenColor  = color.New(color.FgGreen)
	redColor    = color.New(color.FgRed)
	yellowColor = color.New(color.FgYellow)
	cyanColor   = color.New(color.FgCyan)
	boldColor   = color.New(color.Bold)

	// Check if colors should be disabled
	noColor = os.Getenv("NO_COLOR") != "" || os.Getenv("TERM") == "dumb"
)

func init() {
	if noColor {
		color.NoColor = true
	}
}

// Green returns the text in green (for success states)
func Green(text string) string {
	if noColor {
		return text
	}
	return greenColor.Sprint(text)
}

// Red returns the text in red (for error states)
func Red(text string) string {
	if noColor {
		return text
	}
	return redColor.Sprint(text)
}

// Yellow returns the text in yellow (for warning states)
func Yellow(text string) string {
	if noColor {
		return text
	}
	return yellowColor.Sprint(text)
}

// Cyan returns the text in cyan (for info)
func Cyan(text string) string {
	if noColor {
		return text
	}
	return cyanColor.Sprint(text)
}

// Bold returns the text in bold
func Bold(text string) string {
	if noColor {
		return text
	}
	return boldColor.Sprint(text)
}

// PrintTable prints data as a formatted table
func PrintTable(headers []string, rows [][]string) {
	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader(headers)
	table.SetAutoWrapText(false)
	table.SetAutoFormatHeaders(true)
	table.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
	table.SetAlignment(tablewriter.ALIGN_LEFT)
	table.SetCenterSeparator("")
	table.SetColumnSeparator("")
	table.SetRowSeparator("")
	table.SetHeaderLine(false)
	table.SetBorder(false)
	table.SetTablePadding("  ")
	table.SetNoWhiteSpace(true)

	table.AppendBulk(rows)
	table.Render()
}

// PrintJSON prints data as JSON
func PrintJSON(data interface{}) error {
	output, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal JSON: %w", err)
	}
	fmt.Println(string(output))
	return nil
}

// PrintYAML prints data as YAML
func PrintYAML(data interface{}) error {
	output, err := yaml.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal YAML: %w", err)
	}
	fmt.Print(string(output))
	return nil
}

// PrintKeyValue prints a key-value pair with proper formatting
func PrintKeyValue(key string, value interface{}, indent int) {
	indentStr := strings.Repeat("  ", indent)
	fmt.Printf("%s%s: %v\n", indentStr, key, value)
}

// PrintSection prints a section header
func PrintSection(title string) {
	fmt.Println()
	fmt.Println(Bold(title))
}

// PrintSuccess prints a success message
func PrintSuccess(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	fmt.Printf("%s %s\n", Green("✓"), msg)
}

// PrintError prints an error message
func PrintError(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	fmt.Printf("%s %s\n", Red("✗"), msg)
}

// PrintWarning prints a warning message
func PrintWarning(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	fmt.Printf("%s %s\n", Yellow("!"), msg)
}

// PrintInfo prints an info message
func PrintInfo(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	fmt.Printf("%s %s\n", Cyan("i"), msg)
}

// Truncate truncates a string to the specified length
func Truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	if maxLen <= 3 {
		return s[:maxLen]
	}
	return s[:maxLen-3] + "..."
}

// FormatDuration formats a duration in a human-readable way
func FormatDuration(seconds int64) string {
	if seconds < 60 {
		return fmt.Sprintf("%ds", seconds)
	}
	if seconds < 3600 {
		return fmt.Sprintf("%dm%ds", seconds/60, seconds%60)
	}
	if seconds < 86400 {
		hours := seconds / 3600
		minutes := (seconds % 3600) / 60
		return fmt.Sprintf("%dh%dm", hours, minutes)
	}
	days := seconds / 86400
	hours := (seconds % 86400) / 3600
	return fmt.Sprintf("%dd%dh", days, hours)
}
