/*
Copyright 2026 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

package main

import (
	"testing"

	"github.com/bluecontainer/openapi-operator-gen/pkg/bundle"
)

func TestIsBundleCR(t *testing.T) {
	tests := []struct {
		name string
		cr   *CRDocument
		want bool
	}{
		{
			name: "nil CR",
			cr:   nil,
			want: false,
		},
		{
			name: "empty resources",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{},
				},
			},
			want: false,
		},
		{
			name: "Aggregate CR with references",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{
						{"kind": "Order", "name": "my-order"},
					},
				},
			},
			want: false,
		},
		{
			name: "Bundle CR with id and spec",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{
						{
							"id":   "order-1",
							"kind": "Order",
							"spec": map[string]interface{}{"name": "test"},
						},
					},
				},
			},
			want: true,
		},
		{
			name: "Bundle CR with multiple resources",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{
						{
							"id":   "order-1",
							"kind": "Order",
							"spec": map[string]interface{}{"name": "order"},
						},
						{
							"id":        "pet-1",
							"kind":      "Pet",
							"spec":      map[string]interface{}{"name": "fluffy"},
							"dependsOn": []interface{}{"order-1"},
						},
					},
				},
			},
			want: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := isBundleCR(tt.cr)
			if got != tt.want {
				t.Errorf("isBundleCR() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestParseBundleResources(t *testing.T) {
	tests := []struct {
		name       string
		cr         *CRDocument
		wantLen    int
		wantErr    bool
		checkFirst func(bundle.ResourceSpec) bool
	}{
		{
			name:    "nil CR",
			cr:      nil,
			wantErr: true,
		},
		{
			name: "missing id",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{
						{"kind": "Order", "spec": map[string]interface{}{}},
					},
				},
			},
			wantErr: true,
		},
		{
			name: "missing kind",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{
						{"id": "order-1", "spec": map[string]interface{}{}},
					},
				},
			},
			wantErr: true,
		},
		{
			name: "missing spec",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{
						{"id": "order-1", "kind": "Order"},
					},
				},
			},
			wantErr: true,
		},
		{
			name: "valid resource",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{
						{
							"id":   "order-1",
							"kind": "Order",
							"spec": map[string]interface{}{"name": "test"},
						},
					},
				},
			},
			wantLen: 1,
			checkFirst: func(r bundle.ResourceSpec) bool {
				return r.ID == "order-1" && r.Kind == "Order"
			},
		},
		{
			name: "resource with dependsOn",
			cr: &CRDocument{
				Spec: CRSpec{
					Resources: []map[string]interface{}{
						{
							"id":        "pet-1",
							"kind":      "Pet",
							"spec":      map[string]interface{}{"name": "fluffy"},
							"dependsOn": []interface{}{"order-1", "user-1"},
						},
					},
				},
			},
			wantLen: 1,
			checkFirst: func(r bundle.ResourceSpec) bool {
				return len(r.DependsOn) == 2 && r.DependsOn[0] == "order-1" && r.DependsOn[1] == "user-1"
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := parseBundleResources(tt.cr)
			if (err != nil) != tt.wantErr {
				t.Errorf("parseBundleResources() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr {
				return
			}
			if len(got) != tt.wantLen {
				t.Errorf("parseBundleResources() returned %d resources, want %d", len(got), tt.wantLen)
			}
			if tt.checkFirst != nil && len(got) > 0 && !tt.checkFirst(got[0]) {
				t.Errorf("parseBundleResources() first resource check failed")
			}
		})
	}
}

func TestBuildExecutionOrder(t *testing.T) {
	tests := []struct {
		name      string
		resources []bundle.ResourceSpec
		wantOrder []string
		wantErr   bool
	}{
		{
			name:      "empty resources",
			resources: []bundle.ResourceSpec{},
			wantOrder: []string{},
		},
		{
			name: "single resource",
			resources: []bundle.ResourceSpec{
				{ID: "order-1", Kind: "Order"},
			},
			wantOrder: []string{"order-1"},
		},
		{
			name: "no dependencies - alphabetical order",
			resources: []bundle.ResourceSpec{
				{ID: "pet-1", Kind: "Pet"},
				{ID: "order-1", Kind: "Order"},
			},
			wantOrder: []string{"order-1", "pet-1"},
		},
		{
			name: "simple dependency chain",
			resources: []bundle.ResourceSpec{
				{ID: "child", Kind: "Pet", DependsOn: []string{"parent"}},
				{ID: "parent", Kind: "Order"},
			},
			wantOrder: []string{"parent", "child"},
		},
		{
			name: "complex dependencies",
			resources: []bundle.ResourceSpec{
				{ID: "grandchild", Kind: "User", DependsOn: []string{"child"}},
				{ID: "child", Kind: "Pet", DependsOn: []string{"parent"}},
				{ID: "parent", Kind: "Order"},
			},
			wantOrder: []string{"parent", "child", "grandchild"},
		},
		{
			name: "circular dependency",
			resources: []bundle.ResourceSpec{
				{ID: "a", Kind: "Order", DependsOn: []string{"b"}},
				{ID: "b", Kind: "Pet", DependsOn: []string{"a"}},
			},
			wantErr: true,
		},
		{
			name: "unknown dependency",
			resources: []bundle.ResourceSpec{
				{ID: "a", Kind: "Order", DependsOn: []string{"nonexistent"}},
			},
			wantErr: true,
		},
		{
			name: "implicit dependency from spec",
			resources: []bundle.ResourceSpec{
				{ID: "child", Kind: "Pet", Spec: map[string]interface{}{
					"name": "child-of-${resources.parent.status.externalID}",
				}},
				{ID: "parent", Kind: "Order"},
			},
			wantOrder: []string{"parent", "child"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := bundle.BuildExecutionOrderSimple(tt.resources)
			if (err != nil) != tt.wantErr {
				t.Errorf("BuildExecutionOrderSimple() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr {
				return
			}
			if len(got) != len(tt.wantOrder) {
				t.Errorf("BuildExecutionOrderSimple() returned %d items, want %d", len(got), len(tt.wantOrder))
				return
			}
			for i, id := range tt.wantOrder {
				if got[i] != id {
					t.Errorf("BuildExecutionOrderSimple()[%d] = %s, want %s", i, got[i], id)
				}
			}
		})
	}
}

func TestExtractDependenciesFromSpec(t *testing.T) {
	tests := []struct {
		name string
		spec map[string]interface{}
		want []string
	}{
		{
			name: "no dependencies",
			spec: map[string]interface{}{"name": "test"},
			want: []string{},
		},
		{
			name: "single dependency",
			spec: map[string]interface{}{
				"name": "child-of-${resources.parent.status.externalID}",
			},
			want: []string{"parent"},
		},
		{
			name: "multiple dependencies",
			spec: map[string]interface{}{
				"name":   "child-of-${resources.parent.status.externalID}",
				"petId":  "${resources.pet.status.externalID}",
				"userId": "${resources.user.status.externalID}",
			},
			want: []string{"parent", "pet", "user"},
		},
		{
			name: "nested spec",
			spec: map[string]interface{}{
				"nested": map[string]interface{}{
					"ref": "${resources.inner.status.field}",
				},
			},
			want: []string{"inner"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := bundle.ExtractDependenciesFromMap(tt.spec, false)

			// Convert to map for easier comparison
			gotMap := make(map[string]bool)
			for _, dep := range got {
				gotMap[dep] = true
			}

			if len(got) != len(tt.want) {
				t.Errorf("ExtractDependenciesFromMap() returned %d deps, want %d", len(got), len(tt.want))
				return
			}

			for _, want := range tt.want {
				if !gotMap[want] {
					t.Errorf("ExtractDependenciesFromMap() missing dependency %s", want)
				}
			}
		})
	}
}

func TestIsValidResourceID(t *testing.T) {
	tests := []struct {
		input string
		want  bool
	}{
		{"order-1", true},
		{"pet", true},
		{"my-resource-123", true},
		{"a", true},
		{"", false},
		{"Order", false},           // uppercase
		{"1order", false},          // starts with number
		{"-order", false},          // starts with hyphen
		{"order_1", false},         // underscore not allowed
		{"order.1", false},         // dot not allowed
		{"order 1", false},         // space not allowed
		{"order-with-CAPS", false}, // uppercase not allowed
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			got := bundle.IsValidResourceID(tt.input)
			if got != tt.want {
				t.Errorf("IsValidResourceID(%q) = %v, want %v", tt.input, got, tt.want)
			}
		})
	}
}

func TestResolveSpecExpressions(t *testing.T) {
	tests := []struct {
		name          string
		spec          map[string]interface{}
		createdStatus map[string]map[string]interface{}
		wantName      string
		wantErr       bool
	}{
		{
			name: "no expressions",
			spec: map[string]interface{}{"name": "test"},
			createdStatus: map[string]map[string]interface{}{
				"parent": {"status": map[string]interface{}{"externalID": "123"}},
			},
			wantName: "test",
		},
		{
			name: "resolve single expression",
			spec: map[string]interface{}{"name": "child-of-${resources.parent.status.externalID}"},
			createdStatus: map[string]map[string]interface{}{
				"parent": {"status": map[string]interface{}{"externalID": "123"}},
			},
			wantName: "child-of-123",
		},
		{
			name: "missing resource - embedded expression left as-is",
			spec: map[string]interface{}{"name": "child-of-${resources.missing.status.externalID}"},
			createdStatus: map[string]map[string]interface{}{
				"parent": {"status": map[string]interface{}{"externalID": "123"}},
			},
			wantName: "child-of-${resources.missing.status.externalID}", // embedded expressions with missing resources are left as-is
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := bundle.ResolveExpressions(tt.spec, tt.createdStatus)
			if (err != nil) != tt.wantErr {
				t.Errorf("ResolveExpressions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr {
				return
			}
			if name, ok := got["name"].(string); ok {
				if name != tt.wantName {
					t.Errorf("ResolveExpressions() name = %s, want %s", name, tt.wantName)
				}
			} else {
				t.Errorf("ResolveExpressions() name field not found or not a string")
			}
		})
	}
}
