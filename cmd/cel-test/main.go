/*
Copyright 2026 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

// cel-test is a CLI utility for testing CEL expressions used in Aggregate and Bundle CRDs.
// It provides an interactive way to validate CEL expressions before deploying to Kubernetes.
//
// Usage:
//
//	cel-test eval "summary.synced * 100 / summary.total"
//	cel-test eval "orders.size()" --data testdata.json
//	cel-test eval "sum(orders.map(r, r.spec.quantity))" --data testdata.json
//	cel-test interactive
package main

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"reflect"
	"strings"
	"syscall"

	"github.com/bluecontainer/openapi-operator-gen/pkg/aggregate"
	"github.com/bluecontainer/openapi-operator-gen/pkg/bundle"
	celutil "github.com/bluecontainer/openapi-operator-gen/pkg/cel"
	"github.com/google/cel-go/cel"
	"github.com/spf13/cobra"
	"golang.org/x/term"
	"gopkg.in/yaml.v3"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
)

// TestData represents the input data structure for CEL evaluation
type TestData struct {
	// Summary contains aggregate counts
	Summary map[string]int64 `json:"summary"`
	// Resources is the list of all resources
	Resources []map[string]interface{} `json:"resources"`
	// KindLists contains kind-specific lists (e.g., "orders", "pets")
	KindLists map[string][]map[string]interface{} `json:"kindLists"`
}

// History manages command history with navigation
type History struct {
	entries []string
	index   int
	maxSize int
}

// NewHistory creates a new history with the specified max size
func NewHistory(maxSize int) *History {
	return &History{
		entries: make([]string, 0, maxSize),
		index:   -1,
		maxSize: maxSize,
	}
}

// Add adds an entry to history
func (h *History) Add(entry string) {
	if entry == "" {
		return
	}
	// Don't add duplicates of the last entry
	if len(h.entries) > 0 && h.entries[len(h.entries)-1] == entry {
		h.Reset()
		return
	}
	h.entries = append(h.entries, entry)
	if len(h.entries) > h.maxSize {
		h.entries = h.entries[1:]
	}
	h.Reset()
}

// Reset resets the navigation index
func (h *History) Reset() {
	h.index = len(h.entries)
}

// Previous returns the previous entry in history
func (h *History) Previous() (string, bool) {
	if h.index > 0 {
		h.index--
		return h.entries[h.index], true
	}
	if h.index == 0 && len(h.entries) > 0 {
		return h.entries[0], true
	}
	return "", false
}

// Next returns the next entry in history
func (h *History) Next() (string, bool) {
	if h.index < len(h.entries)-1 {
		h.index++
		return h.entries[h.index], true
	}
	h.index = len(h.entries)
	return "", true
}

// Len returns the number of entries in history
func (h *History) Len() int {
	return len(h.entries)
}

// CRDocument represents a parsed Aggregate or Bundle CR
type CRDocument struct {
	APIVersion string                 `yaml:"apiVersion" json:"apiVersion"`
	Kind       string                 `yaml:"kind" json:"kind"`
	Metadata   map[string]interface{} `yaml:"metadata" json:"metadata"`
	Spec       CRSpec                 `yaml:"spec" json:"spec"`
	Status     CRStatus               `yaml:"status" json:"status"`
}

// CRSpec represents the spec of an Aggregate or Bundle CR
type CRSpec struct {
	Resources         []map[string]interface{} `yaml:"resources" json:"resources"`
	ResourceSelectors []map[string]interface{} `yaml:"resourceSelectors" json:"resourceSelectors"`
	DerivedValues     []DerivedValue           `yaml:"derivedValues" json:"derivedValues"`
}

// DerivedValue represents a CEL expression definition from the CR
type DerivedValue struct {
	Name       string `yaml:"name" json:"name"`
	Expression string `yaml:"expression" json:"expression"`
}

// CRStatus represents the status of an Aggregate or Bundle CR
type CRStatus struct {
	State     string                   `yaml:"state" json:"state"`
	Summary   map[string]int64         `yaml:"summary" json:"summary"`
	Resources []map[string]interface{} `yaml:"resources" json:"resources"`
}

// CreatedResource tracks a resource created by cel-test
type CreatedResource struct {
	ID        string
	Kind      string
	Name      string
	Namespace string
	Status    map[string]interface{}
}

var (
	dataFile      string
	crFile        string
	resourcesFile string
	mockData      bool
	showHelp      bool
	kindVars      []string
	summaryJSON   string
	historySize   int
	loadedCR      *CRDocument
	derivedValues []DerivedValue

	// Kubernetes flags
	kubeconfig    string
	kubeNamespace string
	apiGroup      string
	apiVersion    string
	useEnvtest    bool
	crdPaths      []string
	evalExpr      string
	outputFile    string
	outputYAML    string

	// Envtest environment (kept alive for the session)
	testEnv    *envtest.Environment
	restConfig *rest.Config

	// CR from Kubernetes
	crName string // Format: Kind/Name (e.g., PetstoreAggregate/my-aggregate)

	// Interactive session state
	interactiveSelectors []map[string]interface{} // Resource selectors added via :select
	interactiveResources []map[string]interface{} // Explicit resources added via :resource
	interactiveClient    dynamic.Interface        // Kubernetes client for interactive session
	interactiveCleanup   func()                   // Cleanup function for interactive session
)

func main() {
	rootCmd := &cobra.Command{
		Use:   "cel-test",
		Short: "Test CEL expressions for Aggregate and Bundle CRDs",
		Long: `cel-test is a CLI utility for testing CEL expressions used in openapi-operator-gen
Aggregate and Bundle CRDs. It allows you to validate CEL expressions before
deploying to Kubernetes.

Available variables in expressions:
  - resources: list of all resource objects
  - summary: map with total, synced, failed, pending, skipped counts
  - <kind>s: kind-specific lists (e.g., orders, pets, users)

Available aggregate functions:
  - sum(list): sum of numeric values
  - max(list): maximum value
  - min(list): minimum value
  - avg(list): average value

Examples:
  cel-test eval "summary.synced * 100 / summary.total"
  cel-test eval "orders.size()" --kinds orders,pets --data testdata.json
  cel-test eval "sum(orders.map(r, r.spec.quantity))" --data testdata.json
  cel-test eval "summary.total" --cr-name PetstoreAggregate/my-agg --api-group petstore.example.com -n default
  cel-test interactive`,
	}

	evalCmd := &cobra.Command{
		Use:   "eval [expression]",
		Short: "Evaluate a single CEL expression",
		Args:  cobra.ExactArgs(1),
		RunE:  runEval,
	}
	evalCmd.Flags().StringVarP(&dataFile, "data", "d", "", "JSON file with test data")
	evalCmd.Flags().StringVarP(&crFile, "cr", "c", "", "Aggregate/Bundle CR YAML file (uses status for test data)")
	evalCmd.Flags().StringVar(&crName, "cr-name", "", "Fetch CR from Kubernetes by Kind/Name (e.g., PetstoreAggregate/my-aggregate)")
	evalCmd.Flags().StringVarP(&resourcesFile, "resources", "r", "", "YAML file with referenced child CRs (provides spec data)")
	evalCmd.Flags().BoolVarP(&mockData, "mock", "m", false, "Generate mock status data from CR resourceSelectors")
	evalCmd.Flags().StringSliceVarP(&kindVars, "kinds", "k", []string{}, "Kind variable names (e.g., orders,pets,users)")
	evalCmd.Flags().StringVarP(&summaryJSON, "summary", "s", "", "Summary JSON (e.g., '{\"total\":10,\"synced\":8}')")
	// Kubernetes flags for eval
	evalCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file (defaults to ~/.kube/config)")
	evalCmd.Flags().StringVarP(&kubeNamespace, "namespace", "n", "", "Kubernetes namespace to fetch from")
	evalCmd.Flags().StringVar(&apiGroup, "api-group", "", "API group for fetching resources from Kubernetes (required with --cr-name)")
	evalCmd.Flags().StringVar(&apiVersion, "api-version", "v1alpha1", "API version for fetching resources from Kubernetes")
	evalCmd.Flags().BoolVar(&useEnvtest, "envtest", false, "Use envtest instead of real cluster")
	evalCmd.Flags().StringSliceVar(&crdPaths, "crd-paths", []string{}, "Paths to CRD YAML files (required with --envtest)")

	interactiveCmd := &cobra.Command{
		Use:   "interactive",
		Short: "Start interactive CEL expression testing",
		Long: `Start interactive CEL expression testing with history support.

Use arrow keys to navigate history:
  - Up Arrow: Previous command
  - Down Arrow: Next command
  - Ctrl+C: Cancel current input
  - Ctrl+D: Exit`,
		RunE: runInteractive,
	}
	interactiveCmd.Flags().StringVarP(&dataFile, "data", "d", "", "JSON file with test data")
	interactiveCmd.Flags().StringVarP(&crFile, "cr", "c", "", "Aggregate/Bundle CR YAML file (uses status for test data)")
	interactiveCmd.Flags().StringVar(&crName, "cr-name", "", "Fetch CR from Kubernetes by Kind/Name (e.g., PetstoreAggregate/my-aggregate)")
	interactiveCmd.Flags().StringVarP(&resourcesFile, "resources", "r", "", "YAML file with referenced child CRs (provides spec data)")
	interactiveCmd.Flags().BoolVarP(&mockData, "mock", "m", false, "Generate mock status data from CR resourceSelectors")
	interactiveCmd.Flags().StringSliceVarP(&kindVars, "kinds", "k", []string{}, "Kind variable names (e.g., orders,pets,users)")
	interactiveCmd.Flags().IntVar(&historySize, "history-size", 100, "Maximum number of history entries")
	// Kubernetes flags for interactive
	interactiveCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file (defaults to ~/.kube/config)")
	interactiveCmd.Flags().StringVarP(&kubeNamespace, "namespace", "n", "", "Kubernetes namespace to fetch from")
	interactiveCmd.Flags().StringVar(&apiGroup, "api-group", "", "API group for fetching resources from Kubernetes (required with --cr-name)")
	interactiveCmd.Flags().StringVar(&apiVersion, "api-version", "v1alpha1", "API version for fetching resources from Kubernetes")
	interactiveCmd.Flags().BoolVar(&useEnvtest, "envtest", false, "Use envtest instead of real cluster")
	interactiveCmd.Flags().StringSliceVar(&crdPaths, "crd-paths", []string{}, "Paths to CRD YAML files (required with --envtest)")

	exampleCmd := &cobra.Command{
		Use:   "example",
		Short: "Generate example test data file",
		RunE:  runExample,
	}

	expressionsCmd := &cobra.Command{
		Use:   "expressions",
		Short: "List and evaluate derived value expressions from a CR",
		Long: `Read an Aggregate or Bundle CR YAML file and list or evaluate all
derivedValues expressions defined in the spec.

If a --data file is provided, it evaluates each expression against that data.
If --cr is provided with status data, uses that for evaluation.`,
		RunE: runExpressions,
	}
	expressionsCmd.Flags().StringVarP(&crFile, "cr", "c", "", "Aggregate/Bundle CR YAML file")
	expressionsCmd.Flags().StringVar(&crName, "cr-name", "", "Fetch CR from Kubernetes by Kind/Name (e.g., PetstoreAggregate/my-aggregate)")
	expressionsCmd.Flags().StringVarP(&dataFile, "data", "d", "", "JSON file with test data for evaluation")
	expressionsCmd.Flags().StringVarP(&resourcesFile, "resources", "r", "", "YAML file with referenced child CRs (provides spec data)")
	expressionsCmd.Flags().BoolVarP(&mockData, "mock", "m", false, "Generate mock status data from CR resourceSelectors")
	expressionsCmd.Flags().StringSliceVarP(&kindVars, "kinds", "k", []string{}, "Kind variable names (e.g., orders,pets,users)")
	// Kubernetes flags for expressions
	expressionsCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file (defaults to ~/.kube/config)")
	expressionsCmd.Flags().StringVarP(&kubeNamespace, "namespace", "n", "", "Kubernetes namespace to fetch from")
	expressionsCmd.Flags().StringVar(&apiGroup, "api-group", "", "API group for fetching resources from Kubernetes (required with --cr-name)")
	expressionsCmd.Flags().StringVar(&apiVersion, "api-version", "v1alpha1", "API version for fetching resources from Kubernetes")
	expressionsCmd.Flags().BoolVar(&useEnvtest, "envtest", false, "Use envtest instead of real cluster")
	expressionsCmd.Flags().StringSliceVar(&crdPaths, "crd-paths", []string{}, "Paths to CRD YAML files (required with --envtest)")

	// Fetch command - retrieves resources from Kubernetes cluster
	fetchCmd := &cobra.Command{
		Use:   "fetch",
		Short: "Fetch resources from Kubernetes cluster for CEL testing",
		Long: `Fetch resources from a Kubernetes cluster and use them as test data for CEL expressions.

This command connects to a Kubernetes cluster (via kubeconfig or envtest) and fetches
resources of the specified kinds to use as CEL test data.

Examples:
  # Fetch from current kubeconfig context
  cel-test fetch --kinds Order,Pet,User --api-group petstore.example.com

  # Fetch from a specific namespace
  cel-test fetch --kinds Order,Pet --namespace my-namespace --api-group petstore.example.com

  # Use envtest (for testing without a real cluster)
  cel-test fetch --envtest --crd-paths ./config/crd/bases --kinds Order,Pet

  # Fetch and evaluate an expression
  cel-test fetch --kinds Order --api-group petstore.example.com --eval "orders.size()"

  # Save fetched resources as YAML (for use with --resources flag)
  cel-test fetch --kinds Order,Pet --api-group petstore.example.com --output-yaml resources.yaml`,
		RunE: runFetch,
	}
	fetchCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file (defaults to ~/.kube/config)")
	fetchCmd.Flags().StringVarP(&kubeNamespace, "namespace", "n", "", "Kubernetes namespace to fetch from (defaults to all namespaces)")
	fetchCmd.Flags().StringVar(&apiGroup, "api-group", "", "API group for the resources (e.g., petstore.example.com)")
	fetchCmd.Flags().StringVar(&apiVersion, "api-version", "v1alpha1", "API version for the resources")
	fetchCmd.Flags().StringSliceVarP(&kindVars, "kinds", "k", []string{}, "Resource kinds to fetch (e.g., Order,Pet,User)")
	fetchCmd.Flags().BoolVar(&useEnvtest, "envtest", false, "Use envtest instead of real cluster")
	fetchCmd.Flags().StringSliceVar(&crdPaths, "crd-paths", []string{}, "Paths to CRD YAML files (required with --envtest)")
	fetchCmd.Flags().StringVarP(&crFile, "cr", "c", "", "Aggregate/Bundle CR YAML file to get kinds from")
	fetchCmd.Flags().StringVar(&crName, "cr-name", "", "Fetch CR from Kubernetes by Kind/Name to get kinds from (e.g., PetstoreAggregate/my-aggregate)")
	fetchCmd.Flags().StringVarP(&evalExpr, "eval", "e", "", "CEL expression to evaluate after fetching")
	fetchCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file to save fetched data as JSON (for use with --data)")
	fetchCmd.Flags().StringVar(&outputYAML, "output-yaml", "", "Output file to save fetched resources as YAML (for use with --resources)")
	fetchCmd.MarkFlagRequired("api-group")

	rootCmd.AddCommand(evalCmd, interactiveCmd, exampleCmd, expressionsCmd, fetchCmd)

	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func runEval(cmd *cobra.Command, args []string) error {
	expression := args[0]

	testData, err := loadTestData()
	if err != nil {
		return fmt.Errorf("failed to load test data: %w", err)
	}

	env, err := createCELEnv(testData)
	if err != nil {
		return fmt.Errorf("failed to create CEL environment: %w", err)
	}

	result, err := evaluateExpression(env, expression, testData)
	if err != nil {
		return fmt.Errorf("evaluation error: %w", err)
	}

	fmt.Printf("Expression: %s\n", expression)
	fmt.Printf("Result: %v\n", result)
	fmt.Printf("Type: %s\n", reflect.TypeOf(result))

	return nil
}

func runInteractive(cmd *cobra.Command, args []string) error {
	testData, err := loadTestData()
	if err != nil {
		return fmt.Errorf("failed to load test data: %w", err)
	}

	env, err := createCELEnv(testData)
	if err != nil {
		return fmt.Errorf("failed to create CEL environment: %w", err)
	}

	fmt.Println("CEL Expression Tester - Interactive Mode")
	fmt.Println("========================================")
	fmt.Println("Type CEL expressions to evaluate. Type 'help' for available variables.")
	fmt.Println("Type 'data' to show current test data. Type 'exit' or 'quit' to exit.")
	fmt.Println("Use Up/Down arrows to navigate history. Ctrl+C to cancel, Ctrl+D to exit.")
	fmt.Println()

	history := NewHistory(historySize)

	// Check if we have a terminal for raw mode
	if !term.IsTerminal(int(os.Stdin.Fd())) {
		return runInteractiveFallback(env, testData, history)
	}

	// Set up signal handling for clean exit
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigChan
		fmt.Println("\nGoodbye!")
		os.Exit(0)
	}()

	for {
		input, err := readLineWithHistory(history)
		if err != nil {
			if err.Error() == "EOF" {
				fmt.Println("\nGoodbye!")
				return nil
			}
			return err
		}

		input = strings.TrimSpace(input)
		if input == "" {
			continue
		}

		// Add to history before processing
		history.Add(input)

		// Handle commands (start with : or are simple keywords)
		lowerInput := strings.ToLower(input)
		switch {
		case lowerInput == "exit" || lowerInput == "quit" || lowerInput == "q":
			if interactiveCleanup != nil {
				interactiveCleanup()
			}
			fmt.Println("Goodbye!")
			return nil
		case lowerInput == "help" || lowerInput == "h" || lowerInput == "?":
			printInteractiveHelp(testData)
			continue
		case lowerInput == "data":
			printData(testData)
			continue
		case lowerInput == "history":
			printHistory(history)
			continue
		case lowerInput == "reload":
			testData, err = loadTestData()
			if err != nil {
				fmt.Printf("Error reloading data: %v\n", err)
			} else {
				env, _ = createCELEnv(testData)
				fmt.Println("Data reloaded.")
			}
			continue
		case lowerInput == "expressions" || lowerInput == "expr":
			printExpressions(env, testData)
			continue
		case strings.HasPrefix(input, ":use "):
			// :use Kind/Name - Select an Aggregate/Bundle CR from Kubernetes
			testData, env, err = handleUseCommand(input[5:], testData)
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			}
			continue
		case strings.HasPrefix(input, ":select "):
			// :select kind=X [labels=k=v,...] [pattern=regex] - Add a resource selector
			handleSelectCommand(input[8:])
			continue
		case strings.HasPrefix(input, ":resource "):
			// :resource kind=X name=Y [namespace=Z] - Add an explicit resource reference
			handleResourceCommand(input[10:])
			continue
		case lowerInput == ":fetch":
			// :fetch - Fetch resources based on current selectors
			testData, env, err = handleFetchCommand(testData)
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			}
			continue
		case lowerInput == ":clear":
			// :clear - Clear current selectors
			handleClearCommand()
			continue
		case lowerInput == ":selectors" || lowerInput == ":show":
			// :selectors - Show current selectors and resources
			printSelectors()
			continue
		case lowerInput == ":cr":
			// :cr - Show current CR info
			printCRInfo()
			continue
		case strings.HasPrefix(input, ":create"):
			// :create - Create child resources from Bundle CR
			dryRun := strings.Contains(input, "--dry-run")
			testData, env, err = handleCreateCommand(testData, dryRun)
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			}
			continue
		case strings.HasPrefix(input, ":"):
			fmt.Printf("Unknown command: %s (type 'help' for available commands)\n", input)
			continue
		}

		result, err := evaluateExpression(env, input, testData)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		} else {
			fmt.Printf("=> %v (%s)\n", result, reflect.TypeOf(result))
		}
	}
}

// runInteractiveFallback runs interactive mode without history navigation when not in a terminal
func runInteractiveFallback(env *cel.Env, testData *TestData, history *History) error {
	fmt.Println("(Running in basic mode - no history navigation)")
	fmt.Println()

	// Use a simple line reader for non-terminal input
	var input string
	for {
		fmt.Print("cel> ")
		_, err := fmt.Scanln(&input)
		if err != nil {
			if err.Error() == "EOF" || err.Error() == "unexpected newline" {
				continue
			}
			fmt.Println("\nGoodbye!")
			return nil
		}

		input = strings.TrimSpace(input)
		if input == "" {
			continue
		}

		history.Add(input)

		switch strings.ToLower(input) {
		case "exit", "quit", "q":
			fmt.Println("Goodbye!")
			return nil
		case "help", "h", "?":
			printHelp(testData)
			continue
		case "data":
			printData(testData)
			continue
		case "history":
			printHistory(history)
			continue
		case "reload":
			var reloadErr error
			testData, reloadErr = loadTestData()
			if reloadErr != nil {
				fmt.Printf("Error reloading data: %v\n", reloadErr)
			} else {
				env, _ = createCELEnv(testData)
				fmt.Println("Data reloaded.")
			}
			continue
		case "expressions", "expr":
			printExpressions(env, testData)
			continue
		}

		result, evalErr := evaluateExpression(env, input, testData)
		if evalErr != nil {
			fmt.Printf("Error: %v\n", evalErr)
		} else {
			fmt.Printf("=> %v (%s)\n", result, reflect.TypeOf(result))
		}
	}
}

// readLineWithHistory reads a line with history navigation support
func readLineWithHistory(history *History) (string, error) {
	oldState, err := term.MakeRaw(int(os.Stdin.Fd()))
	if err != nil {
		return "", fmt.Errorf("failed to set raw mode: %w", err)
	}
	defer term.Restore(int(os.Stdin.Fd()), oldState)

	fmt.Print("cel> ")

	var line []byte
	cursorPos := 0
	history.Reset()

	buf := make([]byte, 1)
	for {
		_, err := os.Stdin.Read(buf)
		if err != nil {
			return "", err
		}

		switch buf[0] {
		case 3: // Ctrl+C
			fmt.Print("\r\n")
			history.Reset()
			return "", nil
		case 4: // Ctrl+D (EOF)
			fmt.Print("\r\n")
			return "", fmt.Errorf("EOF")
		case 13, 10: // Enter
			fmt.Print("\r\n")
			return string(line), nil
		case 127, 8: // Backspace
			if cursorPos > 0 {
				// Remove character at cursor position
				line = append(line[:cursorPos-1], line[cursorPos:]...)
				cursorPos--
				// Redraw line
				fmt.Print("\r\033[K") // Clear line
				fmt.Print("cel> ")
				fmt.Print(string(line))
				// Move cursor to correct position
				if cursorPos < len(line) {
					fmt.Printf("\033[%dD", len(line)-cursorPos)
				}
			}
		case 27: // Escape sequence
			// Read the next two bytes for arrow keys
			seq := make([]byte, 2)
			os.Stdin.Read(seq)
			if seq[0] == '[' {
				switch seq[1] {
				case 'A': // Up arrow
					if entry, ok := history.Previous(); ok {
						line = []byte(entry)
						cursorPos = len(line)
						fmt.Print("\r\033[K") // Clear line
						fmt.Print("cel> ")
						fmt.Print(string(line))
					}
				case 'B': // Down arrow
					if entry, ok := history.Next(); ok {
						line = []byte(entry)
						cursorPos = len(line)
						fmt.Print("\r\033[K") // Clear line
						fmt.Print("cel> ")
						fmt.Print(string(line))
					}
				case 'C': // Right arrow
					if cursorPos < len(line) {
						cursorPos++
						fmt.Print("\033[C")
					}
				case 'D': // Left arrow
					if cursorPos > 0 {
						cursorPos--
						fmt.Print("\033[D")
					}
				case '3': // Delete key (followed by ~)
					delSeq := make([]byte, 1)
					os.Stdin.Read(delSeq)
					if delSeq[0] == '~' && cursorPos < len(line) {
						line = append(line[:cursorPos], line[cursorPos+1:]...)
						// Redraw line
						fmt.Print("\r\033[K")
						fmt.Print("cel> ")
						fmt.Print(string(line))
						if cursorPos < len(line) {
							fmt.Printf("\033[%dD", len(line)-cursorPos)
						}
					}
				case 'H': // Home
					if cursorPos > 0 {
						fmt.Printf("\033[%dD", cursorPos)
						cursorPos = 0
					}
				case 'F': // End
					if cursorPos < len(line) {
						fmt.Printf("\033[%dC", len(line)-cursorPos)
						cursorPos = len(line)
					}
				}
			}
		case 1: // Ctrl+A (Home)
			if cursorPos > 0 {
				fmt.Printf("\033[%dD", cursorPos)
				cursorPos = 0
			}
		case 5: // Ctrl+E (End)
			if cursorPos < len(line) {
				fmt.Printf("\033[%dC", len(line)-cursorPos)
				cursorPos = len(line)
			}
		case 21: // Ctrl+U (Clear line before cursor)
			line = line[cursorPos:]
			cursorPos = 0
			fmt.Print("\r\033[K")
			fmt.Print("cel> ")
			fmt.Print(string(line))
		case 11: // Ctrl+K (Clear line after cursor)
			line = line[:cursorPos]
			fmt.Print("\r\033[K")
			fmt.Print("cel> ")
			fmt.Print(string(line))
		case 23: // Ctrl+W (Delete word before cursor)
			if cursorPos > 0 {
				// Find start of previous word
				newPos := cursorPos - 1
				for newPos > 0 && line[newPos] == ' ' {
					newPos--
				}
				for newPos > 0 && line[newPos-1] != ' ' {
					newPos--
				}
				line = append(line[:newPos], line[cursorPos:]...)
				cursorPos = newPos
				fmt.Print("\r\033[K")
				fmt.Print("cel> ")
				fmt.Print(string(line))
				if cursorPos < len(line) {
					fmt.Printf("\033[%dD", len(line)-cursorPos)
				}
			}
		case 12: // Ctrl+L (Clear screen)
			fmt.Print("\033[2J\033[H") // Clear screen and move to top
			fmt.Print("cel> ")
			fmt.Print(string(line))
		default:
			if buf[0] >= 32 && buf[0] < 127 { // Printable ASCII
				// Insert character at cursor position
				line = append(line[:cursorPos], append([]byte{buf[0]}, line[cursorPos:]...)...)
				cursorPos++
				// Redraw from cursor position
				fmt.Print("\r\033[K")
				fmt.Print("cel> ")
				fmt.Print(string(line))
				if cursorPos < len(line) {
					fmt.Printf("\033[%dD", len(line)-cursorPos)
				}
			}
		}
	}
}

func printHistory(history *History) {
	if history.Len() == 0 {
		fmt.Println("No history entries.")
		return
	}
	fmt.Println("\nCommand History:")
	for i, entry := range history.entries {
		fmt.Printf("  %3d  %s\n", i+1, entry)
	}
	fmt.Println()
}

func runExample(cmd *cobra.Command, args []string) error {
	example := TestData{
		Summary: map[string]int64{
			"total":   10,
			"synced":  7,
			"failed":  2,
			"pending": 1,
			"skipped": 0,
		},
		Resources: []map[string]interface{}{
			{
				"kind": "Order",
				"metadata": map[string]interface{}{
					"name":      "order-1",
					"namespace": "default",
				},
				"spec": map[string]interface{}{
					"quantity": 5,
					"petId":    "123",
				},
				"status": map[string]interface{}{
					"state":      "Synced",
					"externalID": "ext-1",
				},
			},
			{
				"kind": "Order",
				"metadata": map[string]interface{}{
					"name":      "order-2",
					"namespace": "default",
				},
				"spec": map[string]interface{}{
					"quantity": 10,
					"petId":    "456",
				},
				"status": map[string]interface{}{
					"state":      "Synced",
					"externalID": "ext-2",
				},
			},
			{
				"kind": "Pet",
				"metadata": map[string]interface{}{
					"name":      "fluffy",
					"namespace": "default",
				},
				"spec": map[string]interface{}{
					"name":   "Fluffy",
					"status": "available",
				},
				"status": map[string]interface{}{
					"state":      "Synced",
					"externalID": "123",
				},
			},
			{
				"kind": "Pet",
				"metadata": map[string]interface{}{
					"name":      "buddy",
					"namespace": "default",
				},
				"spec": map[string]interface{}{
					"name":   "Buddy",
					"status": "pending",
				},
				"status": map[string]interface{}{
					"state":      "Failed",
					"externalID": "",
					"message":    "API error",
				},
			},
		},
		KindLists: map[string][]map[string]interface{}{
			"orders": {
				{
					"kind": "Order",
					"metadata": map[string]interface{}{
						"name":      "order-1",
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"quantity": 5,
						"petId":    "123",
					},
					"status": map[string]interface{}{
						"state":      "Synced",
						"externalID": "ext-1",
					},
				},
				{
					"kind": "Order",
					"metadata": map[string]interface{}{
						"name":      "order-2",
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"quantity": 10,
						"petId":    "456",
					},
					"status": map[string]interface{}{
						"state":      "Synced",
						"externalID": "ext-2",
					},
				},
			},
			"pets": {
				{
					"kind": "Pet",
					"metadata": map[string]interface{}{
						"name":      "fluffy",
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"name":   "Fluffy",
						"status": "available",
					},
					"status": map[string]interface{}{
						"state":      "Synced",
						"externalID": "123",
					},
				},
				{
					"kind": "Pet",
					"metadata": map[string]interface{}{
						"name":      "buddy",
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"name":   "Buddy",
						"status": "pending",
					},
					"status": map[string]interface{}{
						"state":      "Failed",
						"externalID": "",
						"message":    "API error",
					},
				},
			},
		},
	}

	data, err := json.MarshalIndent(example, "", "  ")
	if err != nil {
		return err
	}

	fmt.Println(string(data))
	fmt.Fprintln(os.Stderr, "\n# Save this to a file and use with: cel-test eval --data testdata.json \"expression\"")
	return nil
}

// loadCRFile loads an Aggregate or Bundle CR from a YAML file
// It handles multi-document YAML files and returns the first document with derivedValues
func loadCRFile(filename string) (*CRDocument, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read CR file: %w", err)
	}

	// Split by YAML document separator and find one with derivedValues
	scanner := bufio.NewScanner(strings.NewReader(string(data)))
	scanner.Split(splitYAMLDocuments)

	var bestDoc *CRDocument
	for scanner.Scan() {
		docData := scanner.Text()
		if strings.TrimSpace(docData) == "" {
			continue
		}

		var doc CRDocument
		if err := yaml.Unmarshal([]byte(docData), &doc); err != nil {
			continue // Skip invalid documents
		}

		// Check if this is an Aggregate or Bundle
		if !strings.HasSuffix(doc.Kind, "Aggregate") && !strings.HasSuffix(doc.Kind, "Bundle") {
			continue
		}

		// Prefer documents with derivedValues
		if len(doc.Spec.DerivedValues) > 0 {
			return &doc, nil
		}

		// Keep first valid Aggregate/Bundle as fallback
		if bestDoc == nil {
			bestDoc = &doc
		}
	}

	if bestDoc != nil {
		return bestDoc, nil
	}

	// Try parsing as single document
	var doc CRDocument
	if err := yaml.Unmarshal(data, &doc); err != nil {
		return nil, fmt.Errorf("failed to parse CR YAML: %w", err)
	}

	return &doc, nil
}

// splitYAMLDocuments is a bufio.SplitFunc that splits YAML documents
func splitYAMLDocuments(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}

	// Look for document separator "---"
	sep := []byte("\n---")
	if i := strings.Index(string(data), string(sep)); i >= 0 {
		return i + len(sep), data[:i], nil
	}

	// If at EOF, return remaining data
	if atEOF {
		return len(data), data, nil
	}

	// Request more data
	return 0, nil, nil
}

// ResourceCR represents a parsed child resource CR (Order, Pet, User, etc.)
type ResourceCR struct {
	APIVersion string                 `yaml:"apiVersion" json:"apiVersion"`
	Kind       string                 `yaml:"kind" json:"kind"`
	Metadata   map[string]interface{} `yaml:"metadata" json:"metadata"`
	Spec       map[string]interface{} `yaml:"spec" json:"spec"`
	Status     map[string]interface{} `yaml:"status" json:"status"`
}

// loadResourcesCRs loads child resource CRs from a multi-document YAML file
// Returns a map keyed by "kind/namespace/name" for lookup
func loadResourcesCRs(filename string) (map[string]*ResourceCR, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read resources file: %w", err)
	}

	resources := make(map[string]*ResourceCR)

	// Split by YAML document separator
	scanner := bufio.NewScanner(strings.NewReader(string(data)))
	scanner.Split(splitYAMLDocuments)

	for scanner.Scan() {
		docData := scanner.Text()
		if strings.TrimSpace(docData) == "" {
			continue
		}

		var cr ResourceCR
		if err := yaml.Unmarshal([]byte(docData), &cr); err != nil {
			continue // Skip invalid documents
		}

		// Skip if no kind or metadata
		if cr.Kind == "" || cr.Metadata == nil {
			continue
		}

		// Skip Aggregate/Bundle CRs - we only want child resources
		if strings.HasSuffix(cr.Kind, "Aggregate") || strings.HasSuffix(cr.Kind, "Bundle") {
			continue
		}

		// Build lookup key: kind/namespace/name
		name, _ := cr.Metadata["name"].(string)
		namespace, _ := cr.Metadata["namespace"].(string)
		if namespace == "" {
			namespace = "default"
		}
		key := fmt.Sprintf("%s/%s/%s", cr.Kind, namespace, name)
		resources[key] = &cr
	}

	return resources, nil
}

// generateMockDataFromCR generates mock test data based on CR resourceSelectors
// This allows testing expressions without actual status data
func generateMockDataFromCR(cr *CRDocument) *TestData {
	testData := &TestData{
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	// Use shared summary counter for consistent state classification
	var summaryCounter celutil.SummaryCounter

	// Collect kinds from resourceSelectors and explicit resources
	kinds := make(map[string]bool)

	for _, selector := range cr.Spec.ResourceSelectors {
		if kind, ok := selector["kind"].(string); ok {
			kinds[kind] = true
		}
	}

	for _, res := range cr.Spec.Resources {
		if kind, ok := res["kind"].(string); ok {
			kinds[kind] = true
		}
	}

	// Generate 4 resources per kind (2 synced, 1 failed, 1 pending)
	states := []struct {
		state   string
		count   int
		message string
	}{
		{"Synced", 2, "Successfully synced with API"},
		{"Failed", 1, "API returned error"},
		{"Pending", 1, "Waiting for API response"},
	}

	resourceNum := 1
	for kind := range kinds {
		kindLower := strings.ToLower(kind)
		kindKey := kindLower + "s"

		for _, stateInfo := range states {
			for i := 0; i < stateInfo.count; i++ {
				resource := map[string]interface{}{
					"kind": kind,
					"metadata": map[string]interface{}{
						"name":      fmt.Sprintf("%s-%03d", kindLower, resourceNum),
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"id":   resourceNum,
						"name": fmt.Sprintf("Mock %s %d", kind, resourceNum),
					},
					"status": map[string]interface{}{
						"state":   stateInfo.state,
						"message": stateInfo.message,
					},
				}

				if stateInfo.state == "Synced" {
					resource["status"].(map[string]interface{})["externalID"] = fmt.Sprintf("ext-%s-%03d", kindLower, resourceNum)
				} else {
					resource["status"].(map[string]interface{})["externalID"] = ""
				}

				testData.Resources = append(testData.Resources, resource)
				testData.KindLists[kindKey] = append(testData.KindLists[kindKey], resource)

				// Update summary using shared classification logic
				summaryCounter.Add(stateInfo.state)

				resourceNum++
			}
		}
	}

	// Set summary from counter
	testData.Summary = summaryCounter.ToMap()

	return testData
}

// convertCRStatusToTestData converts CR status to TestData format
// If resourceCRs is provided, it looks up spec data from the child CRs
func convertCRStatusToTestData(cr *CRDocument, resourceCRs map[string]*ResourceCR) *TestData {
	testData := &TestData{
		Summary: map[string]int64{
			"total":   0,
			"synced":  0,
			"failed":  0,
			"pending": 0,
			"skipped": 0,
		},
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	// Copy summary if present
	if cr.Status.Summary != nil {
		for k, v := range cr.Status.Summary {
			testData.Summary[k] = v
		}
	}

	// Convert resources - the CR status resources have a different structure
	// than what CEL expects, so we need to transform them
	for _, res := range cr.Status.Resources {
		kindStr, _ := res["kind"].(string)
		nameStr, _ := res["name"].(string)
		namespaceStr, _ := res["namespace"].(string)
		if namespaceStr == "" {
			namespaceStr = "default"
		}

		// Build a resource object that matches what CEL expects
		resource := map[string]interface{}{
			"kind": kindStr,
			"metadata": map[string]interface{}{
				"name":      nameStr,
				"namespace": namespaceStr,
			},
			"status": map[string]interface{}{
				"state":      res["state"],
				"externalID": res["externalID"],
				"message":    res["message"],
			},
			// Default to empty spec
			"spec": map[string]interface{}{},
		}

		// Look up spec from resourceCRs if available
		if resourceCRs != nil {
			key := fmt.Sprintf("%s/%s/%s", kindStr, namespaceStr, nameStr)
			if childCR, found := resourceCRs[key]; found && childCR.Spec != nil {
				resource["spec"] = childCR.Spec
				// Also merge any additional metadata (labels, annotations)
				if meta, ok := resource["metadata"].(map[string]interface{}); ok {
					if labels, ok := childCR.Metadata["labels"]; ok {
						meta["labels"] = labels
					}
					if annotations, ok := childCR.Metadata["annotations"]; ok {
						meta["annotations"] = annotations
					}
				}
			}
		}

		testData.Resources = append(testData.Resources, resource)

		// Build kind-specific lists
		if kindStr != "" {
			kindKey := aggregate.KindToVariableName(kindStr)
			testData.KindLists[kindKey] = append(testData.KindLists[kindKey], resource)
		}
	}

	return testData
}

func loadTestData() (*TestData, error) {
	testData := &TestData{
		Summary: map[string]int64{
			"total":   0,
			"synced":  0,
			"failed":  0,
			"pending": 0,
			"skipped": 0,
		},
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	// Load child resource CRs if --resources flag is provided
	var resourceCRs map[string]*ResourceCR
	if resourcesFile != "" {
		var err error
		resourceCRs, err = loadResourcesCRs(resourcesFile)
		if err != nil {
			return nil, fmt.Errorf("failed to load resources file: %w", err)
		}
	}

	// Load from CR file or Kubernetes if specified
	if crFile != "" || crName != "" {
		cr, cleanup, err := loadCRFromClusterOrFile()
		if err != nil {
			return nil, fmt.Errorf("failed to load CR: %w", err)
		}
		if cleanup != nil {
			defer cleanup()
		}
		if cr != nil {
			loadedCR = cr
			derivedValues = cr.Spec.DerivedValues

			// If --mock flag is set, generate mock data from CR spec
			if mockData {
				testData = generateMockDataFromCR(cr)
			} else if apiGroup != "" {
				// If --api-group is provided, fetch live resources based on CR's spec
				// This uses the CR's resources and resourceSelectors to select which resources to fetch
				client, kubeCleanup, err := getKubernetesClient()
				if err != nil {
					return nil, fmt.Errorf("failed to get Kubernetes client: %w", err)
				}
				if kubeCleanup != nil {
					defer kubeCleanup()
				}

				kubeData, err := fetchResourcesFromCR(client, cr)
				if err != nil {
					return nil, fmt.Errorf("failed to fetch resources from Kubernetes: %w", err)
				}

				// Print summary of fetched resources
				fmt.Printf("Fetched %d resources from Kubernetes based on CR selectors:\n", len(kubeData.Resources))
				for kind, resources := range kubeData.KindLists {
					fmt.Printf("  %s: %d\n", kind, len(resources))
				}
				fmt.Println()

				testData = kubeData
			} else if len(cr.Status.Resources) > 0 || cr.Status.Summary != nil {
				// Fall back to CR's cached status data if no --api-group
				testData = convertCRStatusToTestData(cr, resourceCRs)
			}
		}
	}

	// Load from JSON data file if specified (can override or supplement CR data)
	if dataFile != "" {
		data, err := os.ReadFile(dataFile)
		if err != nil {
			return nil, fmt.Errorf("failed to read data file: %w", err)
		}
		if err := json.Unmarshal(data, testData); err != nil {
			return nil, fmt.Errorf("failed to parse data file: %w", err)
		}
	}

	// Fetch from Kubernetes if --api-group is provided with explicit --kinds (no CR)
	if apiGroup != "" && loadedCR == nil && len(kindVars) > 0 {
		kubeData, cleanup, err := loadTestDataFromKubernetes()
		if err != nil {
			return nil, fmt.Errorf("failed to fetch from Kubernetes: %w", err)
		}
		if cleanup != nil {
			defer cleanup()
		}
		if kubeData != nil {
			testData = kubeData
		}
	}

	// Override summary if provided via flag
	if summaryJSON != "" {
		if err := json.Unmarshal([]byte(summaryJSON), &testData.Summary); err != nil {
			return nil, fmt.Errorf("failed to parse summary JSON: %w", err)
		}
	}

	// Initialize kind lists from flag if not in data file
	for _, kind := range kindVars {
		if _, exists := testData.KindLists[kind]; !exists {
			testData.KindLists[kind] = []map[string]interface{}{}
		}
	}

	// If no data file and no CR status, create some default test data
	if dataFile == "" && crFile == "" && apiGroup == "" && len(testData.Resources) == 0 {
		testData.Summary = map[string]int64{
			"total":   5,
			"synced":  3,
			"failed":  1,
			"pending": 1,
			"skipped": 0,
		}
	}

	return testData, nil
}

// loadTestDataFromKubernetes fetches resources from Kubernetes for use in eval/expressions/interactive
func loadTestDataFromKubernetes() (*TestData, func(), error) {
	// Determine which kinds to fetch
	kinds := kindVars

	// If no kinds specified, try to get them from the loaded CR
	if len(kinds) == 0 && loadedCR != nil {
		kindSet := make(map[string]bool)
		for _, selector := range loadedCR.Spec.ResourceSelectors {
			if kind, ok := selector["kind"].(string); ok {
				kindSet[kind] = true
			}
		}
		for _, res := range loadedCR.Spec.Resources {
			if kind, ok := res["kind"].(string); ok {
				kindSet[kind] = true
			}
		}
		for kind := range kindSet {
			kinds = append(kinds, kind)
		}
	}

	if len(kinds) == 0 {
		return nil, nil, fmt.Errorf("no kinds specified: use --kinds flag or --cr with resourceSelectors")
	}

	// Get Kubernetes client
	client, cleanup, err := getKubernetesClient()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get Kubernetes client: %w", err)
	}

	// Fetch resources
	testData, err := fetchResourcesFromCluster(client, kinds)
	if err != nil {
		if cleanup != nil {
			cleanup()
		}
		return nil, nil, fmt.Errorf("failed to fetch resources: %w", err)
	}

	// Print summary of fetched resources
	fmt.Printf("Fetched %d resources from Kubernetes:\n", len(testData.Resources))
	for kind, resources := range testData.KindLists {
		fmt.Printf("  %s: %d\n", kind, len(resources))
	}
	fmt.Println()

	return testData, cleanup, nil
}

// runExpressions lists and evaluates derived value expressions from a CR
func runExpressions(cmd *cobra.Command, args []string) error {
	// Load the CR from file or Kubernetes
	if crFile == "" && crName == "" {
		return fmt.Errorf("either --cr or --cr-name is required")
	}

	cr, cleanup, err := loadCRFromClusterOrFile()
	if err != nil {
		return fmt.Errorf("failed to load CR: %w", err)
	}
	if cleanup != nil {
		defer cleanup()
	}

	if len(cr.Spec.DerivedValues) == 0 {
		fmt.Println("No derivedValues expressions found in the CR.")
		return nil
	}

	// Load test data for evaluation
	testData, err := loadTestData()
	if err != nil {
		return fmt.Errorf("failed to load test data: %w", err)
	}

	// Create CEL environment
	env, err := createCELEnv(testData)
	if err != nil {
		return fmt.Errorf("failed to create CEL environment: %w", err)
	}

	fmt.Printf("CR: %s/%s (%s)\n", cr.Kind, cr.Metadata["name"], cr.APIVersion)
	fmt.Printf("Found %d derived value expression(s):\n\n", len(cr.Spec.DerivedValues))

	hasData := len(testData.Resources) > 0 || testData.Summary["total"] > 0

	for i, dv := range cr.Spec.DerivedValues {
		fmt.Printf("%d. %s\n", i+1, dv.Name)
		fmt.Printf("   Expression: %s\n", dv.Expression)

		if hasData {
			result, evalErr := evaluateExpression(env, dv.Expression, testData)
			if evalErr != nil {
				fmt.Printf("   Error: %v\n", evalErr)
			} else {
				fmt.Printf("   Result: %v (%s)\n", result, reflect.TypeOf(result))
			}
		} else {
			fmt.Printf("   (No test data available for evaluation)\n")
		}
		fmt.Println()
	}

	if !hasData {
		fmt.Println("Tip: Provide test data with --data <file.json> to evaluate expressions")
	}

	return nil
}

func createCELEnv(testData *TestData) (*cel.Env, error) {
	// Extract kind names from the KindLists map
	kindNames := make([]string, 0, len(testData.KindLists))
	for kindName := range testData.KindLists {
		kindNames = append(kindNames, kindName)
	}

	// Collect resource-specific keys using {kind}_{name} convention
	resourceKeys := celutil.CollectResourceKeys(testData.Resources)

	// Use the shared CEL environment factory with resource-specific variables
	return celutil.NewEnvironmentWithResources(kindNames, resourceKeys)
}

func evaluateExpression(env *cel.Env, expression string, testData *TestData) (interface{}, error) {
	// Build evaluation variables using the shared helper (includes resource-specific variables)
	vars := celutil.BuildVariablesWithResources(testData.Resources, testData.Summary, testData.KindLists)

	// Use the shared evaluation function
	result := celutil.Evaluate(env, expression, vars)
	if result.Error != nil {
		return nil, result.Error
	}

	return result.Value, nil
}

func printHelp(testData *TestData) {
	fmt.Println("\nAvailable Variables:")
	fmt.Println("  resources  - List of all resource objects")
	fmt.Println("  summary    - Map with counts: total, synced, failed, pending, skipped")

	if len(testData.KindLists) > 0 {
		fmt.Println("\nKind-specific Lists:")
		for kindName := range testData.KindLists {
			fmt.Printf("  %s - List of %s resources\n", kindName, kindName)
		}
	}

	// Show resource-specific variables
	resourceKeys := celutil.CollectResourceKeys(testData.Resources)
	if len(resourceKeys) > 0 {
		fmt.Println("\nResource-specific Variables (direct access via {kind}_{name}):")
		for _, key := range resourceKeys {
			fmt.Printf("  %s\n", key)
		}
	}

	fmt.Println("\nAggregate Functions:")
	fmt.Println("  sum(list)  - Sum of numeric values in the list")
	fmt.Println("  max(list)  - Maximum value in the list")
	fmt.Println("  min(list)  - Minimum value in the list")
	fmt.Println("  avg(list)  - Average of values in the list")

	fmt.Println("\nExample Expressions:")
	fmt.Println("  summary.total")
	fmt.Println("  summary.synced * 100 / summary.total")
	fmt.Println("  resources.size()")
	fmt.Println("  resources.filter(r, r.status.state == 'Synced').size()")
	if _, ok := testData.KindLists["orders"]; ok {
		fmt.Println("  orders.size()")
		fmt.Println("  sum(orders.map(r, r.spec.quantity))")
		fmt.Println("  max(orders.map(r, has(r.spec.quantity) ? r.spec.quantity : 0))")
	}
	// Add example for resource-specific variable if available
	if len(resourceKeys) > 0 {
		fmt.Printf("  %s.status.state  (direct access to specific resource)\n", resourceKeys[0])
	}

	fmt.Println("\nKeyboard Shortcuts:")
	fmt.Println("  Up/Down    - Navigate command history")
	fmt.Println("  Left/Right - Move cursor")
	fmt.Println("  Ctrl+A     - Move to beginning of line")
	fmt.Println("  Ctrl+E     - Move to end of line")
	fmt.Println("  Ctrl+U     - Clear line before cursor")
	fmt.Println("  Ctrl+K     - Clear line after cursor")
	fmt.Println("  Ctrl+W     - Delete word before cursor")
	fmt.Println("  Ctrl+L     - Clear screen")
	fmt.Println("  Ctrl+C     - Cancel current input")
	fmt.Println("  Ctrl+D     - Exit")

	fmt.Println("\nCommands:")
	fmt.Println("  help, h, ?     - Show this help")
	fmt.Println("  data           - Show current test data")
	fmt.Println("  expressions    - Show and evaluate derived value expressions from CR")
	fmt.Println("  history        - Show command history")
	fmt.Println("  reload         - Reload test data from file")
	fmt.Println("  exit, quit     - Exit interactive mode")
	fmt.Println()
}

func printData(testData *TestData) {
	data, _ := json.MarshalIndent(testData, "", "  ")
	fmt.Println(string(data))
}

// printExpressions prints and evaluates derived value expressions from the loaded CR
func printExpressions(env *cel.Env, testData *TestData) {
	if len(derivedValues) == 0 {
		fmt.Println("No derived value expressions loaded.")
		fmt.Println("Use --cr flag to load an Aggregate/Bundle CR with derivedValues.")
		return
	}

	fmt.Printf("\nDerived Value Expressions (%d):\n", len(derivedValues))
	for i, dv := range derivedValues {
		fmt.Printf("\n%d. %s\n", i+1, dv.Name)
		fmt.Printf("   Expression: %s\n", dv.Expression)

		result, err := evaluateExpression(env, dv.Expression, testData)
		if err != nil {
			fmt.Printf("   Error: %v\n", err)
		} else {
			fmt.Printf("   Result: %v (%s)\n", result, reflect.TypeOf(result))
		}
	}
	fmt.Println()
}

// ==================== Kubernetes Functions ====================

// runFetch fetches resources from Kubernetes and uses them for CEL testing
func runFetch(cmd *cobra.Command, args []string) error {
	// Determine which kinds to fetch
	kinds := kindVars

	// Extract kinds from CR if provided (from file or Kubernetes)
	if len(kinds) == 0 && (crFile != "" || crName != "") {
		cr, crCleanup, err := loadCRFromClusterOrFile()
		if err != nil {
			return fmt.Errorf("failed to load CR: %w", err)
		}
		if crCleanup != nil {
			defer crCleanup()
		}
		if cr != nil {
			kindSet := make(map[string]bool)
			for _, selector := range cr.Spec.ResourceSelectors {
				if kind, ok := selector["kind"].(string); ok {
					kindSet[kind] = true
				}
			}
			for _, res := range cr.Spec.Resources {
				if kind, ok := res["kind"].(string); ok {
					kindSet[kind] = true
				}
			}
			for kind := range kindSet {
				kinds = append(kinds, kind)
			}
		}
	}

	if len(kinds) == 0 {
		return fmt.Errorf("no kinds specified: use --kinds flag, --cr, or --cr-name with resourceSelectors")
	}

	// Get Kubernetes client
	client, cleanup, err := getKubernetesClient()
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes client: %w", err)
	}
	if cleanup != nil {
		defer cleanup()
	}

	// Fetch resources
	testData, err := fetchResourcesFromCluster(client, kinds)
	if err != nil {
		return fmt.Errorf("failed to fetch resources: %w", err)
	}

	// Print summary
	fmt.Printf("Fetched %d resources from cluster:\n", len(testData.Resources))
	for kind, resources := range testData.KindLists {
		fmt.Printf("  %s: %d\n", kind, len(resources))
	}
	fmt.Printf("\nSummary:\n")
	fmt.Printf("  Total: %d\n", testData.Summary["total"])
	fmt.Printf("  Synced: %d\n", testData.Summary["synced"])
	fmt.Printf("  Failed: %d\n", testData.Summary["failed"])
	fmt.Printf("  Pending: %d\n", testData.Summary["pending"])
	fmt.Println()

	// If --eval flag provided, evaluate the expression
	if evalExpr != "" {
		env, err := createCELEnv(testData)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment: %w", err)
		}

		result, err := evaluateExpression(env, evalExpr, testData)
		if err != nil {
			return fmt.Errorf("evaluation error: %w", err)
		}

		fmt.Printf("Expression: %s\n", evalExpr)
		fmt.Printf("Result: %v\n", result)
		fmt.Printf("Type: %s\n", reflect.TypeOf(result))
		return nil
	}

	// If --output-yaml flag provided, save resources as multi-document YAML
	if outputYAML != "" {
		yamlData, err := resourcesToYAML(testData.Resources)
		if err != nil {
			return fmt.Errorf("failed to marshal resources to YAML: %w", err)
		}
		if err := os.WriteFile(outputYAML, []byte(yamlData), 0644); err != nil {
			return fmt.Errorf("failed to write YAML file: %w", err)
		}
		fmt.Printf("Resources saved to: %s\n", outputYAML)
		fmt.Println("Use with: cel-test eval --cr aggregate.yaml --resources", outputYAML, "\"expression\"")
		return nil
	}

	// Output as JSON
	data, err := json.MarshalIndent(testData, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal test data: %w", err)
	}

	// If --output flag provided, save to file
	if outputFile != "" {
		if err := os.WriteFile(outputFile, data, 0644); err != nil {
			return fmt.Errorf("failed to write output file: %w", err)
		}
		fmt.Printf("Test data saved to: %s\n", outputFile)
		fmt.Println("Use with: cel-test eval --data", outputFile, "\"expression\"")
	} else {
		fmt.Println("# Test data JSON (use with --data flag or --output to save):")
		fmt.Println(string(data))
	}

	return nil
}

// getKubernetesClient returns a dynamic Kubernetes client and optional cleanup function
func getKubernetesClient() (dynamic.Interface, func(), error) {
	var cfg *rest.Config
	var cleanup func()
	var err error

	if useEnvtest {
		cfg, cleanup, err = setupEnvtest()
		if err != nil {
			return nil, nil, fmt.Errorf("failed to setup envtest: %w", err)
		}
	} else {
		cfg, err = getKubeconfig()
		if err != nil {
			return nil, nil, fmt.Errorf("failed to get kubeconfig: %w", err)
		}
	}

	client, err := dynamic.NewForConfig(cfg)
	if err != nil {
		if cleanup != nil {
			cleanup()
		}
		return nil, nil, fmt.Errorf("failed to create dynamic client: %w", err)
	}

	return client, cleanup, nil
}

// getKubeconfig returns a Kubernetes REST config from kubeconfig file
func getKubeconfig() (*rest.Config, error) {
	var kubeconfigPath string

	if kubeconfig != "" {
		kubeconfigPath = kubeconfig
	} else if home := homedir.HomeDir(); home != "" {
		kubeconfigPath = filepath.Join(home, ".kube", "config")
	}

	// Try in-cluster config first if no explicit kubeconfig
	if kubeconfigPath == "" {
		cfg, err := rest.InClusterConfig()
		if err == nil {
			return cfg, nil
		}
	}

	// Build config from kubeconfig file
	cfg, err := clientcmd.BuildConfigFromFlags("", kubeconfigPath)
	if err != nil {
		return nil, fmt.Errorf("failed to build config from kubeconfig: %w", err)
	}

	return cfg, nil
}

// setupEnvtest sets up an envtest environment with CRDs
func setupEnvtest() (*rest.Config, func(), error) {
	if len(crdPaths) == 0 {
		return nil, nil, fmt.Errorf("--crd-paths required when using --envtest")
	}

	testEnv = &envtest.Environment{
		CRDDirectoryPaths:     crdPaths,
		ErrorIfCRDPathMissing: true,
	}

	cfg, err := testEnv.Start()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to start envtest: %w", err)
	}

	restConfig = cfg

	cleanup := func() {
		if testEnv != nil {
			testEnv.Stop()
		}
	}

	fmt.Println("Started envtest environment")
	return cfg, cleanup, nil
}

// parseCRName parses a CR name in the format "Kind/Name" and returns the kind and name
func parseCRName(crNameStr string) (kind, name string, err error) {
	parts := strings.SplitN(crNameStr, "/", 2)
	if len(parts) != 2 {
		return "", "", fmt.Errorf("invalid --cr-name format: expected 'Kind/Name' (e.g., PetstoreAggregate/my-aggregate), got %q", crNameStr)
	}
	kind = parts[0]
	name = parts[1]
	if kind == "" || name == "" {
		return "", "", fmt.Errorf("invalid --cr-name format: both kind and name are required, got %q", crNameStr)
	}
	return kind, name, nil
}

// fetchCRFromCluster fetches a CR from Kubernetes by kind and name
func fetchCRFromCluster(client dynamic.Interface, kind, name, namespace string) (*CRDocument, error) {
	if apiGroup == "" {
		return nil, fmt.Errorf("--api-group is required when using --cr-name")
	}

	// Build GVR for the CR
	// The resource name is the lowercase plural of the kind
	resourceName := aggregate.KindToResourceName(kind)
	gvr := schema.GroupVersionResource{
		Group:    apiGroup,
		Version:  apiVersion,
		Resource: resourceName,
	}

	ctx := context.Background()

	var obj *unstructured.Unstructured
	var err error

	if namespace != "" {
		obj, err = client.Resource(gvr).Namespace(namespace).Get(ctx, name, metav1.GetOptions{})
	} else {
		// Try namespaced first with "default", then cluster-scoped
		obj, err = client.Resource(gvr).Namespace("default").Get(ctx, name, metav1.GetOptions{})
		if err != nil {
			// Try cluster-scoped
			obj, err = client.Resource(gvr).Get(ctx, name, metav1.GetOptions{})
		}
	}

	if err != nil {
		return nil, fmt.Errorf("failed to get %s/%s: %w", kind, name, err)
	}

	// Convert unstructured to CRDocument
	cr, err := unstructuredToCRDocument(obj)
	if err != nil {
		return nil, fmt.Errorf("failed to convert CR to document: %w", err)
	}

	return cr, nil
}

// unstructuredToCRDocument converts an unstructured Kubernetes object to a CRDocument
func unstructuredToCRDocument(obj *unstructured.Unstructured) (*CRDocument, error) {
	// Marshal to JSON and unmarshal to CRDocument
	jsonData, err := obj.MarshalJSON()
	if err != nil {
		return nil, fmt.Errorf("failed to marshal unstructured object: %w", err)
	}

	var doc CRDocument
	if err := json.Unmarshal(jsonData, &doc); err != nil {
		return nil, fmt.Errorf("failed to unmarshal to CRDocument: %w", err)
	}

	return &doc, nil
}

// loadCRFromClusterOrFile loads a CR either from Kubernetes (if --cr-name is set) or from a file (if --cr is set)
func loadCRFromClusterOrFile() (*CRDocument, func(), error) {
	// If --cr-name is provided, fetch from Kubernetes
	if crName != "" {
		kind, name, err := parseCRName(crName)
		if err != nil {
			return nil, nil, err
		}

		client, cleanup, err := getKubernetesClient()
		if err != nil {
			return nil, nil, fmt.Errorf("failed to get Kubernetes client: %w", err)
		}

		cr, err := fetchCRFromCluster(client, kind, name, kubeNamespace)
		if err != nil {
			if cleanup != nil {
				cleanup()
			}
			return nil, nil, err
		}

		fmt.Printf("Fetched %s/%s from Kubernetes\n", kind, name)
		return cr, cleanup, nil
	}

	// Otherwise, load from file
	if crFile != "" {
		cr, err := loadCRFile(crFile)
		if err != nil {
			return nil, nil, err
		}
		return cr, nil, nil
	}

	return nil, nil, nil
}

// fetchResourcesFromCluster fetches resources of specified kinds from the cluster
func fetchResourcesFromCluster(client dynamic.Interface, kinds []string) (*TestData, error) {
	testData := &TestData{
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	// Use shared summary counter for consistent state classification
	var summaryCounter celutil.SummaryCounter

	ctx := context.Background()

	for _, kind := range kinds {
		// Build GVR for the resource
		gvr := schema.GroupVersionResource{
			Group:    apiGroup,
			Version:  apiVersion,
			Resource: aggregate.KindToResourceName(kind),
		}

		var list *unstructured.UnstructuredList
		var err error

		if kubeNamespace != "" {
			list, err = client.Resource(gvr).Namespace(kubeNamespace).List(ctx, metav1.ListOptions{})
		} else {
			list, err = client.Resource(gvr).List(ctx, metav1.ListOptions{})
		}

		if err != nil {
			fmt.Printf("Warning: failed to list %s: %v\n", kind, err)
			continue
		}

		kindKey := aggregate.KindToVariableName(kind)
		testData.KindLists[kindKey] = []map[string]interface{}{}

		for _, item := range list.Items {
			resource := convertUnstructuredToResource(&item, kind)
			testData.Resources = append(testData.Resources, resource)
			testData.KindLists[kindKey] = append(testData.KindLists[kindKey], resource)

			// Update summary based on status using shared classification logic
			state := ""
			if status, ok := resource["status"].(map[string]interface{}); ok {
				if s, ok := status["state"].(string); ok {
					state = s
				}
			}
			summaryCounter.Add(state)
		}
	}

	// Set summary from counter
	testData.Summary = summaryCounter.ToMap()

	return testData, nil
}

// fetchResourcesFromCR fetches resources based on the CR's spec.resources and spec.resourceSelectors
// This mimics what the actual controller does when aggregating resources
func fetchResourcesFromCR(client dynamic.Interface, cr *CRDocument) (*TestData, error) {
	testData := &TestData{
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	var summaryCounter celutil.SummaryCounter
	ctx := context.Background()

	// Create a dynamic fetcher using the shared package
	fetcher := aggregate.NewDynamicFetcher(client, apiGroup, apiVersion)

	// Get CR's namespace as default
	crNamespace := ""
	if meta, ok := cr.Metadata["namespace"].(string); ok {
		crNamespace = meta
	}

	// Helper to add a resource to testData
	addResource := func(item *unstructured.Unstructured, kind string) {
		resource := convertUnstructuredToResource(item, kind)
		testData.Resources = append(testData.Resources, resource)

		kindKey := aggregate.KindToVariableName(kind)
		if testData.KindLists[kindKey] == nil {
			testData.KindLists[kindKey] = []map[string]interface{}{}
		}
		testData.KindLists[kindKey] = append(testData.KindLists[kindKey], resource)

		// Update summary
		state := ""
		if status, ok := resource["status"].(map[string]interface{}); ok {
			if s, ok := status["state"].(string); ok {
				state = s
			}
		}
		summaryCounter.Add(state)
	}

	// Track which resources we've already added (to avoid duplicates)
	seen := make(map[string]bool)

	// 1. Process explicit resource references (spec.resources)
	for _, refMap := range cr.Spec.Resources {
		ref := aggregate.ParseResourceReference(refMap)
		if !ref.IsValid() {
			continue
		}

		namespace := aggregate.DefaultNamespace(ref.Namespace, crNamespace)
		fmt.Printf("Fetching %s/%s from namespace %s...\n", ref.Kind, ref.Name, namespace)

		item, err := fetcher.GetResource(ctx, ref, crNamespace)
		if err != nil {
			fmt.Printf("Warning: failed to get %s/%s in namespace %s: %v\n", ref.Kind, ref.Name, namespace, err)
			continue
		}

		key := aggregate.ResourceKey(ref.Kind, namespace, ref.Name)
		if !seen[key] {
			seen[key] = true
			addResource(item, ref.Kind)
		}
	}

	// 2. Process resource selectors (spec.resourceSelectors)
	for _, selMap := range cr.Spec.ResourceSelectors {
		sel := aggregate.ParseResourceSelector(selMap)
		if !sel.IsValid() {
			continue
		}

		compiled, err := aggregate.CompileSelector(sel)
		if err != nil {
			fmt.Printf("Warning: %v\n", err)
			continue
		}

		// Determine namespace for listing
		namespace := kubeNamespace
		if namespace == "" {
			namespace = aggregate.DefaultNamespace("", crNamespace)
		}

		list, err := fetcher.ListResources(ctx, compiled, namespace)
		if err != nil {
			fmt.Printf("Warning: failed to list %s: %v\n", sel.Kind, err)
			continue
		}

		// Filter by name pattern and add to results
		filtered := fetcher.FilterByNamePattern(list, compiled)
		for i := range filtered {
			item := &filtered[i]
			key := aggregate.ResourceKey(sel.Kind, item.GetNamespace(), item.GetName())
			if !seen[key] {
				seen[key] = true
				addResource(item, sel.Kind)
			}
		}
	}

	// Set summary from counter
	testData.Summary = summaryCounter.ToMap()

	return testData, nil
}

// convertUnstructuredToResource converts an unstructured Kubernetes resource to our map format
func convertUnstructuredToResource(u *unstructured.Unstructured, kind string) map[string]interface{} {
	resource := map[string]interface{}{
		"kind": kind,
		"metadata": map[string]interface{}{
			"name":      u.GetName(),
			"namespace": u.GetNamespace(),
		},
		"spec":   map[string]interface{}{},
		"status": map[string]interface{}{},
	}

	// Copy labels and annotations if present
	if labels := u.GetLabels(); len(labels) > 0 {
		resource["metadata"].(map[string]interface{})["labels"] = labels
	}
	if annotations := u.GetAnnotations(); len(annotations) > 0 {
		resource["metadata"].(map[string]interface{})["annotations"] = annotations
	}

	// Copy spec
	if spec, found, _ := unstructured.NestedMap(u.Object, "spec"); found {
		resource["spec"] = spec
	}

	// Copy status
	if status, found, _ := unstructured.NestedMap(u.Object, "status"); found {
		resource["status"] = status
	}

	return resource
}

// resourcesToYAML converts a list of resources to multi-document YAML format
// The output format is compatible with the --resources flag
func resourcesToYAML(resources []map[string]interface{}) (string, error) {
	if len(resources) == 0 {
		return "# No resources found\n", nil
	}

	var builder strings.Builder
	builder.WriteString("# Generated by cel-test fetch\n")
	builder.WriteString("# Use with: cel-test eval --cr <aggregate.yaml> --resources <this-file>\n")

	for i, res := range resources {
		if i > 0 {
			builder.WriteString("---\n")
		}

		// Build a proper CR structure
		cr := map[string]interface{}{
			"apiVersion": fmt.Sprintf("%s/%s", apiGroup, apiVersion),
			"kind":       res["kind"],
			"metadata":   res["metadata"],
			"spec":       res["spec"],
		}

		// Include status if present and non-empty
		if status, ok := res["status"].(map[string]interface{}); ok && len(status) > 0 {
			cr["status"] = status
		}

		yamlBytes, err := yaml.Marshal(cr)
		if err != nil {
			return "", fmt.Errorf("failed to marshal resource %v: %w", res["metadata"], err)
		}
		builder.Write(yamlBytes)
	}

	return builder.String(), nil
}

// ==================== Interactive Command Handlers ====================

// printInteractiveHelp prints extended help for interactive mode including new commands
func printInteractiveHelp(testData *TestData) {
	fmt.Println("\nAvailable Variables:")
	fmt.Println("  resources  - List of all resource objects")
	fmt.Println("  summary    - Map with counts: total, synced, failed, pending, skipped")

	if len(testData.KindLists) > 0 {
		fmt.Println("\nKind-specific Lists:")
		for kindName := range testData.KindLists {
			fmt.Printf("  %s - List of %s resources\n", kindName, kindName)
		}
	}

	fmt.Println("\nAggregate Functions:")
	fmt.Println("  sum(list)  - Sum of numeric values in the list")
	fmt.Println("  max(list)  - Maximum value in the list")
	fmt.Println("  min(list)  - Minimum value in the list")
	fmt.Println("  avg(list)  - Average of values in the list")

	fmt.Println("\nExample Expressions:")
	fmt.Println("  summary.total")
	fmt.Println("  summary.synced * 100 / summary.total")
	fmt.Println("  resources.size()")
	fmt.Println("  resources.filter(r, r.status.state == 'Synced').size()")
	if _, ok := testData.KindLists["orders"]; ok {
		fmt.Println("  orders.size()")
		fmt.Println("  sum(orders.map(r, r.spec.quantity))")
	}

	fmt.Println("\nKeyboard Shortcuts:")
	fmt.Println("  Up/Down    - Navigate command history")
	fmt.Println("  Left/Right - Move cursor")
	fmt.Println("  Ctrl+A     - Move to beginning of line")
	fmt.Println("  Ctrl+E     - Move to end of line")
	fmt.Println("  Ctrl+U     - Clear line before cursor")
	fmt.Println("  Ctrl+K     - Clear line after cursor")
	fmt.Println("  Ctrl+W     - Delete word before cursor")
	fmt.Println("  Ctrl+L     - Clear screen")
	fmt.Println("  Ctrl+C     - Cancel current input")
	fmt.Println("  Ctrl+D     - Exit")

	fmt.Println("\nBasic Commands:")
	fmt.Println("  help, h, ?     - Show this help")
	fmt.Println("  data           - Show current test data")
	fmt.Println("  expressions    - Show and evaluate derived value expressions from CR")
	fmt.Println("  history        - Show command history")
	fmt.Println("  reload         - Reload test data from file")
	fmt.Println("  exit, quit     - Exit interactive mode")

	fmt.Println("\nKubernetes Commands:")
	fmt.Println("  :use Kind/Name         - Select an Aggregate/Bundle CR from Kubernetes")
	fmt.Println("                           Example: :use PetstoreAggregate/my-aggregate")
	fmt.Println("  :select kind=X [labels=k=v,...] [pattern=regex]")
	fmt.Println("                         - Add a resource selector (like resourceSelectors)")
	fmt.Println("                           Example: :select kind=Order")
	fmt.Println("                           Example: :select kind=Pet labels=env=prod")
	fmt.Println("                           Example: :select kind=Order pattern=^test-")
	fmt.Println("  :resource kind=X name=Y [namespace=Z]")
	fmt.Println("                         - Add an explicit resource reference")
	fmt.Println("                           Example: :resource kind=Order name=my-order")
	fmt.Println("  :fetch                 - Fetch resources from Kubernetes based on selectors")
	fmt.Println("  :clear                 - Clear all selectors and resource references")
	fmt.Println("  :selectors             - Show current selectors and references")
	fmt.Println("  :cr                    - Show loaded CR info")

	fmt.Println("\nBundle Commands:")
	fmt.Println("  :create                - Create child resources from Bundle CR")
	fmt.Println("  :create --dry-run      - Show what would be created without creating")
	fmt.Println()
}

// handleUseCommand handles the :use Kind/Name command to select a CR from Kubernetes
func handleUseCommand(args string, testData *TestData) (*TestData, *cel.Env, error) {
	args = strings.TrimSpace(args)
	if args == "" {
		return testData, nil, fmt.Errorf("usage: :use Kind/Name (e.g., :use PetstoreAggregate/my-aggregate)")
	}

	kind, name, err := parseCRName(args)
	if err != nil {
		return testData, nil, err
	}

	// Ensure we have an API group
	if apiGroup == "" {
		return testData, nil, fmt.Errorf("--api-group is required when using :use command")
	}

	// Get or reuse Kubernetes client
	if interactiveClient == nil {
		client, cleanup, err := getKubernetesClient()
		if err != nil {
			return testData, nil, fmt.Errorf("failed to get Kubernetes client: %w", err)
		}
		interactiveClient = client
		interactiveCleanup = cleanup
	}

	// Fetch the CR
	cr, err := fetchCRFromCluster(interactiveClient, kind, name, kubeNamespace)
	if err != nil {
		return testData, nil, err
	}

	// Update global state
	loadedCR = cr
	derivedValues = cr.Spec.DerivedValues

	// Copy selectors from CR
	interactiveSelectors = cr.Spec.ResourceSelectors
	interactiveResources = cr.Spec.Resources

	fmt.Printf("Loaded %s/%s\n", kind, name)
	fmt.Printf("  DerivedValues: %d\n", len(cr.Spec.DerivedValues))
	fmt.Printf("  ResourceSelectors: %d\n", len(cr.Spec.ResourceSelectors))
	fmt.Printf("  Resources: %d\n", len(cr.Spec.Resources))

	// Ask if user wants to fetch resources now
	fmt.Println("\nUse :fetch to load resources based on CR selectors, or add more with :select/:resource")

	// If CR has status data, use that for now
	if len(cr.Status.Resources) > 0 || cr.Status.Summary != nil {
		testData = convertCRStatusToTestData(cr, nil)
		env, err := createCELEnv(testData)
		if err != nil {
			return testData, nil, fmt.Errorf("failed to create CEL environment: %w", err)
		}
		return testData, env, nil
	}

	return testData, nil, nil
}

// handleSelectCommand handles the :select command to add a resource selector
// Format: :select kind=X [labels=k1=v1,k2=v2] [pattern=regex]
func handleSelectCommand(args string) {
	args = strings.TrimSpace(args)
	if args == "" {
		fmt.Println("Usage: :select kind=X [labels=k1=v1,k2=v2] [pattern=regex]")
		fmt.Println("Example: :select kind=Order")
		fmt.Println("Example: :select kind=Pet labels=env=prod,tier=backend")
		fmt.Println("Example: :select kind=Order pattern=^test-")
		return
	}

	selector := make(map[string]interface{})
	parts := strings.Fields(args)

	for _, part := range parts {
		kv := strings.SplitN(part, "=", 2)
		if len(kv) != 2 {
			fmt.Printf("Invalid format: %s (expected key=value)\n", part)
			return
		}
		key, value := kv[0], kv[1]

		switch key {
		case "kind":
			selector["kind"] = value
		case "labels":
			// Parse labels as k1=v1,k2=v2
			labelMap := make(map[string]interface{})
			labelPairs := strings.Split(value, ",")
			for _, lp := range labelPairs {
				lkv := strings.SplitN(lp, "=", 2)
				if len(lkv) == 2 {
					labelMap[lkv[0]] = lkv[1]
				}
			}
			if len(labelMap) > 0 {
				selector["matchLabels"] = labelMap
			}
		case "pattern":
			selector["namePattern"] = value
		default:
			fmt.Printf("Unknown key: %s (use kind, labels, or pattern)\n", key)
			return
		}
	}

	// Parse and validate using shared package
	sel := aggregate.ParseResourceSelector(selector)
	if !sel.IsValid() {
		fmt.Println("Error: 'kind' is required")
		return
	}

	// Validate regex pattern if specified
	if sel.NamePattern != "" {
		_, err := aggregate.CompileSelector(sel)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return
		}
	}

	interactiveSelectors = append(interactiveSelectors, selector)
	fmt.Printf("Added selector: %v\n", selector)
	fmt.Printf("Total selectors: %d\n", len(interactiveSelectors))
}

// handleResourceCommand handles the :resource command to add an explicit resource reference
// Format: :resource kind=X name=Y [namespace=Z]
func handleResourceCommand(args string) {
	args = strings.TrimSpace(args)
	if args == "" {
		fmt.Println("Usage: :resource kind=X name=Y [namespace=Z]")
		fmt.Println("Example: :resource kind=Order name=my-order")
		fmt.Println("Example: :resource kind=Pet name=fluffy namespace=pets")
		return
	}

	resource := make(map[string]interface{})
	parts := strings.Fields(args)

	for _, part := range parts {
		kv := strings.SplitN(part, "=", 2)
		if len(kv) != 2 {
			fmt.Printf("Invalid format: %s (expected key=value)\n", part)
			return
		}
		key, value := kv[0], kv[1]

		switch key {
		case "kind":
			resource["kind"] = value
		case "name":
			resource["name"] = value
		case "namespace":
			resource["namespace"] = value
		default:
			fmt.Printf("Unknown key: %s (use kind, name, or namespace)\n", key)
			return
		}
	}

	if _, ok := resource["kind"]; !ok {
		fmt.Println("Error: 'kind' is required")
		return
	}
	if _, ok := resource["name"]; !ok {
		fmt.Println("Error: 'name' is required")
		return
	}

	interactiveResources = append(interactiveResources, resource)
	fmt.Printf("Added resource: %v\n", resource)
	fmt.Printf("Total explicit resources: %d\n", len(interactiveResources))
}

// handleFetchCommand handles the :fetch command to fetch resources from Kubernetes
func handleFetchCommand(testData *TestData) (*TestData, *cel.Env, error) {
	if len(interactiveSelectors) == 0 && len(interactiveResources) == 0 {
		return testData, nil, fmt.Errorf("no selectors defined. Use :select or :resource to add selectors, or :use to load a CR")
	}

	if apiGroup == "" {
		return testData, nil, fmt.Errorf("--api-group is required for fetching resources")
	}

	// Get or reuse Kubernetes client
	if interactiveClient == nil {
		client, cleanup, err := getKubernetesClient()
		if err != nil {
			return testData, nil, fmt.Errorf("failed to get Kubernetes client: %w", err)
		}
		interactiveClient = client
		interactiveCleanup = cleanup
	}

	// Build a temporary CRDocument to use fetchResourcesFromCR
	tempCR := &CRDocument{
		Metadata: map[string]interface{}{
			"namespace": kubeNamespace,
		},
		Spec: CRSpec{
			ResourceSelectors: interactiveSelectors,
			Resources:         interactiveResources,
		},
	}

	// If we have a loaded CR, use its namespace as default
	if loadedCR != nil && tempCR.Metadata["namespace"] == "" {
		if ns, ok := loadedCR.Metadata["namespace"].(string); ok {
			tempCR.Metadata["namespace"] = ns
		}
	}

	// Fetch resources
	newTestData, err := fetchResourcesFromCR(interactiveClient, tempCR)
	if err != nil {
		return testData, nil, err
	}

	fmt.Printf("Fetched %d resources:\n", len(newTestData.Resources))
	for kind, resources := range newTestData.KindLists {
		fmt.Printf("  %s: %d\n", kind, len(resources))
	}
	fmt.Printf("Summary: total=%d, synced=%d, failed=%d, pending=%d\n",
		newTestData.Summary["total"],
		newTestData.Summary["synced"],
		newTestData.Summary["failed"],
		newTestData.Summary["pending"])

	// Create new CEL environment with the fetched data
	env, err := createCELEnv(newTestData)
	if err != nil {
		return newTestData, nil, fmt.Errorf("failed to create CEL environment: %w", err)
	}

	return newTestData, env, nil
}

// handleClearCommand handles the :clear command to clear all selectors
func handleClearCommand() {
	interactiveSelectors = nil
	interactiveResources = nil
	fmt.Println("Cleared all selectors and resource references")
}

// printSelectors prints current selectors and resource references
func printSelectors() {
	fmt.Println("\nCurrent Resource Selection:")

	if len(interactiveSelectors) == 0 && len(interactiveResources) == 0 {
		fmt.Println("  (none defined)")
		fmt.Println("\nUse :select or :resource to add selectors, or :use to load a CR")
	} else {
		if len(interactiveSelectors) > 0 {
			fmt.Printf("\nResource Selectors (%d):\n", len(interactiveSelectors))
			for i, sel := range interactiveSelectors {
				kind, _ := sel["kind"].(string)
				fmt.Printf("  %d. kind=%s", i+1, kind)
				if labels, ok := sel["matchLabels"].(map[string]interface{}); ok && len(labels) > 0 {
					labelStrs := []string{}
					for k, v := range labels {
						labelStrs = append(labelStrs, fmt.Sprintf("%s=%v", k, v))
					}
					fmt.Printf(" labels=%s", strings.Join(labelStrs, ","))
				}
				if pattern, ok := sel["namePattern"].(string); ok && pattern != "" {
					fmt.Printf(" pattern=%s", pattern)
				}
				fmt.Println()
			}
		}

		if len(interactiveResources) > 0 {
			fmt.Printf("\nExplicit Resources (%d):\n", len(interactiveResources))
			for i, res := range interactiveResources {
				kind, _ := res["kind"].(string)
				name, _ := res["name"].(string)
				namespace, _ := res["namespace"].(string)
				if namespace == "" {
					namespace = "(default)"
				}
				fmt.Printf("  %d. %s/%s in %s\n", i+1, kind, name, namespace)
			}
		}
	}
	fmt.Println()
}

// printCRInfo prints information about the currently loaded CR
func printCRInfo() {
	if loadedCR == nil {
		fmt.Println("\nNo CR loaded")
		fmt.Println("Use :use Kind/Name or --cr/--cr-name to load a CR")
		return
	}

	fmt.Printf("\nLoaded CR:\n")
	fmt.Printf("  Kind: %s\n", loadedCR.Kind)
	fmt.Printf("  Name: %v\n", loadedCR.Metadata["name"])
	fmt.Printf("  Namespace: %v\n", loadedCR.Metadata["namespace"])
	fmt.Printf("  APIVersion: %s\n", loadedCR.APIVersion)

	if len(derivedValues) > 0 {
		fmt.Printf("\nDerived Values (%d):\n", len(derivedValues))
		for i, dv := range derivedValues {
			fmt.Printf("  %d. %s: %s\n", i+1, dv.Name, dv.Expression)
		}
	}

	if len(loadedCR.Spec.ResourceSelectors) > 0 {
		fmt.Printf("\nCR ResourceSelectors (%d):\n", len(loadedCR.Spec.ResourceSelectors))
		for i, sel := range loadedCR.Spec.ResourceSelectors {
			kind, _ := sel["kind"].(string)
			fmt.Printf("  %d. kind=%s\n", i+1, kind)
		}
	}

	if len(loadedCR.Spec.Resources) > 0 {
		fmt.Printf("\nCR Resources (%d):\n", len(loadedCR.Spec.Resources))
		for i, res := range loadedCR.Spec.Resources {
			kind, _ := res["kind"].(string)
			name, _ := res["name"].(string)
			fmt.Printf("  %d. %s/%s\n", i+1, kind, name)
		}
	}

	// Show Bundle-specific info
	if isBundleCR(loadedCR) {
		fmt.Println("\nThis is a Bundle CR. Use :create to create child resources.")
	}

	fmt.Println()
}

// ==================== Bundle Resource Creation ====================

// isBundleCR detects if the loaded CR is a Bundle (has spec.resources with id and embedded spec)
// rather than an Aggregate (has spec.resources with kind/name references or spec.resourceSelectors)
func isBundleCR(cr *CRDocument) bool {
	if cr == nil || len(cr.Spec.Resources) == 0 {
		return false
	}

	// Bundle CRs have resources with "id" and embedded "spec"
	for _, res := range cr.Spec.Resources {
		if _, hasID := res["id"]; hasID {
			if _, hasSpec := res["spec"]; hasSpec {
				return true
			}
		}
	}
	return false
}

// parseBundleResources parses Bundle resource specifications from a CR
func parseBundleResources(cr *CRDocument) ([]bundle.ResourceSpec, error) {
	if cr == nil {
		return nil, fmt.Errorf("no CR loaded")
	}

	var resources []bundle.ResourceSpec
	for i, res := range cr.Spec.Resources {
		br := bundle.ResourceSpec{}

		// Parse ID (required)
		if id, ok := res["id"].(string); ok {
			br.ID = id
		} else {
			return nil, fmt.Errorf("resource %d: 'id' is required", i)
		}

		// Parse Kind (required)
		if kind, ok := res["kind"].(string); ok {
			br.Kind = kind
		} else {
			return nil, fmt.Errorf("resource %d (%s): 'kind' is required", i, br.ID)
		}

		// Parse Spec (required)
		if spec, ok := res["spec"].(map[string]interface{}); ok {
			br.Spec = spec
		} else {
			return nil, fmt.Errorf("resource %d (%s): 'spec' is required", i, br.ID)
		}

		// Parse DependsOn (optional)
		if dependsOn, ok := res["dependsOn"].([]interface{}); ok {
			for _, dep := range dependsOn {
				if depStr, ok := dep.(string); ok {
					br.DependsOn = append(br.DependsOn, depStr)
				}
			}
		}

		// Parse SkipWhen (optional)
		if skipWhen, ok := res["skipWhen"].([]interface{}); ok {
			for _, sw := range skipWhen {
				if swStr, ok := sw.(string); ok {
					br.SkipWhen = append(br.SkipWhen, swStr)
				}
			}
		}

		// Parse ReadyWhen (optional)
		if readyWhen, ok := res["readyWhen"].([]interface{}); ok {
			for _, rw := range readyWhen {
				if rwStr, ok := rw.(string); ok {
					br.ReadyWhen = append(br.ReadyWhen, rwStr)
				}
			}
		}

		resources = append(resources, br)
	}

	return resources, nil
}

// Note: buildExecutionOrder, extractDependenciesFromSpec, findResourceReferences, and isValidResourceID
// are now provided by the bundle package. Use bundle.BuildExecutionOrderSimple() instead.

// handleCreateCommand handles the :create command to create Bundle child resources
func handleCreateCommand(testData *TestData, dryRun bool) (*TestData, *cel.Env, error) {
	if loadedCR == nil {
		return testData, nil, fmt.Errorf("no CR loaded. Use :use Kind/Name or --cr to load a Bundle CR first")
	}

	if !isBundleCR(loadedCR) {
		return testData, nil, fmt.Errorf("loaded CR is not a Bundle (no spec.resources with id and embedded spec)")
	}

	if apiGroup == "" {
		return testData, nil, fmt.Errorf("--api-group is required for creating resources")
	}

	// Parse bundle resources
	resources, err := parseBundleResources(loadedCR)
	if err != nil {
		return testData, nil, fmt.Errorf("failed to parse bundle resources: %w", err)
	}

	if len(resources) == 0 {
		return testData, nil, fmt.Errorf("no resources defined in bundle")
	}

	// Build execution order
	order, err := bundle.BuildExecutionOrderSimple(resources)
	if err != nil {
		return testData, nil, fmt.Errorf("failed to build execution order: %w", err)
	}

	// Build resource map for quick lookup
	resourceMap := make(map[string]bundle.ResourceSpec)
	for _, res := range resources {
		resourceMap[res.ID] = res
	}

	// Get bundle name and namespace
	bundleName := ""
	if name, ok := loadedCR.Metadata["name"].(string); ok {
		bundleName = name
	} else {
		bundleName = "bundle"
	}

	bundleNamespace := "default"
	if ns, ok := loadedCR.Metadata["namespace"].(string); ok && ns != "" {
		bundleNamespace = ns
	}
	if kubeNamespace != "" {
		bundleNamespace = kubeNamespace
	}

	if dryRun {
		fmt.Println("\n=== Dry Run: Would create the following resources ===")
		for i, id := range order {
			res := resourceMap[id]
			childName := fmt.Sprintf("%s-%s", bundleName, id)
			fmt.Printf("%d. %s/%s/%s\n", i+1, res.Kind, bundleNamespace, childName)
			if len(res.DependsOn) > 0 {
				fmt.Printf("   DependsOn: %v\n", res.DependsOn)
			}
			specJSON, _ := json.MarshalIndent(res.Spec, "   ", "  ")
			fmt.Printf("   Spec: %s\n", string(specJSON))
		}
		fmt.Printf("\nTotal: %d resources would be created\n", len(order))
		return testData, nil, nil
	}

	// Get or reuse Kubernetes client
	if interactiveClient == nil {
		client, cleanup, err := getKubernetesClient()
		if err != nil {
			return testData, nil, fmt.Errorf("failed to get Kubernetes client: %w", err)
		}
		interactiveClient = client
		interactiveCleanup = cleanup
	}

	// Create resources in order
	created := make([]CreatedResource, 0, len(order))
	createdStatus := make(map[string]map[string]interface{}) // Track status for expression resolution

	fmt.Println("\n=== Creating Bundle Resources ===")
	for _, id := range order {
		res := resourceMap[id]
		childName := fmt.Sprintf("%s-%s", bundleName, id)

		fmt.Printf("Creating %s/%s/%s...", res.Kind, bundleNamespace, childName)

		// Resolve any ${resources.<id>.status.<field>} expressions in spec
		resolvedSpec, resolveErr := bundle.ResolveExpressions(res.Spec, createdStatus)
		if resolveErr != nil {
			// Use original spec if resolution fails
			resolvedSpec = res.Spec
		}

		// Create the resource
		err := createChildResource(interactiveClient, res.Kind, childName, bundleNamespace, resolvedSpec)
		if err != nil {
			fmt.Printf(" FAILED: %v\n", err)
			// Continue with other resources
			continue
		}

		fmt.Println(" created")

		// Track created resource
		cr := CreatedResource{
			ID:        id,
			Kind:      res.Kind,
			Name:      childName,
			Namespace: bundleNamespace,
			Status:    map[string]interface{}{"state": "Pending"},
		}
		created = append(created, cr)
		createdStatus[id] = map[string]interface{}{
			"status": cr.Status,
		}
	}

	fmt.Printf("\nCreated %d/%d resources\n", len(created), len(order))

	// Update test data with created resources
	if len(created) > 0 {
		fmt.Println("\nUse :fetch to reload resources with their current status")
	}

	return testData, nil, nil
}

// createChildResource creates a single child resource in Kubernetes
func createChildResource(client dynamic.Interface, kind, name, namespace string, spec map[string]interface{}) error {
	ctx := context.Background()

	// Build the unstructured resource
	resource := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": fmt.Sprintf("%s/%s", apiGroup, apiVersion),
			"kind":       kind,
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
			},
			"spec": spec,
		},
	}

	// Get the GVR
	gvr := schema.GroupVersionResource{
		Group:    apiGroup,
		Version:  apiVersion,
		Resource: aggregate.KindToResourceName(kind),
	}

	// Check if resource already exists
	existing, err := client.Resource(gvr).Namespace(namespace).Get(ctx, name, metav1.GetOptions{})
	if err == nil {
		// Resource exists, update it
		resource.SetResourceVersion(existing.GetResourceVersion())
		_, err = client.Resource(gvr).Namespace(namespace).Update(ctx, resource, metav1.UpdateOptions{})
		if err != nil {
			return fmt.Errorf("failed to update: %w", err)
		}
		return nil
	}

	if !errors.IsNotFound(err) {
		return fmt.Errorf("failed to check existing resource: %w", err)
	}

	// Create new resource
	_, err = client.Resource(gvr).Namespace(namespace).Create(ctx, resource, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create: %w", err)
	}

	return nil
}
