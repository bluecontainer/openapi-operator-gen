/*
Copyright 2026 Generated by openapi-operator-gen.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
*/

// cel-test is a CLI utility for testing CEL expressions used in Aggregate and Bundle CRDs.
// It provides an interactive way to validate CEL expressions before deploying to Kubernetes.
//
// Usage:
//
//	cel-test eval "summary.synced * 100 / summary.total"
//	cel-test eval "orders.size()" --data testdata.json
//	cel-test eval "sum(orders.map(r, r.spec.quantity))" --data testdata.json
//	cel-test interactive
package main

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"reflect"
	"strings"
	"syscall"

	celutil "github.com/bluecontainer/openapi-operator-gen/pkg/cel"
	"github.com/google/cel-go/cel"
	"github.com/spf13/cobra"
	"golang.org/x/term"
	"gopkg.in/yaml.v3"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
)

// TestData represents the input data structure for CEL evaluation
type TestData struct {
	// Summary contains aggregate counts
	Summary map[string]int64 `json:"summary"`
	// Resources is the list of all resources
	Resources []map[string]interface{} `json:"resources"`
	// KindLists contains kind-specific lists (e.g., "orders", "pets")
	KindLists map[string][]map[string]interface{} `json:"kindLists"`
}

// History manages command history with navigation
type History struct {
	entries []string
	index   int
	maxSize int
}

// NewHistory creates a new history with the specified max size
func NewHistory(maxSize int) *History {
	return &History{
		entries: make([]string, 0, maxSize),
		index:   -1,
		maxSize: maxSize,
	}
}

// Add adds an entry to history
func (h *History) Add(entry string) {
	if entry == "" {
		return
	}
	// Don't add duplicates of the last entry
	if len(h.entries) > 0 && h.entries[len(h.entries)-1] == entry {
		h.Reset()
		return
	}
	h.entries = append(h.entries, entry)
	if len(h.entries) > h.maxSize {
		h.entries = h.entries[1:]
	}
	h.Reset()
}

// Reset resets the navigation index
func (h *History) Reset() {
	h.index = len(h.entries)
}

// Previous returns the previous entry in history
func (h *History) Previous() (string, bool) {
	if h.index > 0 {
		h.index--
		return h.entries[h.index], true
	}
	if h.index == 0 && len(h.entries) > 0 {
		return h.entries[0], true
	}
	return "", false
}

// Next returns the next entry in history
func (h *History) Next() (string, bool) {
	if h.index < len(h.entries)-1 {
		h.index++
		return h.entries[h.index], true
	}
	h.index = len(h.entries)
	return "", true
}

// Len returns the number of entries in history
func (h *History) Len() int {
	return len(h.entries)
}

// CRDocument represents a parsed Aggregate or Bundle CR
type CRDocument struct {
	APIVersion string                 `yaml:"apiVersion" json:"apiVersion"`
	Kind       string                 `yaml:"kind" json:"kind"`
	Metadata   map[string]interface{} `yaml:"metadata" json:"metadata"`
	Spec       CRSpec                 `yaml:"spec" json:"spec"`
	Status     CRStatus               `yaml:"status" json:"status"`
}

// CRSpec represents the spec of an Aggregate or Bundle CR
type CRSpec struct {
	Resources         []map[string]interface{} `yaml:"resources" json:"resources"`
	ResourceSelectors []map[string]interface{} `yaml:"resourceSelectors" json:"resourceSelectors"`
	DerivedValues     []DerivedValue           `yaml:"derivedValues" json:"derivedValues"`
}

// DerivedValue represents a CEL expression definition from the CR
type DerivedValue struct {
	Name       string `yaml:"name" json:"name"`
	Expression string `yaml:"expression" json:"expression"`
}

// CRStatus represents the status of an Aggregate or Bundle CR
type CRStatus struct {
	State     string                   `yaml:"state" json:"state"`
	Summary   map[string]int64         `yaml:"summary" json:"summary"`
	Resources []map[string]interface{} `yaml:"resources" json:"resources"`
}

var (
	dataFile      string
	crFile        string
	resourcesFile string
	mockData      bool
	showHelp      bool
	kindVars      []string
	summaryJSON   string
	historySize   int
	loadedCR      *CRDocument
	derivedValues []DerivedValue

	// Kubernetes flags
	kubeconfig    string
	kubeNamespace string
	apiGroup      string
	apiVersion    string
	useEnvtest    bool
	crdPaths      []string
	evalExpr      string
	outputFile    string
	outputYAML    string

	// Envtest environment (kept alive for the session)
	testEnv    *envtest.Environment
	restConfig *rest.Config
)

func main() {
	rootCmd := &cobra.Command{
		Use:   "cel-test",
		Short: "Test CEL expressions for Aggregate and Bundle CRDs",
		Long: `cel-test is a CLI utility for testing CEL expressions used in openapi-operator-gen
Aggregate and Bundle CRDs. It allows you to validate CEL expressions before
deploying to Kubernetes.

Available variables in expressions:
  - resources: list of all resource objects
  - summary: map with total, synced, failed, pending, skipped counts
  - <kind>s: kind-specific lists (e.g., orders, pets, users)

Available aggregate functions:
  - sum(list): sum of numeric values
  - max(list): maximum value
  - min(list): minimum value
  - avg(list): average value

Examples:
  cel-test eval "summary.synced * 100 / summary.total"
  cel-test eval "orders.size()" --kinds orders,pets --data testdata.json
  cel-test eval "sum(orders.map(r, r.spec.quantity))" --data testdata.json
  cel-test interactive`,
	}

	evalCmd := &cobra.Command{
		Use:   "eval [expression]",
		Short: "Evaluate a single CEL expression",
		Args:  cobra.ExactArgs(1),
		RunE:  runEval,
	}
	evalCmd.Flags().StringVarP(&dataFile, "data", "d", "", "JSON file with test data")
	evalCmd.Flags().StringVarP(&crFile, "cr", "c", "", "Aggregate/Bundle CR YAML file (uses status for test data)")
	evalCmd.Flags().StringVarP(&resourcesFile, "resources", "r", "", "YAML file with referenced child CRs (provides spec data)")
	evalCmd.Flags().BoolVarP(&mockData, "mock", "m", false, "Generate mock status data from CR resourceSelectors")
	evalCmd.Flags().StringSliceVarP(&kindVars, "kinds", "k", []string{}, "Kind variable names (e.g., orders,pets,users)")
	evalCmd.Flags().StringVarP(&summaryJSON, "summary", "s", "", "Summary JSON (e.g., '{\"total\":10,\"synced\":8}')")
	// Kubernetes flags for eval
	evalCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file (defaults to ~/.kube/config)")
	evalCmd.Flags().StringVarP(&kubeNamespace, "namespace", "n", "", "Kubernetes namespace to fetch from")
	evalCmd.Flags().StringVar(&apiGroup, "api-group", "", "API group for fetching resources from Kubernetes")
	evalCmd.Flags().StringVar(&apiVersion, "api-version", "v1alpha1", "API version for fetching resources from Kubernetes")
	evalCmd.Flags().BoolVar(&useEnvtest, "envtest", false, "Use envtest instead of real cluster")
	evalCmd.Flags().StringSliceVar(&crdPaths, "crd-paths", []string{}, "Paths to CRD YAML files (required with --envtest)")

	interactiveCmd := &cobra.Command{
		Use:   "interactive",
		Short: "Start interactive CEL expression testing",
		Long: `Start interactive CEL expression testing with history support.

Use arrow keys to navigate history:
  - Up Arrow: Previous command
  - Down Arrow: Next command
  - Ctrl+C: Cancel current input
  - Ctrl+D: Exit`,
		RunE: runInteractive,
	}
	interactiveCmd.Flags().StringVarP(&dataFile, "data", "d", "", "JSON file with test data")
	interactiveCmd.Flags().StringVarP(&crFile, "cr", "c", "", "Aggregate/Bundle CR YAML file (uses status for test data)")
	interactiveCmd.Flags().StringVarP(&resourcesFile, "resources", "r", "", "YAML file with referenced child CRs (provides spec data)")
	interactiveCmd.Flags().BoolVarP(&mockData, "mock", "m", false, "Generate mock status data from CR resourceSelectors")
	interactiveCmd.Flags().StringSliceVarP(&kindVars, "kinds", "k", []string{}, "Kind variable names (e.g., orders,pets,users)")
	interactiveCmd.Flags().IntVar(&historySize, "history-size", 100, "Maximum number of history entries")
	// Kubernetes flags for interactive
	interactiveCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file (defaults to ~/.kube/config)")
	interactiveCmd.Flags().StringVarP(&kubeNamespace, "namespace", "n", "", "Kubernetes namespace to fetch from")
	interactiveCmd.Flags().StringVar(&apiGroup, "api-group", "", "API group for fetching resources from Kubernetes")
	interactiveCmd.Flags().StringVar(&apiVersion, "api-version", "v1alpha1", "API version for fetching resources from Kubernetes")
	interactiveCmd.Flags().BoolVar(&useEnvtest, "envtest", false, "Use envtest instead of real cluster")
	interactiveCmd.Flags().StringSliceVar(&crdPaths, "crd-paths", []string{}, "Paths to CRD YAML files (required with --envtest)")

	exampleCmd := &cobra.Command{
		Use:   "example",
		Short: "Generate example test data file",
		RunE:  runExample,
	}

	expressionsCmd := &cobra.Command{
		Use:   "expressions",
		Short: "List and evaluate derived value expressions from a CR",
		Long: `Read an Aggregate or Bundle CR YAML file and list or evaluate all
derivedValues expressions defined in the spec.

If a --data file is provided, it evaluates each expression against that data.
If --cr is provided with status data, uses that for evaluation.`,
		RunE: runExpressions,
	}
	expressionsCmd.Flags().StringVarP(&crFile, "cr", "c", "", "Aggregate/Bundle CR YAML file (required)")
	expressionsCmd.Flags().StringVarP(&dataFile, "data", "d", "", "JSON file with test data for evaluation")
	expressionsCmd.Flags().StringVarP(&resourcesFile, "resources", "r", "", "YAML file with referenced child CRs (provides spec data)")
	expressionsCmd.Flags().BoolVarP(&mockData, "mock", "m", false, "Generate mock status data from CR resourceSelectors")
	expressionsCmd.Flags().StringSliceVarP(&kindVars, "kinds", "k", []string{}, "Kind variable names (e.g., orders,pets,users)")
	// Kubernetes flags for expressions
	expressionsCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file (defaults to ~/.kube/config)")
	expressionsCmd.Flags().StringVarP(&kubeNamespace, "namespace", "n", "", "Kubernetes namespace to fetch from")
	expressionsCmd.Flags().StringVar(&apiGroup, "api-group", "", "API group for fetching resources from Kubernetes")
	expressionsCmd.Flags().StringVar(&apiVersion, "api-version", "v1alpha1", "API version for fetching resources from Kubernetes")
	expressionsCmd.Flags().BoolVar(&useEnvtest, "envtest", false, "Use envtest instead of real cluster")
	expressionsCmd.Flags().StringSliceVar(&crdPaths, "crd-paths", []string{}, "Paths to CRD YAML files (required with --envtest)")
	expressionsCmd.MarkFlagRequired("cr")

	// Fetch command - retrieves resources from Kubernetes cluster
	fetchCmd := &cobra.Command{
		Use:   "fetch",
		Short: "Fetch resources from Kubernetes cluster for CEL testing",
		Long: `Fetch resources from a Kubernetes cluster and use them as test data for CEL expressions.

This command connects to a Kubernetes cluster (via kubeconfig or envtest) and fetches
resources of the specified kinds to use as CEL test data.

Examples:
  # Fetch from current kubeconfig context
  cel-test fetch --kinds Order,Pet,User --api-group petstore.example.com

  # Fetch from a specific namespace
  cel-test fetch --kinds Order,Pet --namespace my-namespace --api-group petstore.example.com

  # Use envtest (for testing without a real cluster)
  cel-test fetch --envtest --crd-paths ./config/crd/bases --kinds Order,Pet

  # Fetch and evaluate an expression
  cel-test fetch --kinds Order --api-group petstore.example.com --eval "orders.size()"

  # Save fetched resources as YAML (for use with --resources flag)
  cel-test fetch --kinds Order,Pet --api-group petstore.example.com --output-yaml resources.yaml`,
		RunE: runFetch,
	}
	fetchCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file (defaults to ~/.kube/config)")
	fetchCmd.Flags().StringVarP(&kubeNamespace, "namespace", "n", "", "Kubernetes namespace to fetch from (defaults to all namespaces)")
	fetchCmd.Flags().StringVar(&apiGroup, "api-group", "", "API group for the resources (e.g., petstore.example.com)")
	fetchCmd.Flags().StringVar(&apiVersion, "api-version", "v1alpha1", "API version for the resources")
	fetchCmd.Flags().StringSliceVarP(&kindVars, "kinds", "k", []string{}, "Resource kinds to fetch (e.g., Order,Pet,User)")
	fetchCmd.Flags().BoolVar(&useEnvtest, "envtest", false, "Use envtest instead of real cluster")
	fetchCmd.Flags().StringSliceVar(&crdPaths, "crd-paths", []string{}, "Paths to CRD YAML files (required with --envtest)")
	fetchCmd.Flags().StringVarP(&crFile, "cr", "c", "", "Aggregate/Bundle CR YAML file to get kinds from")
	fetchCmd.Flags().StringVarP(&evalExpr, "eval", "e", "", "CEL expression to evaluate after fetching")
	fetchCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file to save fetched data as JSON (for use with --data)")
	fetchCmd.Flags().StringVar(&outputYAML, "output-yaml", "", "Output file to save fetched resources as YAML (for use with --resources)")
	fetchCmd.MarkFlagRequired("api-group")

	rootCmd.AddCommand(evalCmd, interactiveCmd, exampleCmd, expressionsCmd, fetchCmd)

	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func runEval(cmd *cobra.Command, args []string) error {
	expression := args[0]

	testData, err := loadTestData()
	if err != nil {
		return fmt.Errorf("failed to load test data: %w", err)
	}

	env, err := createCELEnv(testData)
	if err != nil {
		return fmt.Errorf("failed to create CEL environment: %w", err)
	}

	result, err := evaluateExpression(env, expression, testData)
	if err != nil {
		return fmt.Errorf("evaluation error: %w", err)
	}

	fmt.Printf("Expression: %s\n", expression)
	fmt.Printf("Result: %v\n", result)
	fmt.Printf("Type: %s\n", reflect.TypeOf(result))

	return nil
}

func runInteractive(cmd *cobra.Command, args []string) error {
	testData, err := loadTestData()
	if err != nil {
		return fmt.Errorf("failed to load test data: %w", err)
	}

	env, err := createCELEnv(testData)
	if err != nil {
		return fmt.Errorf("failed to create CEL environment: %w", err)
	}

	fmt.Println("CEL Expression Tester - Interactive Mode")
	fmt.Println("========================================")
	fmt.Println("Type CEL expressions to evaluate. Type 'help' for available variables.")
	fmt.Println("Type 'data' to show current test data. Type 'exit' or 'quit' to exit.")
	fmt.Println("Use Up/Down arrows to navigate history. Ctrl+C to cancel, Ctrl+D to exit.")
	fmt.Println()

	history := NewHistory(historySize)

	// Check if we have a terminal for raw mode
	if !term.IsTerminal(int(os.Stdin.Fd())) {
		return runInteractiveFallback(env, testData, history)
	}

	// Set up signal handling for clean exit
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigChan
		fmt.Println("\nGoodbye!")
		os.Exit(0)
	}()

	for {
		input, err := readLineWithHistory(history)
		if err != nil {
			if err.Error() == "EOF" {
				fmt.Println("\nGoodbye!")
				return nil
			}
			return err
		}

		input = strings.TrimSpace(input)
		if input == "" {
			continue
		}

		// Add to history before processing
		history.Add(input)

		switch strings.ToLower(input) {
		case "exit", "quit", "q":
			fmt.Println("Goodbye!")
			return nil
		case "help", "h", "?":
			printHelp(testData)
			continue
		case "data":
			printData(testData)
			continue
		case "history":
			printHistory(history)
			continue
		case "reload":
			testData, err = loadTestData()
			if err != nil {
				fmt.Printf("Error reloading data: %v\n", err)
			} else {
				env, _ = createCELEnv(testData)
				fmt.Println("Data reloaded.")
			}
			continue
		case "expressions", "expr":
			printExpressions(env, testData)
			continue
		}

		result, err := evaluateExpression(env, input, testData)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
		} else {
			fmt.Printf("=> %v (%s)\n", result, reflect.TypeOf(result))
		}
	}
}

// runInteractiveFallback runs interactive mode without history navigation when not in a terminal
func runInteractiveFallback(env *cel.Env, testData *TestData, history *History) error {
	fmt.Println("(Running in basic mode - no history navigation)")
	fmt.Println()

	// Use a simple line reader for non-terminal input
	var input string
	for {
		fmt.Print("cel> ")
		_, err := fmt.Scanln(&input)
		if err != nil {
			if err.Error() == "EOF" || err.Error() == "unexpected newline" {
				continue
			}
			fmt.Println("\nGoodbye!")
			return nil
		}

		input = strings.TrimSpace(input)
		if input == "" {
			continue
		}

		history.Add(input)

		switch strings.ToLower(input) {
		case "exit", "quit", "q":
			fmt.Println("Goodbye!")
			return nil
		case "help", "h", "?":
			printHelp(testData)
			continue
		case "data":
			printData(testData)
			continue
		case "history":
			printHistory(history)
			continue
		case "reload":
			var reloadErr error
			testData, reloadErr = loadTestData()
			if reloadErr != nil {
				fmt.Printf("Error reloading data: %v\n", reloadErr)
			} else {
				env, _ = createCELEnv(testData)
				fmt.Println("Data reloaded.")
			}
			continue
		case "expressions", "expr":
			printExpressions(env, testData)
			continue
		}

		result, evalErr := evaluateExpression(env, input, testData)
		if evalErr != nil {
			fmt.Printf("Error: %v\n", evalErr)
		} else {
			fmt.Printf("=> %v (%s)\n", result, reflect.TypeOf(result))
		}
	}
}

// readLineWithHistory reads a line with history navigation support
func readLineWithHistory(history *History) (string, error) {
	oldState, err := term.MakeRaw(int(os.Stdin.Fd()))
	if err != nil {
		return "", fmt.Errorf("failed to set raw mode: %w", err)
	}
	defer term.Restore(int(os.Stdin.Fd()), oldState)

	fmt.Print("cel> ")

	var line []byte
	cursorPos := 0
	history.Reset()

	buf := make([]byte, 1)
	for {
		_, err := os.Stdin.Read(buf)
		if err != nil {
			return "", err
		}

		switch buf[0] {
		case 3: // Ctrl+C
			fmt.Print("\r\n")
			history.Reset()
			return "", nil
		case 4: // Ctrl+D (EOF)
			fmt.Print("\r\n")
			return "", fmt.Errorf("EOF")
		case 13, 10: // Enter
			fmt.Print("\r\n")
			return string(line), nil
		case 127, 8: // Backspace
			if cursorPos > 0 {
				// Remove character at cursor position
				line = append(line[:cursorPos-1], line[cursorPos:]...)
				cursorPos--
				// Redraw line
				fmt.Print("\r\033[K") // Clear line
				fmt.Print("cel> ")
				fmt.Print(string(line))
				// Move cursor to correct position
				if cursorPos < len(line) {
					fmt.Printf("\033[%dD", len(line)-cursorPos)
				}
			}
		case 27: // Escape sequence
			// Read the next two bytes for arrow keys
			seq := make([]byte, 2)
			os.Stdin.Read(seq)
			if seq[0] == '[' {
				switch seq[1] {
				case 'A': // Up arrow
					if entry, ok := history.Previous(); ok {
						line = []byte(entry)
						cursorPos = len(line)
						fmt.Print("\r\033[K") // Clear line
						fmt.Print("cel> ")
						fmt.Print(string(line))
					}
				case 'B': // Down arrow
					if entry, ok := history.Next(); ok {
						line = []byte(entry)
						cursorPos = len(line)
						fmt.Print("\r\033[K") // Clear line
						fmt.Print("cel> ")
						fmt.Print(string(line))
					}
				case 'C': // Right arrow
					if cursorPos < len(line) {
						cursorPos++
						fmt.Print("\033[C")
					}
				case 'D': // Left arrow
					if cursorPos > 0 {
						cursorPos--
						fmt.Print("\033[D")
					}
				case '3': // Delete key (followed by ~)
					delSeq := make([]byte, 1)
					os.Stdin.Read(delSeq)
					if delSeq[0] == '~' && cursorPos < len(line) {
						line = append(line[:cursorPos], line[cursorPos+1:]...)
						// Redraw line
						fmt.Print("\r\033[K")
						fmt.Print("cel> ")
						fmt.Print(string(line))
						if cursorPos < len(line) {
							fmt.Printf("\033[%dD", len(line)-cursorPos)
						}
					}
				case 'H': // Home
					if cursorPos > 0 {
						fmt.Printf("\033[%dD", cursorPos)
						cursorPos = 0
					}
				case 'F': // End
					if cursorPos < len(line) {
						fmt.Printf("\033[%dC", len(line)-cursorPos)
						cursorPos = len(line)
					}
				}
			}
		case 1: // Ctrl+A (Home)
			if cursorPos > 0 {
				fmt.Printf("\033[%dD", cursorPos)
				cursorPos = 0
			}
		case 5: // Ctrl+E (End)
			if cursorPos < len(line) {
				fmt.Printf("\033[%dC", len(line)-cursorPos)
				cursorPos = len(line)
			}
		case 21: // Ctrl+U (Clear line before cursor)
			line = line[cursorPos:]
			cursorPos = 0
			fmt.Print("\r\033[K")
			fmt.Print("cel> ")
			fmt.Print(string(line))
		case 11: // Ctrl+K (Clear line after cursor)
			line = line[:cursorPos]
			fmt.Print("\r\033[K")
			fmt.Print("cel> ")
			fmt.Print(string(line))
		case 23: // Ctrl+W (Delete word before cursor)
			if cursorPos > 0 {
				// Find start of previous word
				newPos := cursorPos - 1
				for newPos > 0 && line[newPos] == ' ' {
					newPos--
				}
				for newPos > 0 && line[newPos-1] != ' ' {
					newPos--
				}
				line = append(line[:newPos], line[cursorPos:]...)
				cursorPos = newPos
				fmt.Print("\r\033[K")
				fmt.Print("cel> ")
				fmt.Print(string(line))
				if cursorPos < len(line) {
					fmt.Printf("\033[%dD", len(line)-cursorPos)
				}
			}
		case 12: // Ctrl+L (Clear screen)
			fmt.Print("\033[2J\033[H") // Clear screen and move to top
			fmt.Print("cel> ")
			fmt.Print(string(line))
		default:
			if buf[0] >= 32 && buf[0] < 127 { // Printable ASCII
				// Insert character at cursor position
				line = append(line[:cursorPos], append([]byte{buf[0]}, line[cursorPos:]...)...)
				cursorPos++
				// Redraw from cursor position
				fmt.Print("\r\033[K")
				fmt.Print("cel> ")
				fmt.Print(string(line))
				if cursorPos < len(line) {
					fmt.Printf("\033[%dD", len(line)-cursorPos)
				}
			}
		}
	}
}

func printHistory(history *History) {
	if history.Len() == 0 {
		fmt.Println("No history entries.")
		return
	}
	fmt.Println("\nCommand History:")
	for i, entry := range history.entries {
		fmt.Printf("  %3d  %s\n", i+1, entry)
	}
	fmt.Println()
}

func runExample(cmd *cobra.Command, args []string) error {
	example := TestData{
		Summary: map[string]int64{
			"total":   10,
			"synced":  7,
			"failed":  2,
			"pending": 1,
			"skipped": 0,
		},
		Resources: []map[string]interface{}{
			{
				"kind": "Order",
				"metadata": map[string]interface{}{
					"name":      "order-1",
					"namespace": "default",
				},
				"spec": map[string]interface{}{
					"quantity": 5,
					"petId":    "123",
				},
				"status": map[string]interface{}{
					"state":      "Synced",
					"externalID": "ext-1",
				},
			},
			{
				"kind": "Order",
				"metadata": map[string]interface{}{
					"name":      "order-2",
					"namespace": "default",
				},
				"spec": map[string]interface{}{
					"quantity": 10,
					"petId":    "456",
				},
				"status": map[string]interface{}{
					"state":      "Synced",
					"externalID": "ext-2",
				},
			},
			{
				"kind": "Pet",
				"metadata": map[string]interface{}{
					"name":      "fluffy",
					"namespace": "default",
				},
				"spec": map[string]interface{}{
					"name":   "Fluffy",
					"status": "available",
				},
				"status": map[string]interface{}{
					"state":      "Synced",
					"externalID": "123",
				},
			},
			{
				"kind": "Pet",
				"metadata": map[string]interface{}{
					"name":      "buddy",
					"namespace": "default",
				},
				"spec": map[string]interface{}{
					"name":   "Buddy",
					"status": "pending",
				},
				"status": map[string]interface{}{
					"state":      "Failed",
					"externalID": "",
					"message":    "API error",
				},
			},
		},
		KindLists: map[string][]map[string]interface{}{
			"orders": {
				{
					"kind": "Order",
					"metadata": map[string]interface{}{
						"name":      "order-1",
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"quantity": 5,
						"petId":    "123",
					},
					"status": map[string]interface{}{
						"state":      "Synced",
						"externalID": "ext-1",
					},
				},
				{
					"kind": "Order",
					"metadata": map[string]interface{}{
						"name":      "order-2",
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"quantity": 10,
						"petId":    "456",
					},
					"status": map[string]interface{}{
						"state":      "Synced",
						"externalID": "ext-2",
					},
				},
			},
			"pets": {
				{
					"kind": "Pet",
					"metadata": map[string]interface{}{
						"name":      "fluffy",
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"name":   "Fluffy",
						"status": "available",
					},
					"status": map[string]interface{}{
						"state":      "Synced",
						"externalID": "123",
					},
				},
				{
					"kind": "Pet",
					"metadata": map[string]interface{}{
						"name":      "buddy",
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"name":   "Buddy",
						"status": "pending",
					},
					"status": map[string]interface{}{
						"state":      "Failed",
						"externalID": "",
						"message":    "API error",
					},
				},
			},
		},
	}

	data, err := json.MarshalIndent(example, "", "  ")
	if err != nil {
		return err
	}

	fmt.Println(string(data))
	fmt.Fprintln(os.Stderr, "\n# Save this to a file and use with: cel-test eval --data testdata.json \"expression\"")
	return nil
}

// loadCRFile loads an Aggregate or Bundle CR from a YAML file
// It handles multi-document YAML files and returns the first document with derivedValues
func loadCRFile(filename string) (*CRDocument, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read CR file: %w", err)
	}

	// Split by YAML document separator and find one with derivedValues
	scanner := bufio.NewScanner(strings.NewReader(string(data)))
	scanner.Split(splitYAMLDocuments)

	var bestDoc *CRDocument
	for scanner.Scan() {
		docData := scanner.Text()
		if strings.TrimSpace(docData) == "" {
			continue
		}

		var doc CRDocument
		if err := yaml.Unmarshal([]byte(docData), &doc); err != nil {
			continue // Skip invalid documents
		}

		// Check if this is an Aggregate or Bundle
		if !strings.HasSuffix(doc.Kind, "Aggregate") && !strings.HasSuffix(doc.Kind, "Bundle") {
			continue
		}

		// Prefer documents with derivedValues
		if len(doc.Spec.DerivedValues) > 0 {
			return &doc, nil
		}

		// Keep first valid Aggregate/Bundle as fallback
		if bestDoc == nil {
			bestDoc = &doc
		}
	}

	if bestDoc != nil {
		return bestDoc, nil
	}

	// Try parsing as single document
	var doc CRDocument
	if err := yaml.Unmarshal(data, &doc); err != nil {
		return nil, fmt.Errorf("failed to parse CR YAML: %w", err)
	}

	return &doc, nil
}

// splitYAMLDocuments is a bufio.SplitFunc that splits YAML documents
func splitYAMLDocuments(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}

	// Look for document separator "---"
	sep := []byte("\n---")
	if i := strings.Index(string(data), string(sep)); i >= 0 {
		return i + len(sep), data[:i], nil
	}

	// If at EOF, return remaining data
	if atEOF {
		return len(data), data, nil
	}

	// Request more data
	return 0, nil, nil
}

// ResourceCR represents a parsed child resource CR (Order, Pet, User, etc.)
type ResourceCR struct {
	APIVersion string                 `yaml:"apiVersion" json:"apiVersion"`
	Kind       string                 `yaml:"kind" json:"kind"`
	Metadata   map[string]interface{} `yaml:"metadata" json:"metadata"`
	Spec       map[string]interface{} `yaml:"spec" json:"spec"`
	Status     map[string]interface{} `yaml:"status" json:"status"`
}

// loadResourcesCRs loads child resource CRs from a multi-document YAML file
// Returns a map keyed by "kind/namespace/name" for lookup
func loadResourcesCRs(filename string) (map[string]*ResourceCR, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read resources file: %w", err)
	}

	resources := make(map[string]*ResourceCR)

	// Split by YAML document separator
	scanner := bufio.NewScanner(strings.NewReader(string(data)))
	scanner.Split(splitYAMLDocuments)

	for scanner.Scan() {
		docData := scanner.Text()
		if strings.TrimSpace(docData) == "" {
			continue
		}

		var cr ResourceCR
		if err := yaml.Unmarshal([]byte(docData), &cr); err != nil {
			continue // Skip invalid documents
		}

		// Skip if no kind or metadata
		if cr.Kind == "" || cr.Metadata == nil {
			continue
		}

		// Skip Aggregate/Bundle CRs - we only want child resources
		if strings.HasSuffix(cr.Kind, "Aggregate") || strings.HasSuffix(cr.Kind, "Bundle") {
			continue
		}

		// Build lookup key: kind/namespace/name
		name, _ := cr.Metadata["name"].(string)
		namespace, _ := cr.Metadata["namespace"].(string)
		if namespace == "" {
			namespace = "default"
		}
		key := fmt.Sprintf("%s/%s/%s", cr.Kind, namespace, name)
		resources[key] = &cr
	}

	return resources, nil
}

// generateMockDataFromCR generates mock test data based on CR resourceSelectors
// This allows testing expressions without actual status data
func generateMockDataFromCR(cr *CRDocument) *TestData {
	testData := &TestData{
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	// Use shared summary counter for consistent state classification
	var summaryCounter celutil.SummaryCounter

	// Collect kinds from resourceSelectors and explicit resources
	kinds := make(map[string]bool)

	for _, selector := range cr.Spec.ResourceSelectors {
		if kind, ok := selector["kind"].(string); ok {
			kinds[kind] = true
		}
	}

	for _, res := range cr.Spec.Resources {
		if kind, ok := res["kind"].(string); ok {
			kinds[kind] = true
		}
	}

	// Generate 4 resources per kind (2 synced, 1 failed, 1 pending)
	states := []struct {
		state   string
		count   int
		message string
	}{
		{"Synced", 2, "Successfully synced with API"},
		{"Failed", 1, "API returned error"},
		{"Pending", 1, "Waiting for API response"},
	}

	resourceNum := 1
	for kind := range kinds {
		kindLower := strings.ToLower(kind)
		kindKey := kindLower + "s"

		for _, stateInfo := range states {
			for i := 0; i < stateInfo.count; i++ {
				resource := map[string]interface{}{
					"kind": kind,
					"metadata": map[string]interface{}{
						"name":      fmt.Sprintf("%s-%03d", kindLower, resourceNum),
						"namespace": "default",
					},
					"spec": map[string]interface{}{
						"id":   resourceNum,
						"name": fmt.Sprintf("Mock %s %d", kind, resourceNum),
					},
					"status": map[string]interface{}{
						"state":   stateInfo.state,
						"message": stateInfo.message,
					},
				}

				if stateInfo.state == "Synced" {
					resource["status"].(map[string]interface{})["externalID"] = fmt.Sprintf("ext-%s-%03d", kindLower, resourceNum)
				} else {
					resource["status"].(map[string]interface{})["externalID"] = ""
				}

				testData.Resources = append(testData.Resources, resource)
				testData.KindLists[kindKey] = append(testData.KindLists[kindKey], resource)

				// Update summary using shared classification logic
				summaryCounter.Add(stateInfo.state)

				resourceNum++
			}
		}
	}

	// Set summary from counter
	testData.Summary = summaryCounter.ToMap()

	return testData
}

// convertCRStatusToTestData converts CR status to TestData format
// If resourceCRs is provided, it looks up spec data from the child CRs
func convertCRStatusToTestData(cr *CRDocument, resourceCRs map[string]*ResourceCR) *TestData {
	testData := &TestData{
		Summary: map[string]int64{
			"total":   0,
			"synced":  0,
			"failed":  0,
			"pending": 0,
			"skipped": 0,
		},
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	// Copy summary if present
	if cr.Status.Summary != nil {
		for k, v := range cr.Status.Summary {
			testData.Summary[k] = v
		}
	}

	// Convert resources - the CR status resources have a different structure
	// than what CEL expects, so we need to transform them
	for _, res := range cr.Status.Resources {
		kindStr, _ := res["kind"].(string)
		nameStr, _ := res["name"].(string)
		namespaceStr, _ := res["namespace"].(string)
		if namespaceStr == "" {
			namespaceStr = "default"
		}

		// Build a resource object that matches what CEL expects
		resource := map[string]interface{}{
			"kind": kindStr,
			"metadata": map[string]interface{}{
				"name":      nameStr,
				"namespace": namespaceStr,
			},
			"status": map[string]interface{}{
				"state":      res["state"],
				"externalID": res["externalID"],
				"message":    res["message"],
			},
			// Default to empty spec
			"spec": map[string]interface{}{},
		}

		// Look up spec from resourceCRs if available
		if resourceCRs != nil {
			key := fmt.Sprintf("%s/%s/%s", kindStr, namespaceStr, nameStr)
			if childCR, found := resourceCRs[key]; found && childCR.Spec != nil {
				resource["spec"] = childCR.Spec
				// Also merge any additional metadata (labels, annotations)
				if meta, ok := resource["metadata"].(map[string]interface{}); ok {
					if labels, ok := childCR.Metadata["labels"]; ok {
						meta["labels"] = labels
					}
					if annotations, ok := childCR.Metadata["annotations"]; ok {
						meta["annotations"] = annotations
					}
				}
			}
		}

		testData.Resources = append(testData.Resources, resource)

		// Build kind-specific lists
		if kindStr != "" {
			kindKey := strings.ToLower(kindStr) + "s"
			testData.KindLists[kindKey] = append(testData.KindLists[kindKey], resource)
		}
	}

	return testData
}

func loadTestData() (*TestData, error) {
	testData := &TestData{
		Summary: map[string]int64{
			"total":   0,
			"synced":  0,
			"failed":  0,
			"pending": 0,
			"skipped": 0,
		},
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	// Load child resource CRs if --resources flag is provided
	var resourceCRs map[string]*ResourceCR
	if resourcesFile != "" {
		var err error
		resourceCRs, err = loadResourcesCRs(resourcesFile)
		if err != nil {
			return nil, fmt.Errorf("failed to load resources file: %w", err)
		}
	}

	// Load from CR file if specified (takes precedence over data file for status)
	if crFile != "" {
		cr, err := loadCRFile(crFile)
		if err != nil {
			return nil, fmt.Errorf("failed to load CR file: %w", err)
		}
		loadedCR = cr
		derivedValues = cr.Spec.DerivedValues

		// If --mock flag is set, generate mock data from CR spec
		if mockData {
			testData = generateMockDataFromCR(cr)
		} else if len(cr.Status.Resources) > 0 || cr.Status.Summary != nil {
			// If CR has status data, use it (with optional resource specs from --resources)
			testData = convertCRStatusToTestData(cr, resourceCRs)
		}
	}

	// Load from JSON data file if specified (can override or supplement CR data)
	if dataFile != "" {
		data, err := os.ReadFile(dataFile)
		if err != nil {
			return nil, fmt.Errorf("failed to read data file: %w", err)
		}
		if err := json.Unmarshal(data, testData); err != nil {
			return nil, fmt.Errorf("failed to parse data file: %w", err)
		}
	}

	// Fetch from Kubernetes if --api-group is provided (and we have kinds to fetch)
	if apiGroup != "" && (len(kindVars) > 0 || loadedCR != nil) {
		kubeData, cleanup, err := loadTestDataFromKubernetes()
		if err != nil {
			return nil, fmt.Errorf("failed to fetch from Kubernetes: %w", err)
		}
		if cleanup != nil {
			defer cleanup()
		}
		// Merge Kubernetes data with any existing data
		if kubeData != nil {
			testData = kubeData
		}
	}

	// Override summary if provided via flag
	if summaryJSON != "" {
		if err := json.Unmarshal([]byte(summaryJSON), &testData.Summary); err != nil {
			return nil, fmt.Errorf("failed to parse summary JSON: %w", err)
		}
	}

	// Initialize kind lists from flag if not in data file
	for _, kind := range kindVars {
		if _, exists := testData.KindLists[kind]; !exists {
			testData.KindLists[kind] = []map[string]interface{}{}
		}
	}

	// If no data file and no CR status, create some default test data
	if dataFile == "" && crFile == "" && apiGroup == "" && len(testData.Resources) == 0 {
		testData.Summary = map[string]int64{
			"total":   5,
			"synced":  3,
			"failed":  1,
			"pending": 1,
			"skipped": 0,
		}
	}

	return testData, nil
}

// loadTestDataFromKubernetes fetches resources from Kubernetes for use in eval/expressions/interactive
func loadTestDataFromKubernetes() (*TestData, func(), error) {
	// Determine which kinds to fetch
	kinds := kindVars

	// If no kinds specified, try to get them from the loaded CR
	if len(kinds) == 0 && loadedCR != nil {
		kindSet := make(map[string]bool)
		for _, selector := range loadedCR.Spec.ResourceSelectors {
			if kind, ok := selector["kind"].(string); ok {
				kindSet[kind] = true
			}
		}
		for _, res := range loadedCR.Spec.Resources {
			if kind, ok := res["kind"].(string); ok {
				kindSet[kind] = true
			}
		}
		for kind := range kindSet {
			kinds = append(kinds, kind)
		}
	}

	if len(kinds) == 0 {
		return nil, nil, fmt.Errorf("no kinds specified: use --kinds flag or --cr with resourceSelectors")
	}

	// Get Kubernetes client
	client, cleanup, err := getKubernetesClient()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get Kubernetes client: %w", err)
	}

	// Fetch resources
	testData, err := fetchResourcesFromCluster(client, kinds)
	if err != nil {
		if cleanup != nil {
			cleanup()
		}
		return nil, nil, fmt.Errorf("failed to fetch resources: %w", err)
	}

	// Print summary of fetched resources
	fmt.Printf("Fetched %d resources from Kubernetes:\n", len(testData.Resources))
	for kind, resources := range testData.KindLists {
		fmt.Printf("  %s: %d\n", kind, len(resources))
	}
	fmt.Println()

	return testData, cleanup, nil
}

// runExpressions lists and evaluates derived value expressions from a CR
func runExpressions(cmd *cobra.Command, args []string) error {
	// Load the CR file
	cr, err := loadCRFile(crFile)
	if err != nil {
		return fmt.Errorf("failed to load CR file: %w", err)
	}

	if len(cr.Spec.DerivedValues) == 0 {
		fmt.Println("No derivedValues expressions found in the CR.")
		return nil
	}

	// Load test data for evaluation
	testData, err := loadTestData()
	if err != nil {
		return fmt.Errorf("failed to load test data: %w", err)
	}

	// Create CEL environment
	env, err := createCELEnv(testData)
	if err != nil {
		return fmt.Errorf("failed to create CEL environment: %w", err)
	}

	fmt.Printf("CR: %s/%s (%s)\n", cr.Kind, cr.Metadata["name"], cr.APIVersion)
	fmt.Printf("Found %d derived value expression(s):\n\n", len(cr.Spec.DerivedValues))

	hasData := len(testData.Resources) > 0 || testData.Summary["total"] > 0

	for i, dv := range cr.Spec.DerivedValues {
		fmt.Printf("%d. %s\n", i+1, dv.Name)
		fmt.Printf("   Expression: %s\n", dv.Expression)

		if hasData {
			result, evalErr := evaluateExpression(env, dv.Expression, testData)
			if evalErr != nil {
				fmt.Printf("   Error: %v\n", evalErr)
			} else {
				fmt.Printf("   Result: %v (%s)\n", result, reflect.TypeOf(result))
			}
		} else {
			fmt.Printf("   (No test data available for evaluation)\n")
		}
		fmt.Println()
	}

	if !hasData {
		fmt.Println("Tip: Provide test data with --data <file.json> to evaluate expressions")
	}

	return nil
}

func createCELEnv(testData *TestData) (*cel.Env, error) {
	// Extract kind names from the KindLists map
	kindNames := make([]string, 0, len(testData.KindLists))
	for kindName := range testData.KindLists {
		kindNames = append(kindNames, kindName)
	}

	// Use the shared CEL environment factory
	return celutil.NewEnvironment(kindNames)
}

func evaluateExpression(env *cel.Env, expression string, testData *TestData) (interface{}, error) {
	// Build evaluation variables using the shared helper
	vars := celutil.BuildVariables(testData.Resources, testData.Summary, testData.KindLists)

	// Use the shared evaluation function
	result := celutil.Evaluate(env, expression, vars)
	if result.Error != nil {
		return nil, result.Error
	}

	return result.Value, nil
}

func printHelp(testData *TestData) {
	fmt.Println("\nAvailable Variables:")
	fmt.Println("  resources  - List of all resource objects")
	fmt.Println("  summary    - Map with counts: total, synced, failed, pending, skipped")

	if len(testData.KindLists) > 0 {
		fmt.Println("\nKind-specific Lists:")
		for kindName := range testData.KindLists {
			fmt.Printf("  %s - List of %s resources\n", kindName, kindName)
		}
	}

	fmt.Println("\nAggregate Functions:")
	fmt.Println("  sum(list)  - Sum of numeric values in the list")
	fmt.Println("  max(list)  - Maximum value in the list")
	fmt.Println("  min(list)  - Minimum value in the list")
	fmt.Println("  avg(list)  - Average of values in the list")

	fmt.Println("\nExample Expressions:")
	fmt.Println("  summary.total")
	fmt.Println("  summary.synced * 100 / summary.total")
	fmt.Println("  resources.size()")
	fmt.Println("  resources.filter(r, r.status.state == 'Synced').size()")
	if _, ok := testData.KindLists["orders"]; ok {
		fmt.Println("  orders.size()")
		fmt.Println("  sum(orders.map(r, r.spec.quantity))")
		fmt.Println("  max(orders.map(r, has(r.spec.quantity) ? r.spec.quantity : 0))")
	}

	fmt.Println("\nKeyboard Shortcuts:")
	fmt.Println("  Up/Down    - Navigate command history")
	fmt.Println("  Left/Right - Move cursor")
	fmt.Println("  Ctrl+A     - Move to beginning of line")
	fmt.Println("  Ctrl+E     - Move to end of line")
	fmt.Println("  Ctrl+U     - Clear line before cursor")
	fmt.Println("  Ctrl+K     - Clear line after cursor")
	fmt.Println("  Ctrl+W     - Delete word before cursor")
	fmt.Println("  Ctrl+L     - Clear screen")
	fmt.Println("  Ctrl+C     - Cancel current input")
	fmt.Println("  Ctrl+D     - Exit")

	fmt.Println("\nCommands:")
	fmt.Println("  help, h, ?     - Show this help")
	fmt.Println("  data           - Show current test data")
	fmt.Println("  expressions    - Show and evaluate derived value expressions from CR")
	fmt.Println("  history        - Show command history")
	fmt.Println("  reload         - Reload test data from file")
	fmt.Println("  exit, quit     - Exit interactive mode")
	fmt.Println()
}

func printData(testData *TestData) {
	data, _ := json.MarshalIndent(testData, "", "  ")
	fmt.Println(string(data))
}

// printExpressions prints and evaluates derived value expressions from the loaded CR
func printExpressions(env *cel.Env, testData *TestData) {
	if len(derivedValues) == 0 {
		fmt.Println("No derived value expressions loaded.")
		fmt.Println("Use --cr flag to load an Aggregate/Bundle CR with derivedValues.")
		return
	}

	fmt.Printf("\nDerived Value Expressions (%d):\n", len(derivedValues))
	for i, dv := range derivedValues {
		fmt.Printf("\n%d. %s\n", i+1, dv.Name)
		fmt.Printf("   Expression: %s\n", dv.Expression)

		result, err := evaluateExpression(env, dv.Expression, testData)
		if err != nil {
			fmt.Printf("   Error: %v\n", err)
		} else {
			fmt.Printf("   Result: %v (%s)\n", result, reflect.TypeOf(result))
		}
	}
	fmt.Println()
}

// ==================== Kubernetes Functions ====================

// runFetch fetches resources from Kubernetes and uses them for CEL testing
func runFetch(cmd *cobra.Command, args []string) error {
	// Determine which kinds to fetch
	kinds := kindVars
	if len(kinds) == 0 && crFile != "" {
		// Extract kinds from CR if provided
		cr, err := loadCRFile(crFile)
		if err != nil {
			return fmt.Errorf("failed to load CR file: %w", err)
		}
		kindSet := make(map[string]bool)
		for _, selector := range cr.Spec.ResourceSelectors {
			if kind, ok := selector["kind"].(string); ok {
				kindSet[kind] = true
			}
		}
		for _, res := range cr.Spec.Resources {
			if kind, ok := res["kind"].(string); ok {
				kindSet[kind] = true
			}
		}
		for kind := range kindSet {
			kinds = append(kinds, kind)
		}
	}

	if len(kinds) == 0 {
		return fmt.Errorf("no kinds specified: use --kinds flag or --cr with resourceSelectors")
	}

	// Get Kubernetes client
	client, cleanup, err := getKubernetesClient()
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes client: %w", err)
	}
	if cleanup != nil {
		defer cleanup()
	}

	// Fetch resources
	testData, err := fetchResourcesFromCluster(client, kinds)
	if err != nil {
		return fmt.Errorf("failed to fetch resources: %w", err)
	}

	// Print summary
	fmt.Printf("Fetched %d resources from cluster:\n", len(testData.Resources))
	for kind, resources := range testData.KindLists {
		fmt.Printf("  %s: %d\n", kind, len(resources))
	}
	fmt.Printf("\nSummary:\n")
	fmt.Printf("  Total: %d\n", testData.Summary["total"])
	fmt.Printf("  Synced: %d\n", testData.Summary["synced"])
	fmt.Printf("  Failed: %d\n", testData.Summary["failed"])
	fmt.Printf("  Pending: %d\n", testData.Summary["pending"])
	fmt.Println()

	// If --eval flag provided, evaluate the expression
	if evalExpr != "" {
		env, err := createCELEnv(testData)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment: %w", err)
		}

		result, err := evaluateExpression(env, evalExpr, testData)
		if err != nil {
			return fmt.Errorf("evaluation error: %w", err)
		}

		fmt.Printf("Expression: %s\n", evalExpr)
		fmt.Printf("Result: %v\n", result)
		fmt.Printf("Type: %s\n", reflect.TypeOf(result))
		return nil
	}

	// If --output-yaml flag provided, save resources as multi-document YAML
	if outputYAML != "" {
		yamlData, err := resourcesToYAML(testData.Resources)
		if err != nil {
			return fmt.Errorf("failed to marshal resources to YAML: %w", err)
		}
		if err := os.WriteFile(outputYAML, []byte(yamlData), 0644); err != nil {
			return fmt.Errorf("failed to write YAML file: %w", err)
		}
		fmt.Printf("Resources saved to: %s\n", outputYAML)
		fmt.Println("Use with: cel-test eval --cr aggregate.yaml --resources", outputYAML, "\"expression\"")
		return nil
	}

	// Output as JSON
	data, err := json.MarshalIndent(testData, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal test data: %w", err)
	}

	// If --output flag provided, save to file
	if outputFile != "" {
		if err := os.WriteFile(outputFile, data, 0644); err != nil {
			return fmt.Errorf("failed to write output file: %w", err)
		}
		fmt.Printf("Test data saved to: %s\n", outputFile)
		fmt.Println("Use with: cel-test eval --data", outputFile, "\"expression\"")
	} else {
		fmt.Println("# Test data JSON (use with --data flag or --output to save):")
		fmt.Println(string(data))
	}

	return nil
}

// getKubernetesClient returns a dynamic Kubernetes client and optional cleanup function
func getKubernetesClient() (dynamic.Interface, func(), error) {
	var cfg *rest.Config
	var cleanup func()
	var err error

	if useEnvtest {
		cfg, cleanup, err = setupEnvtest()
		if err != nil {
			return nil, nil, fmt.Errorf("failed to setup envtest: %w", err)
		}
	} else {
		cfg, err = getKubeconfig()
		if err != nil {
			return nil, nil, fmt.Errorf("failed to get kubeconfig: %w", err)
		}
	}

	client, err := dynamic.NewForConfig(cfg)
	if err != nil {
		if cleanup != nil {
			cleanup()
		}
		return nil, nil, fmt.Errorf("failed to create dynamic client: %w", err)
	}

	return client, cleanup, nil
}

// getKubeconfig returns a Kubernetes REST config from kubeconfig file
func getKubeconfig() (*rest.Config, error) {
	var kubeconfigPath string

	if kubeconfig != "" {
		kubeconfigPath = kubeconfig
	} else if home := homedir.HomeDir(); home != "" {
		kubeconfigPath = filepath.Join(home, ".kube", "config")
	}

	// Try in-cluster config first if no explicit kubeconfig
	if kubeconfigPath == "" {
		cfg, err := rest.InClusterConfig()
		if err == nil {
			return cfg, nil
		}
	}

	// Build config from kubeconfig file
	cfg, err := clientcmd.BuildConfigFromFlags("", kubeconfigPath)
	if err != nil {
		return nil, fmt.Errorf("failed to build config from kubeconfig: %w", err)
	}

	return cfg, nil
}

// setupEnvtest sets up an envtest environment with CRDs
func setupEnvtest() (*rest.Config, func(), error) {
	if len(crdPaths) == 0 {
		return nil, nil, fmt.Errorf("--crd-paths required when using --envtest")
	}

	testEnv = &envtest.Environment{
		CRDDirectoryPaths:     crdPaths,
		ErrorIfCRDPathMissing: true,
	}

	cfg, err := testEnv.Start()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to start envtest: %w", err)
	}

	restConfig = cfg

	cleanup := func() {
		if testEnv != nil {
			testEnv.Stop()
		}
	}

	fmt.Println("Started envtest environment")
	return cfg, cleanup, nil
}

// fetchResourcesFromCluster fetches resources of specified kinds from the cluster
func fetchResourcesFromCluster(client dynamic.Interface, kinds []string) (*TestData, error) {
	testData := &TestData{
		Resources: []map[string]interface{}{},
		KindLists: map[string][]map[string]interface{}{},
	}

	// Use shared summary counter for consistent state classification
	var summaryCounter celutil.SummaryCounter

	ctx := context.Background()

	for _, kind := range kinds {
		// Build GVR for the resource
		gvr := schema.GroupVersionResource{
			Group:    apiGroup,
			Version:  apiVersion,
			Resource: strings.ToLower(kind) + "s", // Pluralize (simple approach)
		}

		var list *unstructured.UnstructuredList
		var err error

		if kubeNamespace != "" {
			list, err = client.Resource(gvr).Namespace(kubeNamespace).List(ctx, metav1.ListOptions{})
		} else {
			list, err = client.Resource(gvr).List(ctx, metav1.ListOptions{})
		}

		if err != nil {
			fmt.Printf("Warning: failed to list %s: %v\n", kind, err)
			continue
		}

		kindKey := strings.ToLower(kind) + "s"
		testData.KindLists[kindKey] = []map[string]interface{}{}

		for _, item := range list.Items {
			resource := convertUnstructuredToResource(&item, kind)
			testData.Resources = append(testData.Resources, resource)
			testData.KindLists[kindKey] = append(testData.KindLists[kindKey], resource)

			// Update summary based on status using shared classification logic
			state := ""
			if status, ok := resource["status"].(map[string]interface{}); ok {
				if s, ok := status["state"].(string); ok {
					state = s
				}
			}
			summaryCounter.Add(state)
		}
	}

	// Set summary from counter
	testData.Summary = summaryCounter.ToMap()

	return testData, nil
}

// convertUnstructuredToResource converts an unstructured Kubernetes resource to our map format
func convertUnstructuredToResource(u *unstructured.Unstructured, kind string) map[string]interface{} {
	resource := map[string]interface{}{
		"kind": kind,
		"metadata": map[string]interface{}{
			"name":      u.GetName(),
			"namespace": u.GetNamespace(),
		},
		"spec":   map[string]interface{}{},
		"status": map[string]interface{}{},
	}

	// Copy labels and annotations if present
	if labels := u.GetLabels(); len(labels) > 0 {
		resource["metadata"].(map[string]interface{})["labels"] = labels
	}
	if annotations := u.GetAnnotations(); len(annotations) > 0 {
		resource["metadata"].(map[string]interface{})["annotations"] = annotations
	}

	// Copy spec
	if spec, found, _ := unstructured.NestedMap(u.Object, "spec"); found {
		resource["spec"] = spec
	}

	// Copy status
	if status, found, _ := unstructured.NestedMap(u.Object, "status"); found {
		resource["status"] = status
	}

	return resource
}

// resourcesToYAML converts a list of resources to multi-document YAML format
// The output format is compatible with the --resources flag
func resourcesToYAML(resources []map[string]interface{}) (string, error) {
	if len(resources) == 0 {
		return "# No resources found\n", nil
	}

	var builder strings.Builder
	builder.WriteString("# Generated by cel-test fetch\n")
	builder.WriteString("# Use with: cel-test eval --cr <aggregate.yaml> --resources <this-file>\n")

	for i, res := range resources {
		if i > 0 {
			builder.WriteString("---\n")
		}

		// Build a proper CR structure
		cr := map[string]interface{}{
			"apiVersion": fmt.Sprintf("%s/%s", apiGroup, apiVersion),
			"kind":       res["kind"],
			"metadata":   res["metadata"],
			"spec":       res["spec"],
		}

		// Include status if present and non-empty
		if status, ok := res["status"].(map[string]interface{}); ok && len(status) > 0 {
			cr["status"] = status
		}

		yamlBytes, err := yaml.Marshal(cr)
		if err != nil {
			return "", fmt.Errorf("failed to marshal resource %v: %w", res["metadata"], err)
		}
		builder.Write(yamlBytes)
	}

	return builder.String(), nil
}
